; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	E:\nightfire_sdk\amx\amxmodx\string.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CA@BOKAAEHK@Pos?5has?5to?5be?5a?5positive?5number?$AA@ ; `string'
PUBLIC	?string_Natives@@3PAUtagAMX_NATIVE_INFO@@A	; string_Natives
PUBLIC	??_C@_0CE@BPGCCENF@Invalid?5vararg?5parameter?5passed?3@ ; `string'
PUBLIC	??_C@_03BDGOHNNK@add?$AA@			; `string'
PUBLIC	??_C@_07LIAJLFAH@contain?$AA@			; `string'
PUBLIC	??_C@_08CKODEMPI@containi?$AA@			; `string'
PUBLIC	??_C@_04COAGEIMF@copy?$AA@			; `string'
PUBLIC	??_C@_05KFPAAIBD@copyc?$AA@			; `string'
PUBLIC	??_C@_05OAKNMNI@equal?$AA@			; `string'
PUBLIC	??_C@_06DMDJIANE@equali?$AA@			; `string'
PUBLIC	??_C@_03MLKKGMLN@fmt?$AA@			; `string'
PUBLIC	??_C@_06DLEPGFEF@format?$AA@			; `string'
PUBLIC	??_C@_08BJCMOPON@formatex?$AA@			; `string'
PUBLIC	??_C@_0M@KKJIOJF@format_args?$AA@		; `string'
PUBLIC	??_C@_07CFBKIKCH@isdigit?$AA@			; `string'
PUBLIC	??_C@_07EOADCIGC@isalnum?$AA@			; `string'
PUBLIC	??_C@_07CNBMLEON@isspace?$AA@			; `string'
PUBLIC	??_C@_07EGIOHHOB@isalpha?$AA@			; `string'
PUBLIC	??_C@_0O@KEPPMDBB@is_char_upper?$AA@		; `string'
PUBLIC	??_C@_0O@PPEBKIKI@is_char_lower?$AA@		; `string'
PUBLIC	??_C@_0L@CNFJNCLK@is_char_mb?$AA@		; `string'
PUBLIC	??_C@_0BD@OPFHAMAJ@is_string_category?$AA@	; `string'
PUBLIC	??_C@_0P@KJJEJCPJ@get_char_bytes?$AA@		; `string'
PUBLIC	??_C@_0O@JPHLEKIB@mb_strtotitle?$AA@		; `string'
PUBLIC	??_C@_0O@OHFJCPCA@mb_strtolower?$AA@		; `string'
PUBLIC	??_C@_0O@LMOHEEJJ@mb_strtoupper?$AA@		; `string'
PUBLIC	??_C@_0L@LPHCPNNN@mb_ucfirst?$AA@		; `string'
PUBLIC	??_C@_0L@MLCNPPEP@num_to_str?$AA@		; `string'
PUBLIC	??_C@_08DPCMHIHH@numtostr?$AA@			; `string'
PUBLIC	??_C@_05GOEGCMJM@parse?$AA@			; `string'
PUBLIC	??_C@_07CLEHDIEJ@replace?$AA@			; `string'
PUBLIC	??_C@_0P@MIKGGNGL@replace_string?$AA@		; `string'
PUBLIC	??_C@_0BB@BMPAJNBK@replace_stringex?$AA@	; `string'
PUBLIC	??_C@_04JGHPGNCE@setc?$AA@			; `string'
PUBLIC	??_C@_08IGPPEDJN@strbreak?$AA@			; `string'
PUBLIC	??_C@_08NCPBOIPA@argparse?$AA@			; `string'
PUBLIC	??_C@_0N@GFHAOFDI@split_string?$AA@		; `string'
PUBLIC	??_C@_0L@EGACLCBB@strtolower?$AA@		; `string'
PUBLIC	??_C@_0L@BNLMNJKI@strtoupper?$AA@		; `string'
PUBLIC	??_C@_0L@FMBPHLPG@str_to_num?$AA@		; `string'
PUBLIC	??_C@_08FBHENKAD@strtonum?$AA@			; `string'
PUBLIC	??_C@_06MCCMIJDC@strtol?$AA@			; `string'
PUBLIC	??_C@_06DIMDGBLI@strtof?$AA@			; `string'
PUBLIC	??_C@_04GDOMMDLP@trim?$AA@			; `string'
PUBLIC	??_C@_07FCGOBCIN@ucfirst?$AA@			; `string'
PUBLIC	??_C@_06INGNBPPF@strtok?$AA@			; `string'
PUBLIC	??_C@_07CACKDPPN@strtok2?$AA@			; `string'
PUBLIC	??_C@_06GICABBBG@strlen?$AA@			; `string'
PUBLIC	??_C@_06IHGHFDEH@strcat?$AA@			; `string'
PUBLIC	??_C@_07PFELJMPK@strfind?$AA@			; `string'
PUBLIC	??_C@_06OKBBGPCH@strcmp?$AA@			; `string'
PUBLIC	??_C@_07IGGOFOFD@strncmp?$AA@			; `string'
PUBLIC	??_C@_0N@KMNNBAGA@str_to_float?$AA@		; `string'
PUBLIC	??_C@_0N@MDDICGFD@float_to_str?$AA@		; `string'
PUBLIC	??_C@_07KJDOPNEF@vformat?$AA@			; `string'
PUBLIC	??_C@_0BM@KJALMONH@No?5search?5string?5specified?4?$AA@ ; `string'
PUBLIC	??_C@_0CJ@NFNJDNGL@replace?$CI?$CJ?5buffer?5not?5big?5enough?5@ ; `string'
PUBLIC	??_C@_0CK@IBLGDDPF@Cannot?5replace?5searches?5of?5empty@ ; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	??_C@_02NJPGOMH@?$CFf?$AA@			; `string'
_BSS	SEGMENT
?g_cpbuf@@3PAHA DD 01000H DUP (?)			; g_cpbuf
_BSS	ENDS
;	COMDAT ?cpbuf@?1??vformat@@YAHPAUtagAMX@@PAH@Z@4PAHA
_BSS	SEGMENT
?cpbuf@?1??vformat@@YAHPAUtagAMX@@PAH@Z@4PAHA DD 01000H DUP (?) ; `vformat'::`2'::cpbuf
_BSS	ENDS
;	COMDAT ??_C@_02NJPGOMH@?$CFf?$AA@
CONST	SEGMENT
??_C@_02NJPGOMH@?$CFf?$AA@ DB '%f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@IBLGDDPF@Cannot?5replace?5searches?5of?5empty@
CONST	SEGMENT
??_C@_0CK@IBLGDDPF@Cannot?5replace?5searches?5of?5empty@ DB 'Cannot repla'
	DB	'ce searches of empty strings.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@NFNJDNGL@replace?$CI?$CJ?5buffer?5not?5big?5enough?5@
CONST	SEGMENT
??_C@_0CJ@NFNJDNGL@replace?$CI?$CJ?5buffer?5not?5big?5enough?5@ DB 'repla'
	DB	'ce() buffer not big enough (%d>=%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KJALMONH@No?5search?5string?5specified?4?$AA@
CONST	SEGMENT
??_C@_0BM@KJALMONH@No?5search?5string?5specified?4?$AA@ DB 'No search str'
	DB	'ing specified.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07KJDOPNEF@vformat?$AA@
CONST	SEGMENT
??_C@_07KJDOPNEF@vformat?$AA@ DB 'vformat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MDDICGFD@float_to_str?$AA@
CONST	SEGMENT
??_C@_0N@MDDICGFD@float_to_str?$AA@ DB 'float_to_str', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KMNNBAGA@str_to_float?$AA@
CONST	SEGMENT
??_C@_0N@KMNNBAGA@str_to_float?$AA@ DB 'str_to_float', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IGGOFOFD@strncmp?$AA@
CONST	SEGMENT
??_C@_07IGGOFOFD@strncmp?$AA@ DB 'strncmp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OKBBGPCH@strcmp?$AA@
CONST	SEGMENT
??_C@_06OKBBGPCH@strcmp?$AA@ DB 'strcmp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PFELJMPK@strfind?$AA@
CONST	SEGMENT
??_C@_07PFELJMPK@strfind?$AA@ DB 'strfind', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IHGHFDEH@strcat?$AA@
CONST	SEGMENT
??_C@_06IHGHFDEH@strcat?$AA@ DB 'strcat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GICABBBG@strlen?$AA@
CONST	SEGMENT
??_C@_06GICABBBG@strlen?$AA@ DB 'strlen', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CACKDPPN@strtok2?$AA@
CONST	SEGMENT
??_C@_07CACKDPPN@strtok2?$AA@ DB 'strtok2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06INGNBPPF@strtok?$AA@
CONST	SEGMENT
??_C@_06INGNBPPF@strtok?$AA@ DB 'strtok', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FCGOBCIN@ucfirst?$AA@
CONST	SEGMENT
??_C@_07FCGOBCIN@ucfirst?$AA@ DB 'ucfirst', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GDOMMDLP@trim?$AA@
CONST	SEGMENT
??_C@_04GDOMMDLP@trim?$AA@ DB 'trim', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DIMDGBLI@strtof?$AA@
CONST	SEGMENT
??_C@_06DIMDGBLI@strtof?$AA@ DB 'strtof', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MCCMIJDC@strtol?$AA@
CONST	SEGMENT
??_C@_06MCCMIJDC@strtol?$AA@ DB 'strtol', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FBHENKAD@strtonum?$AA@
CONST	SEGMENT
??_C@_08FBHENKAD@strtonum?$AA@ DB 'strtonum', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FMBPHLPG@str_to_num?$AA@
CONST	SEGMENT
??_C@_0L@FMBPHLPG@str_to_num?$AA@ DB 'str_to_num', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BNLMNJKI@strtoupper?$AA@
CONST	SEGMENT
??_C@_0L@BNLMNJKI@strtoupper?$AA@ DB 'strtoupper', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EGACLCBB@strtolower?$AA@
CONST	SEGMENT
??_C@_0L@EGACLCBB@strtolower?$AA@ DB 'strtolower', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GFHAOFDI@split_string?$AA@
CONST	SEGMENT
??_C@_0N@GFHAOFDI@split_string?$AA@ DB 'split_string', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08NCPBOIPA@argparse?$AA@
CONST	SEGMENT
??_C@_08NCPBOIPA@argparse?$AA@ DB 'argparse', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08IGPPEDJN@strbreak?$AA@
CONST	SEGMENT
??_C@_08IGPPEDJN@strbreak?$AA@ DB 'strbreak', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04JGHPGNCE@setc?$AA@
CONST	SEGMENT
??_C@_04JGHPGNCE@setc?$AA@ DB 'setc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BMPAJNBK@replace_stringex?$AA@
CONST	SEGMENT
??_C@_0BB@BMPAJNBK@replace_stringex?$AA@ DB 'replace_stringex', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MIKGGNGL@replace_string?$AA@
CONST	SEGMENT
??_C@_0P@MIKGGNGL@replace_string?$AA@ DB 'replace_string', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CLEHDIEJ@replace?$AA@
CONST	SEGMENT
??_C@_07CLEHDIEJ@replace?$AA@ DB 'replace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GOEGCMJM@parse?$AA@
CONST	SEGMENT
??_C@_05GOEGCMJM@parse?$AA@ DB 'parse', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DPCMHIHH@numtostr?$AA@
CONST	SEGMENT
??_C@_08DPCMHIHH@numtostr?$AA@ DB 'numtostr', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MLCNPPEP@num_to_str?$AA@
CONST	SEGMENT
??_C@_0L@MLCNPPEP@num_to_str?$AA@ DB 'num_to_str', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LPHCPNNN@mb_ucfirst?$AA@
CONST	SEGMENT
??_C@_0L@LPHCPNNN@mb_ucfirst?$AA@ DB 'mb_ucfirst', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LMOHEEJJ@mb_strtoupper?$AA@
CONST	SEGMENT
??_C@_0O@LMOHEEJJ@mb_strtoupper?$AA@ DB 'mb_strtoupper', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OHFJCPCA@mb_strtolower?$AA@
CONST	SEGMENT
??_C@_0O@OHFJCPCA@mb_strtolower?$AA@ DB 'mb_strtolower', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JPHLEKIB@mb_strtotitle?$AA@
CONST	SEGMENT
??_C@_0O@JPHLEKIB@mb_strtotitle?$AA@ DB 'mb_strtotitle', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KJJEJCPJ@get_char_bytes?$AA@
CONST	SEGMENT
??_C@_0P@KJJEJCPJ@get_char_bytes?$AA@ DB 'get_char_bytes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OPFHAMAJ@is_string_category?$AA@
CONST	SEGMENT
??_C@_0BD@OPFHAMAJ@is_string_category?$AA@ DB 'is_string_category', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CNFJNCLK@is_char_mb?$AA@
CONST	SEGMENT
??_C@_0L@CNFJNCLK@is_char_mb?$AA@ DB 'is_char_mb', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PPEBKIKI@is_char_lower?$AA@
CONST	SEGMENT
??_C@_0O@PPEBKIKI@is_char_lower?$AA@ DB 'is_char_lower', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KEPPMDBB@is_char_upper?$AA@
CONST	SEGMENT
??_C@_0O@KEPPMDBB@is_char_upper?$AA@ DB 'is_char_upper', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07EGIOHHOB@isalpha?$AA@
CONST	SEGMENT
??_C@_07EGIOHHOB@isalpha?$AA@ DB 'isalpha', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CNBMLEON@isspace?$AA@
CONST	SEGMENT
??_C@_07CNBMLEON@isspace?$AA@ DB 'isspace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EOADCIGC@isalnum?$AA@
CONST	SEGMENT
??_C@_07EOADCIGC@isalnum?$AA@ DB 'isalnum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CFBKIKCH@isdigit?$AA@
CONST	SEGMENT
??_C@_07CFBKIKCH@isdigit?$AA@ DB 'isdigit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KKJIOJF@format_args?$AA@
CONST	SEGMENT
??_C@_0M@KKJIOJF@format_args?$AA@ DB 'format_args', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BJCMOPON@formatex?$AA@
CONST	SEGMENT
??_C@_08BJCMOPON@formatex?$AA@ DB 'formatex', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06DLEPGFEF@format?$AA@
CONST	SEGMENT
??_C@_06DLEPGFEF@format?$AA@ DB 'format', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MLKKGMLN@fmt?$AA@
CONST	SEGMENT
??_C@_03MLKKGMLN@fmt?$AA@ DB 'fmt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06DMDJIANE@equali?$AA@
CONST	SEGMENT
??_C@_06DMDJIANE@equali?$AA@ DB 'equali', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OAKNMNI@equal?$AA@
CONST	SEGMENT
??_C@_05OAKNMNI@equal?$AA@ DB 'equal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KFPAAIBD@copyc?$AA@
CONST	SEGMENT
??_C@_05KFPAAIBD@copyc?$AA@ DB 'copyc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04COAGEIMF@copy?$AA@
CONST	SEGMENT
??_C@_04COAGEIMF@copy?$AA@ DB 'copy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CKODEMPI@containi?$AA@
CONST	SEGMENT
??_C@_08CKODEMPI@containi?$AA@ DB 'containi', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LIAJLFAH@contain?$AA@
CONST	SEGMENT
??_C@_07LIAJLFAH@contain?$AA@ DB 'contain', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BDGOHNNK@add?$AA@
CONST	SEGMENT
??_C@_03BDGOHNNK@add?$AA@ DB 'add', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@BPGCCENF@Invalid?5vararg?5parameter?5passed?3@
CONST	SEGMENT
??_C@_0CE@BPGCCENF@Invalid?5vararg?5parameter?5passed?3@ DB 'Invalid vara'
	DB	'rg parameter passed: %d', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
?string_Natives@@3PAUtagAMX_NATIVE_INFO@@A DD FLAT:??_C@_03BDGOHNNK@add?$AA@ ; string_Natives
	DD	FLAT:?add@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_07LIAJLFAH@contain?$AA@
	DD	FLAT:?contain@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_08CKODEMPI@containi?$AA@
	DD	FLAT:?containi@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_04COAGEIMF@copy?$AA@
	DD	FLAT:?copy@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_05KFPAAIBD@copyc?$AA@
	DD	FLAT:?copyc@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_05OAKNMNI@equal?$AA@
	DD	FLAT:?equal@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_06DMDJIANE@equali?$AA@
	DD	FLAT:?equali@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_03MLKKGMLN@fmt?$AA@
	DD	FLAT:?fmt@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_06DLEPGFEF@format?$AA@
	DD	FLAT:?format@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_08BJCMOPON@formatex?$AA@
	DD	FLAT:?formatex@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0M@KKJIOJF@format_args?$AA@
	DD	FLAT:?format_args@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_07CFBKIKCH@isdigit?$AA@
	DD	FLAT:?is_digit@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_07EOADCIGC@isalnum?$AA@
	DD	FLAT:?is_alnum@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_07CNBMLEON@isspace?$AA@
	DD	FLAT:?is_space@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_07EGIOHHOB@isalpha?$AA@
	DD	FLAT:?is_alpha@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0O@KEPPMDBB@is_char_upper?$AA@
	DD	FLAT:?is_char_upper@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0O@PPEBKIKI@is_char_lower?$AA@
	DD	FLAT:?is_char_lower@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0L@CNFJNCLK@is_char_mb?$AA@
	DD	FLAT:?is_char_mb@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0BD@OPFHAMAJ@is_string_category?$AA@
	DD	FLAT:?is_string_category@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0P@KJJEJCPJ@get_char_bytes?$AA@
	DD	FLAT:?get_char_bytes@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0O@JPHLEKIB@mb_strtotitle?$AA@
	DD	FLAT:?mb_strtotitle@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0O@OHFJCPCA@mb_strtolower?$AA@
	DD	FLAT:?mb_strtolower@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0O@LMOHEEJJ@mb_strtoupper?$AA@
	DD	FLAT:?mb_strtoupper@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0L@LPHCPNNN@mb_ucfirst?$AA@
	DD	FLAT:?mb_ucfirst@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0L@MLCNPPEP@num_to_str?$AA@
	DD	FLAT:?numtostr@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_08DPCMHIHH@numtostr?$AA@
	DD	FLAT:?numtostr@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_05GOEGCMJM@parse?$AA@
	DD	FLAT:?parse@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_07CLEHDIEJ@replace?$AA@
	DD	FLAT:?replace@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0P@MIKGGNGL@replace_string?$AA@
	DD	FLAT:?replace_string@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0BB@BMPAJNBK@replace_stringex?$AA@
	DD	FLAT:?replace_stringex@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_04JGHPGNCE@setc?$AA@
	DD	FLAT:?setc@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_08IGPPEDJN@strbreak?$AA@
	DD	FLAT:?strbreak@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_08NCPBOIPA@argparse?$AA@
	DD	FLAT:?argparse@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0N@GFHAOFDI@split_string?$AA@
	DD	FLAT:?split_string@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0L@EGACLCBB@strtolower?$AA@
	DD	FLAT:?strtolower@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0L@BNLMNJKI@strtoupper?$AA@
	DD	FLAT:?strtoupper@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0L@FMBPHLPG@str_to_num?$AA@
	DD	FLAT:?strtonum@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_08FBHENKAD@strtonum?$AA@
	DD	FLAT:?strtonum@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_06MCCMIJDC@strtol?$AA@
	DD	FLAT:?amx_strtol@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_06DIMDGBLI@strtof?$AA@
	DD	FLAT:?amx_strtof@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_04GDOMMDLP@trim?$AA@
	DD	FLAT:?amx_trim@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_07FCGOBCIN@ucfirst?$AA@
	DD	FLAT:?amx_ucfirst@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_06INGNBPPF@strtok?$AA@
	DD	FLAT:?amx_strtok@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_07CACKDPPN@strtok2?$AA@
	DD	FLAT:?amx_strtok2@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_06GICABBBG@strlen?$AA@
	DD	FLAT:?amx_strlen@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_06IHGHFDEH@strcat?$AA@
	DD	FLAT:?n_strcat@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_07PFELJMPK@strfind?$AA@
	DD	FLAT:?n_strfind@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_06OKBBGPCH@strcmp?$AA@
	DD	FLAT:?n_strcmp@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_07IGGOFOFD@strncmp?$AA@
	DD	FLAT:?n_strncmp@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0N@KMNNBAGA@str_to_float?$AA@
	DD	FLAT:?str_to_float@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0N@MDDICGFD@float_to_str?$AA@
	DD	FLAT:?float_to_str@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_07KJDOPNEF@vformat?$AA@
	DD	FLAT:?vformat@@YAHPAUtagAMX@@PAH@Z
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_C@_0CA@BOKAAEHK@Pos?5has?5to?5be?5a?5positive?5number?$AA@
CONST	SEGMENT
??_C@_0CA@BOKAAEHK@Pos?5has?5to?5be?5a?5positive?5number?$AA@ DB 'Pos has'
	DB	' to be a positive number', 00H		; `string'
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_sprintf
PUBLIC	?stristr@@YAPBDPBD0@Z				; stristr
PUBLIC	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z		; get_amxaddr
PUBLIC	?format_amxstring@@YAPADPAUtagAMX@@PAHHAAH@Z	; format_amxstring
PUBLIC	?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z		; get_amxstring
PUBLIC	?get_amxstring_null@@YAPADPAUtagAMX@@HHAAH@Z	; get_amxstring_null
PUBLIC	?get_amxvector_null@@YAPAHPAUtagAMX@@H@Z	; get_amxvector_null
PUBLIC	_get_amxstring_r
PUBLIC	?amxstring_len@@YAHPAH@Z			; amxstring_len
PUBLIC	?set_amxstring@@YAHPAUtagAMX@@HPBDH@Z		; set_amxstring
PUBLIC	?set_amxstring_simple@@YAHPAHPBDH@Z		; set_amxstring_simple
PUBLIC	?set_amxstring_utf8_char@@YAHPAUtagAMX@@HPBDII@Z ; set_amxstring_utf8_char
PUBLIC	?set_amxstring_utf8_cell@@YAHPAUtagAMX@@HPBHII@Z ; set_amxstring_utf8_cell
PUBLIC	?copy_amxmemory@@YAXPAH0H@Z			; copy_amxmemory
PUBLIC	??$set_amxstring_utf8@H@@YAHPAUtagAMX@@HPBHII@Z	; set_amxstring_utf8<int>
PUBLIC	??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z	; set_amxstring_utf8<char>
PUBLIC	?get_amxbuffer@@YAPADH@Z			; get_amxbuffer
PUBLIC	?utf8isspace@@YA_NPBD@Z				; utf8isspace
PUBLIC	?utf8getspaces@@YAIPBD@Z			; utf8getspaces
PUBLIC	?parse_arg@@YAPADPAPADAAH@Z			; parse_arg
PUBLIC	?fastcellcmp@@YA_NPAH0H@Z			; fastcellcmp
PUBLIC	?fo_numargs@@YAHPAUtagAMX@@@Z			; fo_numargs
PUBLIC	?fo_getargnum@@YAHPAUtagAMX@@H@Z		; fo_getargnum
PUBLIC	?fo_getargfloat@@YAMPAUtagAMX@@H@Z		; fo_getargfloat
PUBLIC	?fo_getargstr@@YAPADPAUtagAMX@@HH@Z		; fo_getargstr
PUBLIC	?format_arguments@@YAPADPAUtagAMX@@HAAH@Z	; format_arguments
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_isalpha:PROC
EXTRN	_isupper:PROC
EXTRN	_islower:PROC
EXTRN	_isdigit:PROC
EXTRN	_isspace:PROC
EXTRN	_isalnum:PROC
EXTRN	_toupper:PROC
EXTRN	_tolower:PROC
EXTRN	_memmove:PROC
EXTRN	_strstr:PROC
EXTRN	_strncmp:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_atoi:PROC
EXTRN	_strtod:PROC
EXTRN	_strtol:PROC
EXTRN	?FormatAmxString@CLangMngr@@QAEPADPAUtagAMX@@PAHHAAH@Z:PROC ; CLangMngr::FormatAmxString
EXTRN	?UTIL_GetUTF8CharBytes@@YAIPBD@Z:PROC		; UTIL_GetUTF8CharBytes
EXTRN	?UTIL_ReplaceAll@@YAIPADIPBDI1I_N@Z:PROC	; UTIL_ReplaceAll
EXTRN	?UTIL_ReplaceEx@@YAPADPADIPBDI1I_N@Z:PROC	; UTIL_ReplaceEx
EXTRN	_LogError:PROC
EXTRN	_utf8seek:PROC
EXTRN	_utf8toupper:PROC
EXTRN	_utf8tolower:PROC
EXTRN	_utf8totitle:PROC
EXTRN	_utf8casefold:PROC
EXTRN	_utf8iscategory:PROC
EXTRN	??$atcprintf@HH@@YAIPAHIPBHPAUtagAMX@@00@Z:PROC	; atcprintf<int,int>
EXTRN	??$UTIL_CheckValidChar@H@@YAHPAH@Z:PROC		; UTIL_CheckValidChar<int>
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memcpy:PROC
EXTRN	?g_langMngr@@3VCLangMngr@@A:BYTE		; g_langMngr
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?buffer@?1??get_amxbuffer@@YAPADH@Z@4PAY0EAAA@DA
_BSS	SEGMENT
?buffer@?1??get_amxbuffer@@YAPADH@Z@4PAY0EAAA@DA DB 010000H DUP (?) ; `get_amxbuffer'::`2'::buffer
_BSS	ENDS
;	COMDAT ?arg@?1??parse_arg@@YAPADPAPADAAH@Z@4PADA
_BSS	SEGMENT
?arg@?1??parse_arg@@YAPADPAPADAAH@Z@4PADA DB 0c00H DUP (?) ; `parse_arg'::`2'::arg
_BSS	ENDS
;	COMDAT ?buffer@?1??fo_getargstr@@YAPADPAUtagAMX@@HH@Z@4PAY0MAA@DA
_BSS	SEGMENT
?buffer@?1??fo_getargstr@@YAPADPAUtagAMX@@HH@Z@4PAY0MAA@DA DB 01800H DUP (?) ; `fo_getargstr'::`2'::buffer
_BSS	ENDS
;	COMDAT ?buffer@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PAY0MAA@DA
_BSS	SEGMENT
?buffer@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PAY0MAA@DA DB 01800H DUP (?) ; `format_arguments'::`2'::buffer
_BSS	ENDS
;	COMDAT ?format@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PADA
_BSS	SEGMENT
?format@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PADA DB 010H DUP (?) ; `format_arguments'::`2'::format
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
; File e:\nightfire_sdk\amx\public\amtl\am-algorithm.h
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
; File e:\nightfire_sdk\amx\public\amtl\am-algorithm.h
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
; File e:\nightfire_sdk\amx\public\amtl\am-algorithm.h
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
; File e:\nightfire_sdk\amx\public\amtl\am-algorithm.h
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?is_string_category@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_inputLength$ = -4					; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?is_string_category@@YAHPAUtagAMX@@PAH@Z PROC		; is_string_category, COMDAT

; 1640 : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	56		 push	 esi

; 1644 : 	auto input = get_amxstring(amx, params[arg_input], 0, inputLength);

  00004	8b 74 24 14	 mov	 esi, DWORD PTR _amx$[esp+12]
  00008	8d 44 24 0c	 lea	 eax, DWORD PTR _inputLength$[esp+16]
  0000c	57		 push	 edi
  0000d	50		 push	 eax
  0000e	8b 44 24 20	 mov	 eax, DWORD PTR _params$[esp+20]
  00012	6a 00		 push	 0
  00014	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _inputLength$[esp+28], 0
  0001c	ff 70 04	 push	 DWORD PTR [eax+4]
  0001f	56		 push	 esi
  00020	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
; File e:\nightfire_sdk\amx\public\amtl\am-algorithm.h

; 40   :     return t1 < t2 ? t1 : t2;

  00025	8b 6c 24 20	 mov	 ebp, DWORD PTR _inputLength$[esp+36]
; File e:\nightfire_sdk\amx\amxmodx\string.cpp

; 1644 : 	auto input = get_amxstring(amx, params[arg_input], 0, inputLength);

  00029	8b d8		 mov	 ebx, eax
; File e:\nightfire_sdk\amx\public\amtl\am-algorithm.h

; 40   :     return t1 < t2 ? t1 : t2;

  0002b	8b 44 24 2c	 mov	 eax, DWORD PTR _params$[esp+32]
  0002f	8b fd		 mov	 edi, ebp
; File e:\nightfire_sdk\amx\amxmodx\string.cpp

; 1647 : 	auto outputSize = get_amxaddr(amx, params[arg_outputsize]);

  00031	ff 70 10	 push	 DWORD PTR [eax+16]
; File e:\nightfire_sdk\amx\public\amtl\am-algorithm.h

; 40   :     return t1 < t2 ? t1 : t2;

  00034	39 68 08	 cmp	 DWORD PTR [eax+8], ebp
; File e:\nightfire_sdk\amx\amxmodx\string.cpp

; 1647 : 	auto outputSize = get_amxaddr(amx, params[arg_outputsize]);

  00037	56		 push	 esi
; File e:\nightfire_sdk\amx\public\amtl\am-algorithm.h

; 40   :     return t1 < t2 ? t1 : t2;

  00038	0f 4c 78 08	 cmovl	 edi, DWORD PTR [eax+8]
; File e:\nightfire_sdk\amx\amxmodx\string.cpp

; 1647 : 	auto outputSize = get_amxaddr(amx, params[arg_outputsize]);

  0003c	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr
  00041	83 c4 18	 add	 esp, 24			; 00000018H
  00044	8b f0		 mov	 esi, eax

; 1648 : 
; 1649 : 	// User wants to check only one character whatever its size.
; 1650 : 	if (inputMaxLength <= 1)

  00046	83 ff 01	 cmp	 edi, 1
  00049	7f 25		 jg	 SHORT $LN3@is_string_

; 1651 : 	{
; 1652 : 		// Gets the character length.
; 1653 : 		inputMaxLength = utf8seek(input, inputLength, input, 1, SEEK_CUR) - input;

  0004b	6a 01		 push	 1
  0004d	6a 01		 push	 1
  0004f	53		 push	 ebx
  00050	55		 push	 ebp
  00051	53		 push	 ebx
  00052	e8 00 00 00 00	 call	 _utf8seek
  00057	8b f8		 mov	 edi, eax
  00059	83 c4 14	 add	 esp, 20			; 00000014H
  0005c	2b fb		 sub	 edi, ebx

; 1654 : 
; 1655 : 		// Truncated character.
; 1656 : 		if (inputMaxLength > inputLength)

  0005e	3b fd		 cmp	 edi, ebp
  00060	7e 0e		 jle	 SHORT $LN3@is_string_

; 1657 : 		{
; 1658 : 			*outputSize = 0;

  00062	5f		 pop	 edi
  00063	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1659 : 			return FALSE;

  00069	33 c0		 xor	 eax, eax
  0006b	5e		 pop	 esi
  0006c	5d		 pop	 ebp
  0006d	5b		 pop	 ebx

; 1668 : }

  0006e	59		 pop	 ecx
  0006f	c3		 ret	 0
$LN3@is_string_:

; 1660 : 		}
; 1661 : 	}
; 1662 : 
; 1663 : 	// Checks input with the given flags.
; 1664 : 	*outputSize = utf8iscategory(input, inputMaxLength, params[arg_flags]);

  00070	8b 44 24 1c	 mov	 eax, DWORD PTR _params$[esp+16]
  00074	ff 70 0c	 push	 DWORD PTR [eax+12]
  00077	57		 push	 edi
  00078	53		 push	 ebx
  00079	e8 00 00 00 00	 call	 _utf8iscategory
  0007e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00081	89 06		 mov	 DWORD PTR [esi], eax

; 1665 : 
; 1666 : 	// If function consumed input, then it's a success.
; 1667 : 	return static_cast<cell>(*outputSize == inputMaxLength);

  00083	33 c9		 xor	 ecx, ecx
  00085	3b c7		 cmp	 eax, edi
  00087	0f 94 c1	 sete	 cl
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi
  0008c	5d		 pop	 ebp
  0008d	8b c1		 mov	 eax, ecx
  0008f	5b		 pop	 ebx

; 1668 : }

  00090	59		 pop	 ecx
  00091	c3		 ret	 0
?is_string_category@@YAHPAUtagAMX@@PAH@Z ENDP		; is_string_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?mb_strtotitle@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_sourceLength$ = -4					; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?mb_strtotitle@@YAHPAUtagAMX@@PAH@Z PROC		; mb_strtotitle, COMDAT

; 1617 : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp

; 1618 : 	enum args { arg_count, arg_string, arg_maxlength };
; 1619 : 
; 1620 : 	auto sourceLength = 0;
; 1621 : 	auto source = get_amxstring(amx, params[arg_string], 0, sourceLength);

  00003	8b 6c 24 14	 mov	 ebp, DWORD PTR _params$[esp+8]
  00007	8d 44 24 08	 lea	 eax, DWORD PTR _sourceLength$[esp+12]
  0000b	57		 push	 edi
  0000c	50		 push	 eax
  0000d	6a 00		 push	 0
  0000f	ff 75 04	 push	 DWORD PTR [ebp+4]
  00012	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _sourceLength$[esp+28], 0
  0001a	ff 74 24 20	 push	 DWORD PTR _amx$[esp+24]
  0001e	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring

; 1622 : 
; 1623 : 	auto outputMaxLength = params[arg_maxlength];

  00023	8b 6d 08	 mov	 ebp, DWORD PTR [ebp+8]
  00026	8b d8		 mov	 ebx, eax

; 1624 : 
; 1625 : 	if (outputMaxLength <= 0)

  00028	85 ed		 test	 ebp, ebp

; 1626 : 	{
; 1627 : 		outputMaxLength = sourceLength;
; 1628 : 	}
; 1629 : 
; 1630 : 	auto output = get_amxbuffer(1);

  0002a	6a 01		 push	 1
  0002c	0f 4e 6c 24 20	 cmovle	 ebp, DWORD PTR _sourceLength$[esp+36]
  00031	e8 00 00 00 00	 call	 ?get_amxbuffer@@YAPADH@Z ; get_amxbuffer

; 1631 : 	auto outputLength = utf8totitle(source, sourceLength, output, MAX_BUFFER_LENGTH - 1, UTF8_LOCALE_DEFAULT, nullptr, TRUE);

  00036	6a 01		 push	 1
  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	68 ff 3f 00 00	 push	 16383			; 00003fffH
  00041	8b f8		 mov	 edi, eax
  00043	57		 push	 edi
  00044	ff 74 24 34	 push	 DWORD PTR _sourceLength$[esp+56]
  00048	53		 push	 ebx
  00049	e8 00 00 00 00	 call	 _utf8totitle

; 1632 : 
; 1633 : 	output[outputLength] = '\0';
; 1634 : 
; 1635 : 	return set_amxstring_utf8(amx, params[arg_string], output, outputLength, outputMaxLength);

  0004e	55		 push	 ebp
  0004f	50		 push	 eax
  00050	57		 push	 edi
  00051	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  00055	8b 44 24 54	 mov	 eax, DWORD PTR _params$[esp+72]
  00059	ff 70 04	 push	 DWORD PTR [eax+4]
  0005c	ff 74 24 54	 push	 DWORD PTR _amx$[esp+76]
  00060	e8 00 00 00 00	 call	 ??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z ; set_amxstring_utf8<char>
  00065	83 c4 44	 add	 esp, 68			; 00000044H
  00068	5f		 pop	 edi
  00069	5d		 pop	 ebp
  0006a	5b		 pop	 ebx

; 1636 : }

  0006b	59		 pop	 ecx
  0006c	c3		 ret	 0
?mb_strtotitle@@YAHPAUtagAMX@@PAH@Z ENDP		; mb_strtotitle
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?fmt@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_length$ = -4						; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?fmt@@YAHPAUtagAMX@@PAH@Z PROC				; fmt, COMDAT

; 1604 : {

  00000	51		 push	 ecx
  00001	56		 push	 esi

; 1605 : 	int length;
; 1606 : 	const char *string = format_amxstring(amx, params, 1, length);

  00002	8b 74 24 10	 mov	 esi, DWORD PTR _params$[esp+4]
  00006	8d 44 24 04	 lea	 eax, DWORD PTR _length$[esp+8]
  0000a	50		 push	 eax
  0000b	6a 01		 push	 1
  0000d	56		 push	 esi
  0000e	ff 74 24 18	 push	 DWORD PTR _amx$[esp+16]
  00012	e8 00 00 00 00	 call	 ?format_amxstring@@YAPADPAUtagAMX@@PAHHAAH@Z ; format_amxstring

; 1607 : 
; 1608 : 	size_t num_params = *params / sizeof(cell);
; 1609 : 
; 1610 : 	set_amxstring_utf8_char(amx, params[num_params + 1], string, length, MAX_FMT_LENGTH - 1);

  00017	68 ff 00 00 00	 push	 255			; 000000ffH
  0001c	ff 74 24 18	 push	 DWORD PTR _length$[esp+28]
  00020	50		 push	 eax
  00021	8b 06		 mov	 eax, DWORD PTR [esi]
  00023	c1 e8 02	 shr	 eax, 2
  00026	ff 74 86 04	 push	 DWORD PTR [esi+eax*4+4]
  0002a	ff 74 24 2c	 push	 DWORD PTR _amx$[esp+36]
  0002e	e8 00 00 00 00	 call	 ?set_amxstring_utf8_char@@YAHPAUtagAMX@@HPBDII@Z ; set_amxstring_utf8_char
  00033	83 c4 24	 add	 esp, 36			; 00000024H

; 1611 : 
; 1612 : 	return 1;

  00036	b8 01 00 00 00	 mov	 eax, 1
  0003b	5e		 pop	 esi

; 1613 : };

  0003c	59		 pop	 ecx
  0003d	c3		 ret	 0
?fmt@@YAHPAUtagAMX@@PAH@Z ENDP				; fmt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?vformat@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_vargPos$ = -8						; size = 4
_maxlen$1$ = -4						; size = 4
_copy$1$ = 8						; size = 1
_amx$ = 8						; size = 4
_dest$1$ = 12						; size = 4
_params$ = 12						; size = 4
?vformat@@YAHPAUtagAMX@@PAH@Z PROC			; vformat, COMDAT

; 1542 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	55		 push	 ebp

; 1543 : 	int vargPos = static_cast<int>(params[4]);
; 1544 : 
; 1545 : 	/** get the parent parameter array */
; 1546 : 	AMX_HEADER *hdr = (AMX_HEADER *)amx->base;
; 1547 : 	cell *local_params = (cell *)(
; 1548 : 		(char *)amx->base + (cell)hdr->dat +
; 1549 : 		(cell)amx->frm + (2 * sizeof(cell))

  00004	8b 6c 24 10	 mov	 ebp, DWORD PTR _amx$[esp+8]
  00008	56		 push	 esi
  00009	8b 74 24 18	 mov	 esi, DWORD PTR _params$[esp+12]
  0000d	57		 push	 edi
  0000e	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  00011	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00014	89 44 24 0c	 mov	 DWORD PTR _vargPos$[esp+20], eax
  00018	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  0001b	8d 7a 08	 lea	 edi, DWORD PTR [edx+8]
  0001e	03 4d 14	 add	 ecx, DWORD PTR [ebp+20]
  00021	03 f9		 add	 edi, ecx

; 1550 : 		);
; 1551 : 
; 1552 : 	cell max = local_params[0] / sizeof(cell);

  00023	8b 17		 mov	 edx, DWORD PTR [edi]
  00025	c1 ea 02	 shr	 edx, 2

; 1553 : 	if (vargPos > (int)max + 1)

  00028	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
  0002b	3b c1		 cmp	 eax, ecx
  0002d	7e 1a		 jle	 SHORT $LN5@vformat

; 1554 : 	{
; 1555 : 		LogError(amx, AMX_ERR_NATIVE, "Invalid vararg parameter passed: %d", vargPos);

  0002f	50		 push	 eax
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@BPGCCENF@Invalid?5vararg?5parameter?5passed?3@
  00035	6a 0a		 push	 10			; 0000000aH
  00037	55		 push	 ebp
  00038	e8 00 00 00 00	 call	 _LogError
  0003d	83 c4 10	 add	 esp, 16			; 00000010H

; 1556 : 		return 0;

  00040	33 c0		 xor	 eax, eax
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5d		 pop	 ebp

; 1597 : }

  00045	83 c4 08	 add	 esp, 8
  00048	c3		 ret	 0
$LN5@vformat:

; 1557 : 	}
; 1558 : 	
; 1559 : 	/**
; 1560 : 	 * check for bounds clipping
; 1561 : 	 */
; 1562 : 	cell addr_start = params[1];
; 1563 : 	cell addr_end = addr_start + params[2];

  00049	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0004c	89 4c 24 10	 mov	 DWORD PTR _maxlen$1$[esp+20], ecx

; 1564 : 	bool copy = false;

  00050	c6 44 24 18 00	 mov	 BYTE PTR _copy$1$[esp+16], 0
  00055	53		 push	 ebx
  00056	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00059	8d 34 19	 lea	 esi, DWORD PTR [ecx+ebx]

; 1565 : 	for (int i = vargPos; i <= max; i++)

  0005c	3b c2		 cmp	 eax, edx
  0005e	7f 17		 jg	 SHORT $LN15@vformat
$LL4@vformat:

; 1566 : 	{
; 1567 : 		//does this clip the bounds?
; 1568 : 		if ( (local_params[i] >= addr_start)
; 1569 : 			&& (local_params[i] <= addr_end) )

  00060	8b 0c 87	 mov	 ecx, DWORD PTR [edi+eax*4]
  00063	3b cb		 cmp	 ecx, ebx
  00065	7c 04		 jl	 SHORT $LN2@vformat
  00067	3b ce		 cmp	 ecx, esi
  00069	7e 07		 jle	 SHORT $LN11@vformat
$LN2@vformat:

; 1565 : 	for (int i = vargPos; i <= max; i++)

  0006b	40		 inc	 eax
  0006c	3b c2		 cmp	 eax, edx
  0006e	7e f0		 jle	 SHORT $LL4@vformat
  00070	eb 05		 jmp	 SHORT $LN15@vformat
$LN11@vformat:

; 1570 : 		{
; 1571 : 			copy = true;

  00072	c6 44 24 1c 01	 mov	 BYTE PTR _copy$1$[esp+20], 1
$LN15@vformat:

; 1572 : 			break;
; 1573 : 		}
; 1574 : 	}
; 1575 : 
; 1576 : 	/* get destination info */
; 1577 : 	cell *fmt = get_amxaddr(amx, params[3]);

  00077	8b 44 24 20	 mov	 eax, DWORD PTR _params$[esp+20]
  0007b	ff 70 0c	 push	 DWORD PTR [eax+12]
  0007e	55		 push	 ebp
  0007f	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 1578 : 	cell *realdest = get_amxaddr(amx, params[1]);

  00084	53		 push	 ebx
  00085	55		 push	 ebp
  00086	8b f0		 mov	 esi, eax
  00088	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 1579 : 	size_t maxlen = static_cast<size_t>(params[2]);
; 1580 : 	cell *dest = realdest;
; 1581 : 
; 1582 : 	/* if this is necessary... */
; 1583 : 	static cell cpbuf[4096];
; 1584 : 	if (copy)

  0008d	80 7c 24 2c 00	 cmp	 BYTE PTR _copy$1$[esp+36], 0
  00092	bb 00 00 00 00	 mov	 ebx, OFFSET ?cpbuf@?1??vformat@@YAHPAUtagAMX@@PAH@Z@4PAHA
  00097	89 44 24 30	 mov	 DWORD PTR _dest$1$[esp+36], eax
  0009b	0f 44 d8	 cmove	 ebx, eax

; 1585 : 		dest = cpbuf;
; 1586 : 
; 1587 : 	/* perform format */
; 1588 : 	size_t total = atcprintf(dest, maxlen, fmt, amx, local_params, &vargPos);

  0009e	8d 44 24 20	 lea	 eax, DWORD PTR _vargPos$[esp+40]
  000a2	50		 push	 eax
  000a3	57		 push	 edi
  000a4	55		 push	 ebp
  000a5	56		 push	 esi
  000a6	ff 74 24 34	 push	 DWORD PTR _maxlen$1$[esp+56]
  000aa	53		 push	 ebx
  000ab	e8 00 00 00 00	 call	 ??$atcprintf@HH@@YAIPAHIPBHPAUtagAMX@@00@Z ; atcprintf<int,int>
  000b0	83 c4 28	 add	 esp, 40			; 00000028H
  000b3	8b f0		 mov	 esi, eax

; 1589 : 
; 1590 : 	/* copy back */
; 1591 : 	if (copy)

  000b5	80 7c 24 1c 00	 cmp	 BYTE PTR _copy$1$[esp+20], 0
  000ba	74 15		 je	 SHORT $LN8@vformat

; 1592 : 	{
; 1593 : 		memcpy(realdest, dest, (total+1) * sizeof(cell));

  000bc	8d 0c b5 04 00
	00 00		 lea	 ecx, DWORD PTR [esi*4+4]
  000c3	51		 push	 ecx
  000c4	53		 push	 ebx
  000c5	ff 74 24 28	 push	 DWORD PTR _dest$1$[esp+28]
  000c9	e8 00 00 00 00	 call	 _memcpy
  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@vformat:

; 1594 : 	}
; 1595 : 
; 1596 : 	return total;

  000d1	5b		 pop	 ebx
  000d2	5f		 pop	 edi
  000d3	8b c6		 mov	 eax, esi
  000d5	5e		 pop	 esi
  000d6	5d		 pop	 ebp

; 1597 : }

  000d7	83 c4 08	 add	 esp, 8
  000da	c3		 ret	 0
?vformat@@YAHPAUtagAMX@@PAH@Z ENDP			; vformat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?n_strfind@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_sourceLength$1$ = -8					; size = 4
_sourceLength$ = -8					; size = 4
_searchLength$ = -4					; size = 4
_amx$ = 8						; size = 4
_search$1$ = 12						; size = 4
_params$ = 12						; size = 4
?n_strfind@@YAHPAUtagAMX@@PAH@Z PROC			; n_strfind, COMDAT

; 1500 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	53		 push	 ebx

; 1501 : 	enum args { arg_count, arg_source, arg_search, arg_ignorecase, arg_startpos };
; 1502 : 
; 1503 : 	auto sourceLength = 0;
; 1504 : 	auto searchLength = 0;
; 1505 : 
; 1506 : 	auto source = get_amxstring(amx, params[arg_source], 0, sourceLength);

  00004	8b 5c 24 14	 mov	 ebx, DWORD PTR _params$[esp+8]
  00008	8d 44 24 04	 lea	 eax, DWORD PTR _sourceLength$[esp+12]
  0000c	55		 push	 ebp
  0000d	56		 push	 esi
  0000e	8b 74 24 18	 mov	 esi, DWORD PTR _amx$[esp+16]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	ff 73 04	 push	 DWORD PTR [ebx+4]
  00018	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _sourceLength$[esp+32], 0
  00020	56		 push	 esi
  00021	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _searchLength$[esp+36], 0
  00029	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  0002e	8b e8		 mov	 ebp, eax

; 1507 : 	auto search = get_amxstring(amx, params[arg_search], 1, searchLength);

  00030	8d 44 24 20	 lea	 eax, DWORD PTR _searchLength$[esp+36]
  00034	50		 push	 eax
  00035	6a 01		 push	 1
  00037	ff 73 08	 push	 DWORD PTR [ebx+8]
  0003a	56		 push	 esi
  0003b	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  00040	83 c4 20	 add	 esp, 32			; 00000020H
  00043	8b d0		 mov	 edx, eax

; 1508 : 	
; 1509 : 	if (params[arg_ignorecase] != 0)

  00045	83 7b 0c 00	 cmp	 DWORD PTR [ebx+12], 0
  00049	89 54 24 1c	 mov	 DWORD PTR _search$1$[esp+16], edx
  0004d	74 5c		 je	 SHORT $LN9@n_strfind

; 1510 : 	{
; 1511 : 		auto sourceFolded = get_amxbuffer(2);

  0004f	57		 push	 edi
  00050	6a 02		 push	 2
  00052	e8 00 00 00 00	 call	 ?get_amxbuffer@@YAPADH@Z ; get_amxbuffer

; 1512 : 		auto searchFolded = get_amxbuffer(3);

  00057	6a 03		 push	 3
  00059	8b f8		 mov	 edi, eax
  0005b	e8 00 00 00 00	 call	 ?get_amxbuffer@@YAPADH@Z ; get_amxbuffer

; 1513 : 
; 1514 : 		sourceLength = utf8casefold(source, sourceLength, sourceFolded, MAX_BUFFER_LENGTH - 1, UTF8_LOCALE_DEFAULT, nullptr, TRUE);

  00060	6a 01		 push	 1
  00062	6a 00		 push	 0
  00064	6a 00		 push	 0
  00066	68 ff 3f 00 00	 push	 16383			; 00003fffH
  0006b	57		 push	 edi
  0006c	ff 74 24 2c	 push	 DWORD PTR _sourceLength$[esp+52]
  00070	8b f0		 mov	 esi, eax
  00072	55		 push	 ebp
  00073	e8 00 00 00 00	 call	 _utf8casefold

; 1515 : 		searchLength = utf8casefold(search, searchLength, searchFolded, MAX_BUFFER_LENGTH - 1, UTF8_LOCALE_DEFAULT, nullptr, TRUE);

  00078	6a 01		 push	 1
  0007a	6a 00		 push	 0
  0007c	6a 00		 push	 0
  0007e	68 ff 3f 00 00	 push	 16383			; 00003fffH
  00083	56		 push	 esi
  00084	ff 74 24 4c	 push	 DWORD PTR _searchLength$[esp+80]
  00088	89 44 24 4c	 mov	 DWORD PTR _sourceLength$1$[esp+84], eax
  0008c	ff 74 24 5c	 push	 DWORD PTR _search$1$[esp+80]
  00090	e8 00 00 00 00	 call	 _utf8casefold

; 1516 : 
; 1517 : 		sourceFolded[sourceLength] = '\0';

  00095	8b 4c 24 50	 mov	 ecx, DWORD PTR _sourceLength$1$[esp+88]
  00099	83 c4 40	 add	 esp, 64			; 00000040H

; 1518 : 		searchFolded[searchLength] = '\0';
; 1519 : 
; 1520 : 		source = sourceFolded;

  0009c	8b ef		 mov	 ebp, edi

; 1521 : 		search = searchFolded;

  0009e	8b d6		 mov	 edx, esi
  000a0	c6 04 0f 00	 mov	 BYTE PTR [edi+ecx], 0
  000a4	c6 04 06 00	 mov	 BYTE PTR [esi+eax], 0
  000a8	5f		 pop	 edi
  000a9	eb 04		 jmp	 SHORT $LN2@n_strfind
$LN9@n_strfind:
  000ab	8b 4c 24 0c	 mov	 ecx, DWORD PTR _sourceLength$[esp+20]
$LN2@n_strfind:

; 1522 : 		}
; 1523 : 
; 1524 : 	auto position = params[arg_startpos];

  000af	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]

; 1525 : 	
; 1526 : 	if (position < 0 || position > sourceLength)

  000b2	85 c0		 test	 eax, eax
  000b4	78 1d		 js	 SHORT $LN4@n_strfind
  000b6	3b c1		 cmp	 eax, ecx
  000b8	7f 19		 jg	 SHORT $LN4@n_strfind
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h

; 537  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  000ba	52		 push	 edx
; File e:\nightfire_sdk\amx\amxmodx\string.cpp

; 1531 : 	auto find = strstr(source + position, search);

  000bb	03 c5		 add	 eax, ebp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h

; 537  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 _strstr
  000c3	83 c4 08	 add	 esp, 8
; File e:\nightfire_sdk\amx\amxmodx\string.cpp

; 1533 : 	if (!find)

  000c6	85 c0		 test	 eax, eax
  000c8	74 09		 je	 SHORT $LN4@n_strfind

; 1534 : 	{
; 1535 : 		return -1;
; 1536 : 	}
; 1537 : 
; 1538 : 	return (find - source);

  000ca	5e		 pop	 esi
  000cb	2b c5		 sub	 eax, ebp
  000cd	5d		 pop	 ebp
  000ce	5b		 pop	 ebx

; 1539 : }

  000cf	83 c4 08	 add	 esp, 8
  000d2	c3		 ret	 0
$LN4@n_strfind:
  000d3	5e		 pop	 esi
  000d4	5d		 pop	 ebp

; 1527 : 		{
; 1528 : 		return -1;

  000d5	83 c8 ff	 or	 eax, -1
  000d8	5b		 pop	 ebx

; 1539 : }

  000d9	83 c4 08	 add	 esp, 8
  000dc	c3		 ret	 0
?n_strfind@@YAHPAUtagAMX@@PAH@Z ENDP			; n_strfind
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?n_strncmp@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_string1Length$ = -12					; size = 4
_string2Length$ = -8					; size = 4
_string2$1$ = -4					; size = 4
_amx$ = 8						; size = 4
_string1$1$ = 12					; size = 4
_params$ = 12						; size = 4
?n_strncmp@@YAHPAUtagAMX@@PAH@Z PROC			; n_strncmp, COMDAT

; 1471 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp

; 1472 : 	enum args { arg_count, arg_string1, arg_string2, arg_numbytes, arg_ignorecase };
; 1473 : 
; 1474 : 	auto string1Length = 0;
; 1475 : 	auto string2Length = 0;
; 1476 : 
; 1477 : 	auto string1 = get_amxstring(amx, params[arg_string1], 0, string1Length);

  00005	8b 6c 24 1c	 mov	 ebp, DWORD PTR _params$[esp+16]
  00009	8d 44 24 08	 lea	 eax, DWORD PTR _string1Length$[esp+20]
  0000d	56		 push	 esi
  0000e	8b 74 24 1c	 mov	 esi, DWORD PTR _amx$[esp+20]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	ff 75 04	 push	 DWORD PTR [ebp+4]
  00018	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _string1Length$[esp+36], 0
  00020	56		 push	 esi
  00021	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _string2Length$[esp+40], 0
  00029	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  0002e	8b d8		 mov	 ebx, eax

; 1478 : 	auto string2 = get_amxstring(amx, params[arg_string2], 1, string2Length);

  00030	8d 44 24 20	 lea	 eax, DWORD PTR _string2Length$[esp+40]
  00034	50		 push	 eax
  00035	6a 01		 push	 1
  00037	ff 75 08	 push	 DWORD PTR [ebp+8]
  0003a	89 5c 24 3c	 mov	 DWORD PTR _string1$1$[esp+48], ebx
  0003e	56		 push	 esi
  0003f	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  00044	83 c4 20	 add	 esp, 32			; 00000020H
  00047	89 44 24 14	 mov	 DWORD PTR _string2$1$[esp+24], eax

; 1479 : 
; 1480 : 	if (params[arg_ignorecase] != 0)

  0004b	83 7d 10 00	 cmp	 DWORD PTR [ebp+16], 0
  0004f	74 55		 je	 SHORT $LN2@n_strncmp

; 1481 : 	{
; 1482 : 		auto string1Folded = get_amxbuffer(2);

  00051	57		 push	 edi
  00052	6a 02		 push	 2
  00054	e8 00 00 00 00	 call	 ?get_amxbuffer@@YAPADH@Z ; get_amxbuffer

; 1483 : 		auto string2Folded = get_amxbuffer(3);

  00059	6a 03		 push	 3
  0005b	8b d8		 mov	 ebx, eax
  0005d	e8 00 00 00 00	 call	 ?get_amxbuffer@@YAPADH@Z ; get_amxbuffer

; 1484 : 
; 1485 : 		string1Length = utf8casefold(string1, string1Length, string1Folded, MAX_BUFFER_LENGTH - 1, UTF8_LOCALE_DEFAULT, nullptr, TRUE);

  00062	6a 01		 push	 1
  00064	6a 00		 push	 0
  00066	6a 00		 push	 0
  00068	68 ff 3f 00 00	 push	 16383			; 00003fffH
  0006d	53		 push	 ebx
  0006e	ff 74 24 2c	 push	 DWORD PTR _string1Length$[esp+56]
  00072	8b f8		 mov	 edi, eax
  00074	ff 74 24 44	 push	 DWORD PTR _string1$1$[esp+56]
  00078	e8 00 00 00 00	 call	 _utf8casefold

; 1486 : 		string2Length = utf8casefold(string2, string2Length, string2Folded, MAX_BUFFER_LENGTH - 1, UTF8_LOCALE_DEFAULT, nullptr, TRUE);

  0007d	6a 01		 push	 1
  0007f	6a 00		 push	 0
  00081	6a 00		 push	 0
  00083	68 ff 3f 00 00	 push	 16383			; 00003fffH
  00088	57		 push	 edi
  00089	ff 74 24 4c	 push	 DWORD PTR _string2Length$[esp+84]
  0008d	8b f0		 mov	 esi, eax
  0008f	ff 74 24 54	 push	 DWORD PTR _string2$1$[esp+88]
  00093	e8 00 00 00 00	 call	 _utf8casefold
  00098	83 c4 40	 add	 esp, 64			; 00000040H

; 1487 : 
; 1488 : 		string1Folded[string1Length] = '\0';

  0009b	c6 04 33 00	 mov	 BYTE PTR [ebx+esi], 0

; 1489 : 		string2Folded[string2Length] = '\0';

  0009f	c6 04 07 00	 mov	 BYTE PTR [edi+eax], 0

; 1490 : 
; 1491 : 		string1 = string1Folded;
; 1492 : 		string2 = string2Folded;

  000a3	8b c7		 mov	 eax, edi
  000a5	5f		 pop	 edi
$LN2@n_strncmp:

; 1493 : 	}
; 1494 : 
; 1495 : 	return strncmp(string1, string2, params[arg_numbytes]);

  000a6	ff 75 0c	 push	 DWORD PTR [ebp+12]
  000a9	50		 push	 eax
  000aa	53		 push	 ebx
  000ab	e8 00 00 00 00	 call	 _strncmp
  000b0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b3	5e		 pop	 esi
  000b4	5d		 pop	 ebp
  000b5	5b		 pop	 ebx

; 1496 : }

  000b6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b9	c3		 ret	 0
?n_strncmp@@YAHPAUtagAMX@@PAH@Z ENDP			; n_strncmp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?n_strcmp@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_string1Length$ = -8					; size = 4
_string2Length$ = -4					; size = 4
_amx$ = 8						; size = 4
_string1$1$ = 12					; size = 4
_params$ = 12						; size = 4
?n_strcmp@@YAHPAUtagAMX@@PAH@Z PROC			; n_strcmp, COMDAT

; 1442 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	55		 push	 ebp
  00004	56		 push	 esi

; 1443 : 	enum args { arg_count, arg_string1, arg_string2, arg_ignorecase };
; 1444 : 
; 1445 : 	auto string1Length = 0;
; 1446 : 	auto string2Length = 0;
; 1447 : 
; 1448 : 	auto string1 = get_amxstring(amx, params[arg_string1], 0, string1Length);

  00005	8b 74 24 14	 mov	 esi, DWORD PTR _amx$[esp+12]
  00009	8d 44 24 08	 lea	 eax, DWORD PTR _string1Length$[esp+16]
  0000d	57		 push	 edi
  0000e	8b 7c 24 1c	 mov	 edi, DWORD PTR _params$[esp+16]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _string1Length$[esp+28], 0
  0001d	ff 77 04	 push	 DWORD PTR [edi+4]
  00020	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _string2Length$[esp+32], 0
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  0002e	8b e8		 mov	 ebp, eax

; 1449 : 	auto string2 = get_amxstring(amx, params[arg_string2], 1, string2Length);

  00030	8d 44 24 20	 lea	 eax, DWORD PTR _string2Length$[esp+36]
  00034	50		 push	 eax
  00035	6a 01		 push	 1
  00037	ff 77 08	 push	 DWORD PTR [edi+8]
  0003a	89 6c 24 38	 mov	 DWORD PTR _string1$1$[esp+44], ebp
  0003e	56		 push	 esi
  0003f	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  00044	83 c4 20	 add	 esp, 32			; 00000020H
  00047	8b f0		 mov	 esi, eax

; 1450 : 
; 1451 : 	if (params[arg_ignorecase] != 0)

  00049	83 7f 0c 00	 cmp	 DWORD PTR [edi+12], 0
  0004d	74 52		 je	 SHORT $LL2@n_strcmp

; 1452 : 	{
; 1453 : 		auto string1Folded = get_amxbuffer(2);

  0004f	53		 push	 ebx
  00050	6a 02		 push	 2
  00052	e8 00 00 00 00	 call	 ?get_amxbuffer@@YAPADH@Z ; get_amxbuffer

; 1454 : 		auto string2Folded = get_amxbuffer(3);

  00057	6a 03		 push	 3
  00059	8b e8		 mov	 ebp, eax
  0005b	e8 00 00 00 00	 call	 ?get_amxbuffer@@YAPADH@Z ; get_amxbuffer

; 1455 : 
; 1456 : 		string1Length = utf8casefold(string1, string1Length, string1Folded, MAX_BUFFER_LENGTH - 1, UTF8_LOCALE_DEFAULT, nullptr, TRUE);

  00060	6a 01		 push	 1
  00062	6a 00		 push	 0
  00064	6a 00		 push	 0
  00066	68 ff 3f 00 00	 push	 16383			; 00003fffH
  0006b	55		 push	 ebp
  0006c	ff 74 24 2c	 push	 DWORD PTR _string1Length$[esp+52]
  00070	8b d8		 mov	 ebx, eax
  00072	ff 74 24 40	 push	 DWORD PTR _string1$1$[esp+52]
  00076	e8 00 00 00 00	 call	 _utf8casefold

; 1457 : 		string2Length = utf8casefold(string2, string2Length, string2Folded, MAX_BUFFER_LENGTH - 1, UTF8_LOCALE_DEFAULT, nullptr, TRUE);

  0007b	6a 01		 push	 1
  0007d	6a 00		 push	 0
  0007f	6a 00		 push	 0
  00081	68 ff 3f 00 00	 push	 16383			; 00003fffH
  00086	53		 push	 ebx
  00087	ff 74 24 4c	 push	 DWORD PTR _string2Length$[esp+80]
  0008b	8b f8		 mov	 edi, eax
  0008d	56		 push	 esi
  0008e	e8 00 00 00 00	 call	 _utf8casefold
  00093	83 c4 40	 add	 esp, 64			; 00000040H

; 1458 : 
; 1459 : 		string1Folded[string1Length] = '\0';

  00096	c6 04 2f 00	 mov	 BYTE PTR [edi+ebp], 0

; 1460 : 		string2Folded[string2Length] = '\0';
; 1461 : 
; 1462 : 		string1 = string1Folded;
; 1463 : 		string2 = string2Folded;

  0009a	8b f3		 mov	 esi, ebx
  0009c	c6 04 03 00	 mov	 BYTE PTR [ebx+eax], 0
  000a0	5b		 pop	 ebx
$LL2@n_strcmp:

; 1464 : 	}
; 1465 : 
; 1466 : 	return strcmp(string1, string2);

  000a1	8a 45 00	 mov	 al, BYTE PTR [ebp]
  000a4	3a 06		 cmp	 al, BYTE PTR [esi]
  000a6	75 1f		 jne	 SHORT $LN5@n_strcmp
  000a8	84 c0		 test	 al, al
  000aa	74 12		 je	 SHORT $LN6@n_strcmp
  000ac	8a 45 01	 mov	 al, BYTE PTR [ebp+1]
  000af	3a 46 01	 cmp	 al, BYTE PTR [esi+1]
  000b2	75 13		 jne	 SHORT $LN5@n_strcmp
  000b4	83 c5 02	 add	 ebp, 2
  000b7	83 c6 02	 add	 esi, 2
  000ba	84 c0		 test	 al, al
  000bc	75 e3		 jne	 SHORT $LL2@n_strcmp
$LN6@n_strcmp:
  000be	5f		 pop	 edi
  000bf	5e		 pop	 esi
  000c0	33 c0		 xor	 eax, eax
  000c2	5d		 pop	 ebp

; 1467 : }

  000c3	83 c4 08	 add	 esp, 8
  000c6	c3		 ret	 0
$LN5@n_strcmp:
  000c7	5f		 pop	 edi

; 1464 : 	}
; 1465 : 
; 1466 : 	return strcmp(string1, string2);

  000c8	1b c0		 sbb	 eax, eax
  000ca	5e		 pop	 esi
  000cb	83 c8 01	 or	 eax, 1
  000ce	5d		 pop	 ebp

; 1467 : }

  000cf	83 c4 08	 add	 esp, 8
  000d2	c3		 ret	 0
?n_strcmp@@YAHPAUtagAMX@@PAH@Z ENDP			; n_strcmp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?n_strcat@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?n_strcat@@YAHPAUtagAMX@@PAH@Z PROC			; n_strcat, COMDAT

; 1414 : {

  00000	53		 push	 ebx

; 1415 : 	cell *cdest, *csrc;
; 1416 : 
; 1417 : 	cdest = get_amxaddr(amx, params[1]);

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _params$[esp]
  00005	56		 push	 esi
  00006	ff 73 04	 push	 DWORD PTR [ebx+4]
  00009	ff 74 24 10	 push	 DWORD PTR _amx$[esp+8]
  0000d	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 1418 : 	csrc = get_amxaddr(amx, params[2]);

  00012	ff 73 08	 push	 DWORD PTR [ebx+8]
  00015	8b f0		 mov	 esi, eax
  00017	ff 74 24 18	 push	 DWORD PTR _amx$[esp+16]
  0001b	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 1419 : 	int num = params[3];

  00020	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00023	83 c4 10	 add	 esp, 16			; 00000010H

; 1420 : 	
; 1421 : 	while (*cdest && num)

  00026	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00029	8b d0		 mov	 edx, eax
  0002b	74 10		 je	 SHORT $LN3@n_strcat
  0002d	0f 1f 00	 npad	 3
$LL2@n_strcat:
  00030	85 c9		 test	 ecx, ecx
  00032	74 0d		 je	 SHORT $LN16@n_strcat

; 1422 : 	{
; 1423 : 		cdest++;

  00034	83 c6 04	 add	 esi, 4

; 1424 : 		num--;

  00037	49		 dec	 ecx
  00038	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0003b	75 f3		 jne	 SHORT $LL2@n_strcat
$LN3@n_strcat:

; 1425 : 	}
; 1426 : 	
; 1427 : 	if (!num)

  0003d	85 c9		 test	 ecx, ecx
  0003f	75 05		 jne	 SHORT $LN9@n_strcat
$LN16@n_strcat:
  00041	5e		 pop	 esi

; 1428 : 		return 0;

  00042	33 c0		 xor	 eax, eax
  00044	5b		 pop	 ebx

; 1438 : }

  00045	c3		 ret	 0
$LN9@n_strcat:

; 1429 : 	
; 1430 : 	while (*csrc && num)

  00046	8b 02		 mov	 eax, DWORD PTR [edx]
  00048	85 c0		 test	 eax, eax
  0004a	74 16		 je	 SHORT $LN17@n_strcat
  0004c	2b d6		 sub	 edx, esi
  0004e	66 90		 npad	 2
$LL4@n_strcat:
  00050	85 c9		 test	 ecx, ecx
  00052	74 0e		 je	 SHORT $LN17@n_strcat

; 1431 : 	{
; 1432 : 		*cdest++ = *csrc++;

  00054	89 06		 mov	 DWORD PTR [esi], eax

; 1433 : 		num--;

  00056	49		 dec	 ecx
  00057	8b 44 32 04	 mov	 eax, DWORD PTR [edx+esi+4]
  0005b	83 c6 04	 add	 esi, 4
  0005e	85 c0		 test	 eax, eax
  00060	75 ee		 jne	 SHORT $LL4@n_strcat
$LN17@n_strcat:

; 1434 : 	}
; 1435 : 	*cdest = 0;

  00062	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1436 : 
; 1437 : 	return params[3] - num;

  00068	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0006b	5e		 pop	 esi
  0006c	2b c1		 sub	 eax, ecx
  0006e	5b		 pop	 ebx

; 1438 : }

  0006f	c3		 ret	 0
?n_strcat@@YAHPAUtagAMX@@PAH@Z ENDP			; n_strcat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?amx_trim@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_originalLength$1$ = -4					; size = 4
_length$ = -4						; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?amx_trim@@YAHPAUtagAMX@@PAH@Z PROC			; amx_trim, COMDAT

; 1389 : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1390 : 	int length;
; 1391 : 	auto string = get_amxstring(amx, params[1], 0, length);

  00005	8d 44 24 10	 lea	 eax, DWORD PTR _length$[esp+20]
  00009	50		 push	 eax
  0000a	8b 44 24 20	 mov	 eax, DWORD PTR _params$[esp+20]
  0000e	6a 00		 push	 0
  00010	ff 70 04	 push	 DWORD PTR [eax+4]
  00013	ff 74 24 24	 push	 DWORD PTR _amx$[esp+28]
  00017	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  0001c	8b d8		 mov	 ebx, eax

; 1392 : 
; 1393 : 	auto leftSpaces  = utf8getspaces(string);

  0001e	53		 push	 ebx
  0001f	e8 00 00 00 00	 call	 ?utf8getspaces@@YAIPBD@Z ; utf8getspaces

; 1394 : 	auto rightSpaces = 0u;
; 1395 : 
; 1396 : 	auto originalLength = length;

  00024	8b 74 24 24	 mov	 esi, DWORD PTR _length$[esp+40]
  00028	8b e8		 mov	 ebp, eax
  0002a	83 c4 14	 add	 esp, 20			; 00000014H
  0002d	33 ff		 xor	 edi, edi
  0002f	8b c6		 mov	 eax, esi
  00031	89 44 24 10	 mov	 DWORD PTR _originalLength$1$[esp+20], eax

; 1397 : 
; 1398 : 	if (leftSpaces < size_t(length))

  00035	3b ee		 cmp	 ebp, esi
  00037	73 21		 jae	 SHORT $LN3@amx_trim

; 1399 : 	{
; 1400 : 		while (--length >= 0 && utf8isspace(string + length))

  00039	83 ee 01	 sub	 esi, 1
  0003c	78 1c		 js	 SHORT $LN3@amx_trim
  0003e	66 90		 npad	 2
$LL2@amx_trim:
  00040	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?utf8isspace@@YA_NPBD@Z	; utf8isspace
  00049	83 c4 04	 add	 esp, 4
  0004c	84 c0		 test	 al, al
  0004e	74 06		 je	 SHORT $LN10@amx_trim

; 1401 : 		{
; 1402 : 			++rightSpaces;

  00050	47		 inc	 edi
  00051	83 ee 01	 sub	 esi, 1
  00054	79 ea		 jns	 SHORT $LL2@amx_trim
$LN10@amx_trim:
  00056	8b 44 24 10	 mov	 eax, DWORD PTR _originalLength$1$[esp+20]
$LN3@amx_trim:

; 1403 : 		}
; 1404 : 	}
; 1405 : 
; 1406 : 	auto totalSpaces = leftSpaces + rightSpaces;

  0005a	8d 34 2f	 lea	 esi, DWORD PTR [edi+ebp]

; 1407 : 
; 1408 : 	set_amxstring(amx, params[1], string + leftSpaces, originalLength - totalSpaces);

  0005d	2b c6		 sub	 eax, esi
  0005f	8d 0c 2b	 lea	 ecx, DWORD PTR [ebx+ebp]
  00062	50		 push	 eax
  00063	8b 44 24 20	 mov	 eax, DWORD PTR _params$[esp+20]
  00067	51		 push	 ecx
  00068	ff 70 04	 push	 DWORD PTR [eax+4]
  0006b	ff 74 24 24	 push	 DWORD PTR _amx$[esp+28]
  0006f	e8 00 00 00 00	 call	 ?set_amxstring@@YAHPAUtagAMX@@HPBDH@Z ; set_amxstring
  00074	83 c4 10	 add	 esp, 16			; 00000010H

; 1409 : 
; 1410 : 	return totalSpaces;

  00077	8b c6		 mov	 eax, esi
  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5d		 pop	 ebp
  0007c	5b		 pop	 ebx

; 1411 : }

  0007d	59		 pop	 ecx
  0007e	c3		 ret	 0
?amx_trim@@YAHPAUtagAMX@@PAH@Z ENDP			; amx_trim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?amx_strlen@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_len$ = -4						; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?amx_strlen@@YAHPAUtagAMX@@PAH@Z PROC			; amx_strlen, COMDAT

; 1381 : {

  00000	51		 push	 ecx

; 1382 : 	int len;
; 1383 : 	char *str = get_amxstring(amx, params[1], 0, len);

  00001	8d 04 24	 lea	 eax, DWORD PTR _len$[esp+4]
  00004	50		 push	 eax
  00005	8b 44 24 10	 mov	 eax, DWORD PTR _params$[esp+4]
  00009	6a 00		 push	 0
  0000b	ff 70 04	 push	 DWORD PTR [eax+4]
  0000e	ff 74 24 14	 push	 DWORD PTR _amx$[esp+12]
  00012	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  00017	83 c4 10	 add	 esp, 16			; 00000010H

; 1384 : 
; 1385 : 	return strlen(str);

  0001a	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0001d	0f 1f 00	 npad	 3
$LL3@amx_strlen:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $LL3@amx_strlen
  00027	2b c2		 sub	 eax, edx

; 1386 : }

  00029	59		 pop	 ecx
  0002a	c3		 ret	 0
?amx_strlen@@YAHPAUtagAMX@@PAH@Z ENDP			; amx_strlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\public\amtl\am-algorithm.h
;	COMDAT ??$Min@H@ke@@YAHABH0@Z
_TEXT	SEGMENT
_t1$ = 8						; size = 4
_t2$ = 12						; size = 4
??$Min@H@ke@@YAHABH0@Z PROC				; ke::Min<int>, COMDAT

; 40   :     return t1 < t2 ? t1 : t2;

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _t1$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR _t2$[esp-4]
  00008	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0000a	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000c	0f 4c c2	 cmovl	 eax, edx
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]

; 41   : }

  00011	c3		 ret	 0
??$Min@H@ke@@YAHABH0@Z ENDP				; ke::Min<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
; File e:\nightfire_sdk\amx\public\amtl\am-algorithm.h
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?mb_ucfirst@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_outputMaxLength$2$ = -24				; size = 4
_sourceLength$ = -24					; size = 4
_params$GSCopy$1$ = -20					; size = 4
_amx$GSCopy$1$ = -16					; size = 4
_output$1 = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?mb_ucfirst@@YAHPAUtagAMX@@PAH@Z PROC			; mb_ucfirst, COMDAT

; 1342 : {

  00000	83 ec 18	 sub	 esp, 24			; 00000018H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 14	 mov	 DWORD PTR __$ArrayPad$[esp+24], eax
  0000e	8b 44 24 1c	 mov	 eax, DWORD PTR _amx$[esp+20]

; 1343 : 	enum args { arg_count, arg_string, arg_maxlength };
; 1344 : 
; 1345 : 	auto sourceLength = 0;
; 1346 : 	auto source = get_amxstring(amx, params[arg_string], 0, sourceLength);

  00012	8d 0c 24	 lea	 ecx, DWORD PTR _sourceLength$[esp+24]
  00015	53		 push	 ebx
  00016	8b 5c 24 24	 mov	 ebx, DWORD PTR _params$[esp+24]
  0001a	55		 push	 ebp
  0001b	56		 push	 esi
  0001c	51		 push	 ecx
  0001d	6a 00		 push	 0
  0001f	ff 73 04	 push	 DWORD PTR [ebx+4]
  00022	89 44 24 20	 mov	 DWORD PTR _amx$GSCopy$1$[esp+48], eax
  00026	50		 push	 eax
  00027	89 5c 24 20	 mov	 DWORD PTR _params$GSCopy$1$[esp+52], ebx
  0002b	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _sourceLength$[esp+52], 0
  00033	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring

; 1347 : 
; 1348 : 	auto outputMaxLength = params[arg_maxlength];
; 1349 : 
; 1350 : 	if (outputMaxLength <= 0)
; 1351 : 	{
; 1352 : 		outputMaxLength = sourceLength;
; 1353 : 	}
; 1354 : 
; 1355 : 	// Retrieves the first character length in bytes.
; 1356 : 	auto firstChLength = utf8seek(source, sourceLength, source, 1, SEEK_CUR) - source;

  00038	6a 01		 push	 1
  0003a	8b f0		 mov	 esi, eax
  0003c	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0003f	8b 5c 24 20	 mov	 ebx, DWORD PTR _sourceLength$[esp+56]
  00043	85 c0		 test	 eax, eax
  00045	6a 01		 push	 1
  00047	56		 push	 esi
  00048	0f 4e c3	 cmovle	 eax, ebx
  0004b	53		 push	 ebx
  0004c	56		 push	 esi
  0004d	89 44 24 30	 mov	 DWORD PTR _outputMaxLength$2$[esp+72], eax
  00051	e8 00 00 00 00	 call	 _utf8seek
  00056	8b e8		 mov	 ebp, eax
  00058	83 c4 24	 add	 esp, 36			; 00000024H
  0005b	2b ee		 sub	 ebp, esi

; 1357 : 
; 1358 : 	if (firstChLength)

  0005d	74 5e		 je	 SHORT $LN3@mb_ucfirst

; 1359 : 	{
; 1360 : 		char output[8] = {};
; 1361 : 		auto outputLength = utf8toupper(source, firstChLength, output, MAX_BUFFER_LENGTH - 1, UTF8_LOCALE_DEFAULT, nullptr, TRUE);

  0005f	57		 push	 edi
  00060	6a 01		 push	 1
  00062	6a 00		 push	 0
  00064	6a 00		 push	 0
  00066	68 ff 3f 00 00	 push	 16383			; 00003fffH
  0006b	8d 44 24 2c	 lea	 eax, DWORD PTR _output$1[esp+56]
  0006f	0f 57 c0	 xorps	 xmm0, xmm0
  00072	50		 push	 eax
  00073	55		 push	 ebp
  00074	56		 push	 esi
  00075	66 0f d6 44 24
	38		 movq	 QWORD PTR _output$1[esp+68], xmm0
  0007b	e8 00 00 00 00	 call	 _utf8toupper
  00080	8b f8		 mov	 edi, eax
  00082	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1362 : 
; 1363 : 		// The converted character is either larger or smaller in bytes.
; 1364 : 		if (firstChLength != outputLength)

  00085	3b ef		 cmp	 ebp, edi
  00087	74 24		 je	 SHORT $LN4@mb_ucfirst

; 1365 : 		{
; 1366 : 			// Calculates the new string length and makes sure we don't go over the buffer size (fairly unlikely).
; 1367 : 			sourceLength = ke::Min<int>(sourceLength + (outputLength - firstChLength), outputMaxLength);

  00089	8b cf		 mov	 ecx, edi
  0008b	2b cd		 sub	 ecx, ebp
  0008d	03 cb		 add	 ecx, ebx
; File e:\nightfire_sdk\amx\public\amtl\am-algorithm.h

; 40   :     return t1 < t2 ? t1 : t2;

  0008f	8b 5c 24 10	 mov	 ebx, DWORD PTR _outputMaxLength$2$[esp+40]
  00093	3b cb		 cmp	 ecx, ebx
  00095	0f 4c d9	 cmovl	 ebx, ecx
; File e:\nightfire_sdk\amx\amxmodx\string.cpp

; 1370 : 			memmove(source + outputLength, source + firstChLength, (sourceLength - outputLength) * sizeof(char));	

  00098	8b c3		 mov	 eax, ebx
  0009a	2b c7		 sub	 eax, edi
  0009c	50		 push	 eax
  0009d	8d 04 2e	 lea	 eax, DWORD PTR [esi+ebp]
  000a0	50		 push	 eax
  000a1	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 _memmove
  000aa	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@mb_ucfirst:

; 1371 : 		}
; 1372 : 
; 1373 : 		// Copy the new character at the start of the string.
; 1374 : 		memcpy(source, output, outputLength);

  000ad	57		 push	 edi
  000ae	8d 44 24 20	 lea	 eax, DWORD PTR _output$1[esp+44]
  000b2	50		 push	 eax
  000b3	56		 push	 esi
  000b4	e8 00 00 00 00	 call	 _memcpy
  000b9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bc	5f		 pop	 edi
$LN3@mb_ucfirst:

; 1375 : 	}
; 1376 : 
; 1377 : 	return set_amxstring_utf8(amx, params[arg_string], source, sourceLength, outputMaxLength);

  000bd	ff 74 24 0c	 push	 DWORD PTR _outputMaxLength$2$[esp+36]
  000c1	8b 44 24 14	 mov	 eax, DWORD PTR _params$GSCopy$1$[esp+40]
  000c5	53		 push	 ebx
  000c6	56		 push	 esi
  000c7	ff 70 04	 push	 DWORD PTR [eax+4]
  000ca	ff 74 24 24	 push	 DWORD PTR _amx$GSCopy$1$[esp+52]
  000ce	e8 00 00 00 00	 call	 ??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z ; set_amxstring_utf8<char>

; 1378 : }

  000d3	8b 4c 24 34	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+56]
  000d7	83 c4 14	 add	 esp, 20			; 00000014H
  000da	5e		 pop	 esi
  000db	5d		 pop	 ebp
  000dc	5b		 pop	 ebx
  000dd	33 cc		 xor	 ecx, esp
  000df	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e4	83 c4 18	 add	 esp, 24			; 00000018H
  000e7	c3		 ret	 0
?mb_ucfirst@@YAHPAUtagAMX@@PAH@Z ENDP			; mb_ucfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?amx_ucfirst@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?amx_ucfirst@@YAHPAUtagAMX@@PAH@Z PROC			; amx_ucfirst, COMDAT

; 1331 : 	cell *str = get_amxaddr(amx, params[1]);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _params$[esp-4]
  00004	56		 push	 esi
  00005	ff 70 04	 push	 DWORD PTR [eax+4]
  00008	ff 74 24 0c	 push	 DWORD PTR _amx$[esp+4]
  0000c	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr
  00011	8b f0		 mov	 esi, eax

; 1332 : 	
; 1333 : 	if (!isalpha((char)str[0]) || !(str[0] & (1<<5)))

  00013	0f be 0e	 movsx	 ecx, BYTE PTR [esi]
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 _isalpha
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001f	85 c0		 test	 eax, eax
  00021	74 13		 je	 SHORT $LN3@amx_ucfirs
  00023	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00025	f6 c1 20	 test	 cl, 32			; 00000020H
  00028	74 0c		 je	 SHORT $LN3@amx_ucfirs

; 1335 : 	str[0] &= ~(1<<5);

  0002a	83 e1 df	 and	 ecx, -33		; ffffffdfH

; 1336 : 	
; 1337 : 	return 1;

  0002d	b8 01 00 00 00	 mov	 eax, 1
  00032	89 0e		 mov	 DWORD PTR [esi], ecx
  00034	5e		 pop	 esi

; 1338 : }

  00035	c3		 ret	 0
$LN3@amx_ucfirs:

; 1334 : 		return 0;

  00036	33 c0		 xor	 eax, eax
  00038	5e		 pop	 esi

; 1338 : }

  00039	c3		 ret	 0
?amx_ucfirst@@YAHPAUtagAMX@@PAH@Z ENDP			; amx_ucfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?get_char_bytes@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_len$ = -4						; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?get_char_bytes@@YAHPAUtagAMX@@PAH@Z PROC		; get_char_bytes, COMDAT

; 1322 : {

  00000	51		 push	 ecx

; 1323 : 	int len;
; 1324 : 	char *str = get_amxstring(amx, params[1], 0, len);

  00001	8d 04 24	 lea	 eax, DWORD PTR _len$[esp+4]
  00004	50		 push	 eax
  00005	8b 44 24 10	 mov	 eax, DWORD PTR _params$[esp+4]
  00009	6a 00		 push	 0
  0000b	ff 70 04	 push	 DWORD PTR [eax+4]
  0000e	ff 74 24 14	 push	 DWORD PTR _amx$[esp+12]
  00012	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring

; 1325 : 
; 1326 : 	return UTIL_GetUTF8CharBytes(str);

  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ?UTIL_GetUTF8CharBytes@@YAIPBD@Z ; UTIL_GetUTF8CharBytes

; 1327 : };

  0001d	83 c4 18	 add	 esp, 24			; 00000018H
  00020	c3		 ret	 0
?get_char_bytes@@YAHPAUtagAMX@@PAH@Z ENDP		; get_char_bytes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?is_char_mb@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_chr$ = 12						; size = 1
_params$ = 12						; size = 4
?is_char_mb@@YAHPAUtagAMX@@PAH@Z PROC			; is_char_mb, COMDAT

; 1310 : 	char chr = params[1];

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _params$[esp-4]
  00004	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  00007	88 44 24 08	 mov	 BYTE PTR _chr$[esp-4], al

; 1311 : 
; 1312 : 	unsigned int bytes = UTIL_GetUTF8CharBytes(&chr);

  0000b	8d 44 24 08	 lea	 eax, DWORD PTR _chr$[esp-4]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?UTIL_GetUTF8CharBytes@@YAIPBD@Z ; UTIL_GetUTF8CharBytes

; 1313 : 	if (bytes == 1)

  00015	33 c9		 xor	 ecx, ecx
  00017	83 c4 04	 add	 esp, 4
  0001a	83 f8 01	 cmp	 eax, 1
  0001d	0f 44 c1	 cmove	 eax, ecx

; 1314 : 	{
; 1315 : 		return 0;
; 1316 : 	}
; 1317 : 
; 1318 : 	return bytes;
; 1319 : }

  00020	c3		 ret	 0
?is_char_mb@@YAHPAUtagAMX@@PAH@Z ENDP			; is_char_mb
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?is_char_lower@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_chr$ = 12						; size = 1
_params$ = 12						; size = 4
?is_char_lower@@YAHPAUtagAMX@@PAH@Z PROC		; is_char_lower, COMDAT

; 1298 : 	char chr = params[1];

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _params$[esp-4]
  00004	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  00007	88 44 24 08	 mov	 BYTE PTR _chr$[esp-4], al

; 1299 : 
; 1300 : 	if (UTIL_GetUTF8CharBytes(&chr) != 1)

  0000b	8d 44 24 08	 lea	 eax, DWORD PTR _chr$[esp-4]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?UTIL_GetUTF8CharBytes@@YAIPBD@Z ; UTIL_GetUTF8CharBytes
  00015	83 c4 04	 add	 esp, 4
  00018	83 f8 01	 cmp	 eax, 1
  0001b	74 03		 je	 SHORT $LN2@is_char_lo

; 1301 : 	{
; 1302 : 		return 0;

  0001d	33 c0		 xor	 eax, eax

; 1306 : }

  0001f	c3		 ret	 0
$LN2@is_char_lo:

; 1303 : 	}
; 1304 : 
; 1305 : 	return islower(chr);

  00020	0f be 44 24 08	 movsx	 eax, BYTE PTR _chr$[esp-4]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _islower
  0002b	83 c4 04	 add	 esp, 4

; 1306 : }

  0002e	c3		 ret	 0
?is_char_lower@@YAHPAUtagAMX@@PAH@Z ENDP		; is_char_lower
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?is_char_upper@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_chr$ = 12						; size = 1
_params$ = 12						; size = 4
?is_char_upper@@YAHPAUtagAMX@@PAH@Z PROC		; is_char_upper, COMDAT

; 1286 : 	char chr = params[1];

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _params$[esp-4]
  00004	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  00007	88 44 24 08	 mov	 BYTE PTR _chr$[esp-4], al

; 1287 : 
; 1288 : 	if (UTIL_GetUTF8CharBytes(&chr) != 1)

  0000b	8d 44 24 08	 lea	 eax, DWORD PTR _chr$[esp-4]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?UTIL_GetUTF8CharBytes@@YAIPBD@Z ; UTIL_GetUTF8CharBytes
  00015	83 c4 04	 add	 esp, 4
  00018	83 f8 01	 cmp	 eax, 1
  0001b	74 03		 je	 SHORT $LN2@is_char_up

; 1289 : 	{
; 1290 : 		return 0;

  0001d	33 c0		 xor	 eax, eax

; 1294 : }

  0001f	c3		 ret	 0
$LN2@is_char_up:

; 1291 : 	}
; 1292 : 
; 1293 : 	return isupper(chr);

  00020	0f be 44 24 08	 movsx	 eax, BYTE PTR _chr$[esp-4]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _isupper
  0002b	83 c4 04	 add	 esp, 4

; 1294 : }

  0002e	c3		 ret	 0
?is_char_upper@@YAHPAUtagAMX@@PAH@Z ENDP		; is_char_upper
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?is_alpha@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_chr$ = 12						; size = 1
_params$ = 12						; size = 4
?is_alpha@@YAHPAUtagAMX@@PAH@Z PROC			; is_alpha, COMDAT

; 1274 : 	char chr = params[1];

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _params$[esp-4]
  00004	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  00007	88 44 24 08	 mov	 BYTE PTR _chr$[esp-4], al

; 1275 : 
; 1276 : 	if (UTIL_GetUTF8CharBytes(&chr) != 1)

  0000b	8d 44 24 08	 lea	 eax, DWORD PTR _chr$[esp-4]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?UTIL_GetUTF8CharBytes@@YAIPBD@Z ; UTIL_GetUTF8CharBytes
  00015	83 c4 04	 add	 esp, 4
  00018	83 f8 01	 cmp	 eax, 1
  0001b	74 03		 je	 SHORT $LN2@is_alpha

; 1277 : 	{
; 1278 : 		return 0;

  0001d	33 c0		 xor	 eax, eax

; 1282 : }

  0001f	c3		 ret	 0
$LN2@is_alpha:

; 1279 : 	}
; 1280 : 
; 1281 : 	return isalpha(chr);

  00020	0f be 44 24 08	 movsx	 eax, BYTE PTR _chr$[esp-4]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _isalpha
  0002b	83 c4 04	 add	 esp, 4

; 1282 : }

  0002e	c3		 ret	 0
?is_alpha@@YAHPAUtagAMX@@PAH@Z ENDP			; is_alpha
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?is_space@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_chr$ = 12						; size = 1
_params$ = 12						; size = 4
?is_space@@YAHPAUtagAMX@@PAH@Z PROC			; is_space, COMDAT

; 1262 : 	char chr = params[1];

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _params$[esp-4]
  00004	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  00007	88 44 24 08	 mov	 BYTE PTR _chr$[esp-4], al

; 1263 : 
; 1264 : 	if (UTIL_GetUTF8CharBytes(&chr) != 1)

  0000b	8d 44 24 08	 lea	 eax, DWORD PTR _chr$[esp-4]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?UTIL_GetUTF8CharBytes@@YAIPBD@Z ; UTIL_GetUTF8CharBytes
  00015	83 c4 04	 add	 esp, 4
  00018	83 f8 01	 cmp	 eax, 1
  0001b	74 03		 je	 SHORT $LN2@is_space

; 1265 : 	{
; 1266 : 		return 0;

  0001d	33 c0		 xor	 eax, eax

; 1270 : }

  0001f	c3		 ret	 0
$LN2@is_space:

; 1267 : 	}
; 1268 : 
; 1269 : 	return isspace(chr);

  00020	0f be 44 24 08	 movsx	 eax, BYTE PTR _chr$[esp-4]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _isspace
  0002b	83 c4 04	 add	 esp, 4

; 1270 : }

  0002e	c3		 ret	 0
?is_space@@YAHPAUtagAMX@@PAH@Z ENDP			; is_space
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?is_alnum@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_chr$ = 12						; size = 1
_params$ = 12						; size = 4
?is_alnum@@YAHPAUtagAMX@@PAH@Z PROC			; is_alnum, COMDAT

; 1250 : 	char chr = params[1];

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _params$[esp-4]
  00004	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  00007	88 44 24 08	 mov	 BYTE PTR _chr$[esp-4], al

; 1251 : 
; 1252 : 	if (UTIL_GetUTF8CharBytes(&chr) != 1)

  0000b	8d 44 24 08	 lea	 eax, DWORD PTR _chr$[esp-4]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?UTIL_GetUTF8CharBytes@@YAIPBD@Z ; UTIL_GetUTF8CharBytes
  00015	83 c4 04	 add	 esp, 4
  00018	83 f8 01	 cmp	 eax, 1
  0001b	74 03		 je	 SHORT $LN2@is_alnum

; 1253 : 	{
; 1254 : 		return 0;

  0001d	33 c0		 xor	 eax, eax

; 1258 : }

  0001f	c3		 ret	 0
$LN2@is_alnum:

; 1255 : 	}
; 1256 : 
; 1257 : 	return isalnum(chr);

  00020	0f be 44 24 08	 movsx	 eax, BYTE PTR _chr$[esp-4]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _isalnum
  0002b	83 c4 04	 add	 esp, 4

; 1258 : }

  0002e	c3		 ret	 0
?is_alnum@@YAHPAUtagAMX@@PAH@Z ENDP			; is_alnum
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?is_digit@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_chr$ = 12						; size = 1
_params$ = 12						; size = 4
?is_digit@@YAHPAUtagAMX@@PAH@Z PROC			; is_digit, COMDAT

; 1238 : 	char chr = params[1];

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _params$[esp-4]
  00004	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  00007	88 44 24 08	 mov	 BYTE PTR _chr$[esp-4], al

; 1239 : 
; 1240 : 	if (UTIL_GetUTF8CharBytes(&chr) != 1)

  0000b	8d 44 24 08	 lea	 eax, DWORD PTR _chr$[esp-4]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?UTIL_GetUTF8CharBytes@@YAIPBD@Z ; UTIL_GetUTF8CharBytes
  00015	83 c4 04	 add	 esp, 4
  00018	83 f8 01	 cmp	 eax, 1
  0001b	74 03		 je	 SHORT $LN2@is_digit

; 1241 : 	{
; 1242 : 		return 0;

  0001d	33 c0		 xor	 eax, eax

; 1246 : }

  0001f	c3		 ret	 0
$LN2@is_digit:

; 1243 : 	}
; 1244 : 
; 1245 : 	return isdigit(chr);

  00020	0f be 44 24 08	 movsx	 eax, BYTE PTR _chr$[esp-4]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _isdigit
  0002b	83 c4 04	 add	 esp, 4

; 1246 : }

  0002e	c3		 ret	 0
?is_digit@@YAHPAUtagAMX@@PAH@Z ENDP			; is_digit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?format_args@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_len$ = 12						; size = 4
_params$ = 12						; size = 4
?format_args@@YAHPAUtagAMX@@PAH@Z PROC			; format_args, COMDAT

; 1221 : {

  00000	57		 push	 edi

; 1222 : 	int len;
; 1223 : 	int pos = params[3];

  00001	8b 7c 24 0c	 mov	 edi, DWORD PTR _params$[esp]
  00005	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]

; 1224 : 	
; 1225 : 	if (pos < 0)

  00008	85 c0		 test	 eax, eax
  0000a	79 17		 jns	 SHORT $LN2@format_arg

; 1226 : 	{
; 1227 : 		LogError(amx, AMX_ERR_NATIVE, "Pos has to be a positive number");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@BOKAAEHK@Pos?5has?5to?5be?5a?5positive?5number?$AA@
  00011	6a 0a		 push	 10			; 0000000aH
  00013	ff 74 24 10	 push	 DWORD PTR _amx$[esp+8]
  00017	e8 00 00 00 00	 call	 _LogError
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1228 : 		return 0;

  0001f	33 c0		 xor	 eax, eax
  00021	5f		 pop	 edi

; 1234 : }

  00022	c3		 ret	 0
$LN2@format_arg:

; 1229 : 	}
; 1230 : 
; 1231 : 	char* string = format_arguments(amx, pos, len); // indexed from 0

  00023	8d 4c 24 0c	 lea	 ecx, DWORD PTR _len$[esp]
  00027	51		 push	 ecx
  00028	50		 push	 eax
  00029	ff 74 24 10	 push	 DWORD PTR _amx$[esp+8]
  0002d	e8 00 00 00 00	 call	 ?format_arguments@@YAPADPAUtagAMX@@HAAH@Z ; format_arguments

; 1232 : 	
; 1233 : 	return set_amxstring_utf8(amx, params[1], string, len, params[2]);

  00032	ff 77 08	 push	 DWORD PTR [edi+8]
  00035	ff 74 24 1c	 push	 DWORD PTR _len$[esp+16]
  00039	50		 push	 eax
  0003a	ff 77 04	 push	 DWORD PTR [edi+4]
  0003d	ff 74 24 24	 push	 DWORD PTR _amx$[esp+28]
  00041	e8 00 00 00 00	 call	 ??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z ; set_amxstring_utf8<char>
  00046	83 c4 20	 add	 esp, 32			; 00000020H
  00049	5f		 pop	 edi

; 1234 : }

  0004a	c3		 ret	 0
?format_args@@YAHPAUtagAMX@@PAH@Z ENDP			; format_args
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?split_string@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_textLen$ = -12						; size = 4
_maxLen$1$ = -8						; size = 4
_splitLen$ = -8						; size = 4
_split$1$ = -4						; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?split_string@@YAHPAUtagAMX@@PAH@Z PROC			; split_string, COMDAT

; 1184 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx

; 1185 : 	int textLen, splitLen;
; 1186 : 	char *text = get_amxstring(amx, params[1], 0, textLen);

  00004	8b 5c 24 14	 mov	 ebx, DWORD PTR _amx$[esp+12]
  00008	8d 44 24 04	 lea	 eax, DWORD PTR _textLen$[esp+16]
  0000c	55		 push	 ebp
  0000d	56		 push	 esi
  0000e	8b 74 24 20	 mov	 esi, DWORD PTR _params$[esp+20]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	ff 76 04	 push	 DWORD PTR [esi+4]
  00018	53		 push	 ebx
  00019	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  0001e	8b e8		 mov	 ebp, eax

; 1187 : 	const char *split = get_amxstring(amx, params[2], 1, splitLen);

  00020	8d 44 24 20	 lea	 eax, DWORD PTR _splitLen$[esp+40]
  00024	50		 push	 eax
  00025	6a 01		 push	 1
  00027	ff 76 08	 push	 DWORD PTR [esi+8]
  0002a	53		 push	 ebx
  0002b	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring

; 1188 : 
; 1189 : 	if (splitLen > textLen)

  00030	8b 5c 24 30	 mov	 ebx, DWORD PTR _splitLen$[esp+56]
  00034	8b c8		 mov	 ecx, eax
  00036	8b 44 24 2c	 mov	 eax, DWORD PTR _textLen$[esp+56]
  0003a	83 c4 20	 add	 esp, 32			; 00000020H
  0003d	89 4c 24 14	 mov	 DWORD PTR _split$1$[esp+24], ecx
  00041	3b d8		 cmp	 ebx, eax
  00043	7e 0a		 jle	 SHORT $LN5@split_stri

; 1190 : 	{
; 1191 : 		return -1;

  00045	5e		 pop	 esi
  00046	5d		 pop	 ebp
  00047	83 c8 ff	 or	 eax, -1
  0004a	5b		 pop	 ebx

; 1218 : }

  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	c3		 ret	 0
$LN5@split_stri:

; 1192 : 	}
; 1193 : 
; 1194 : 	int maxLen = params[4];

  0004f	8b 56 10	 mov	 edx, DWORD PTR [esi+16]

; 1195 : 
; 1196 : 	/**
; 1197 : 	* Note that it's <= ... you could also just add 1,
; 1198 : 	* but this is a bit nicer
; 1199 : 	*/
; 1200 : 	for (int i = 0; i <= textLen - splitLen; i++)

  00052	33 f6		 xor	 esi, esi
  00054	57		 push	 edi
  00055	8b f8		 mov	 edi, eax
  00057	89 54 24 14	 mov	 DWORD PTR _maxLen$1$[esp+28], edx
  0005b	2b fb		 sub	 edi, ebx
  0005d	78 1c		 js	 SHORT $LN3@split_stri
  0005f	90		 npad	 1
$LL4@split_stri:

; 1201 : 	{
; 1202 : 		if (strncmp(&text[i], split, splitLen) == 0)

  00060	53		 push	 ebx
  00061	51		 push	 ecx
  00062	8d 04 2e	 lea	 eax, DWORD PTR [esi+ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 _strncmp
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006e	85 c0		 test	 eax, eax
  00070	74 14		 je	 SHORT $LN11@split_stri

; 1195 : 
; 1196 : 	/**
; 1197 : 	* Note that it's <= ... you could also just add 1,
; 1198 : 	* but this is a bit nicer
; 1199 : 	*/
; 1200 : 	for (int i = 0; i <= textLen - splitLen; i++)

  00072	8b 4c 24 18	 mov	 ecx, DWORD PTR _split$1$[esp+28]
  00076	46		 inc	 esi
  00077	3b f7		 cmp	 esi, edi
  00079	7e e5		 jle	 SHORT $LL4@split_stri
$LN3@split_stri:
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5d		 pop	 ebp

; 1214 : 		}
; 1215 : 	}
; 1216 : 
; 1217 : 	return -1;

  0007e	83 c8 ff	 or	 eax, -1
  00081	5b		 pop	 ebx

; 1218 : }

  00082	83 c4 0c	 add	 esp, 12			; 0000000cH
  00085	c3		 ret	 0
$LN11@split_stri:

; 1203 : 		{
; 1204 : 			/* Split hereeeee */
; 1205 : 			if (i > maxLen)

  00086	8b 44 24 14	 mov	 eax, DWORD PTR _maxLen$1$[esp+28]
  0008a	3b f0		 cmp	 esi, eax
  0008c	7e 03		 jle	 SHORT $LN7@split_stri

; 1206 : 			{
; 1207 : 				set_amxstring_utf8(amx, params[3], text, textLen, maxLen);

  0008e	50		 push	 eax

; 1208 : 			}
; 1209 : 			else

  0008f	eb 01		 jmp	 SHORT $LN16@split_stri
$LN7@split_stri:

; 1210 : 			{
; 1211 : 				set_amxstring_utf8(amx, params[3], text, textLen, i);

  00091	56		 push	 esi
$LN16@split_stri:
  00092	8b 44 24 14	 mov	 eax, DWORD PTR _textLen$[esp+32]
  00096	50		 push	 eax
  00097	8b 44 24 2c	 mov	 eax, DWORD PTR _params$[esp+32]
  0009b	55		 push	 ebp
  0009c	ff 70 0c	 push	 DWORD PTR [eax+12]
  0009f	8b 44 24 30	 mov	 eax, DWORD PTR _amx$[esp+40]
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 ??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z ; set_amxstring_utf8<char>
  000a9	83 c4 14	 add	 esp, 20			; 00000014H

; 1212 : 			}
; 1213 : 			return i + splitLen;

  000ac	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5d		 pop	 ebp
  000b2	5b		 pop	 ebx

; 1218 : }

  000b3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b6	c3		 ret	 0
?split_string@@YAHPAUtagAMX@@PAH@Z ENDP			; split_string
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?strbreak@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_string$1$ = -24					; size = 4
_beg$1$ = -20						; size = 4
_spaces$1$ = -16					; size = 4
_LeftMax$1$ = -12					; size = 4
_RightMax$1$ = -8					; size = 4
tv344 = -4						; size = 4
__len$ = -4						; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?strbreak@@YAHPAUtagAMX@@PAH@Z PROC			; strbreak, COMDAT

; 1112 : {

  00000	83 ec 18	 sub	 esp, 24			; 00000018H
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	57		 push	 edi

; 1113 : 	int _len;
; 1114 : 	bool in_quote = false;
; 1115 : 	bool had_quotes = false;
; 1116 : 	size_t i = 0;
; 1117 : 	size_t beg = 0;
; 1118 : 
; 1119 : 	char *string = get_amxstring(amx, params[1], 0, _len);

  00007	8b 7c 24 30	 mov	 edi, DWORD PTR _params$[esp+36]
  0000b	8d 44 24 24	 lea	 eax, DWORD PTR __len$[esp+40]
  0000f	50		 push	 eax
  00010	33 f6		 xor	 esi, esi
  00012	32 db		 xor	 bl, bl
  00014	56		 push	 esi
  00015	ff 77 04	 push	 DWORD PTR [edi+4]
  00018	32 ff		 xor	 bh, bh
  0001a	ff 74 24 38	 push	 DWORD PTR _amx$[esp+48]
  0001e	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring

; 1120 : 	cell *right = get_amxaddr(amx, params[4]);

  00023	ff 77 10	 push	 DWORD PTR [edi+16]
  00026	8b e8		 mov	 ebp, eax
  00028	ff 74 24 40	 push	 DWORD PTR _amx$[esp+56]
  0002c	89 6c 24 28	 mov	 DWORD PTR _string$1$[esp+64], ebp
  00030	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 1121 : 	int LeftMax = params[3];

  00035	8b 4c 24 48	 mov	 ecx, DWORD PTR _params$[esp+60]
  00039	8b f8		 mov	 edi, eax

; 1122 : 	int RightMax = params[5];
; 1123 : 
; 1124 : 	size_t len = (size_t)_len;
; 1125 : 	size_t spaces;
; 1126 : 
; 1127 : 	if ((spaces = utf8getspaces(string)) > 0)

  0003b	55		 push	 ebp
  0003c	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0003f	89 44 24 38	 mov	 DWORD PTR _LeftMax$1$[esp+68], eax
  00043	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00046	89 44 24 3c	 mov	 DWORD PTR _RightMax$1$[esp+68], eax
  0004a	e8 00 00 00 00	 call	 ?utf8getspaces@@YAIPBD@Z ; utf8getspaces

; 1128 : 	{
; 1129 : 		i += spaces;
; 1130 : 	}
; 1131 : 
; 1132 : 	beg = i;
; 1133 : 	for (; i<len; i++)

  0004f	8b 6c 24 40	 mov	 ebp, DWORD PTR __len$[esp+68]
  00053	83 c4 1c	 add	 esp, 28			; 0000001cH
  00056	85 c0		 test	 eax, eax
  00058	89 44 24 18	 mov	 DWORD PTR _spaces$1$[esp+40], eax
  0005c	0f 45 f0	 cmovne	 esi, eax
  0005f	89 74 24 14	 mov	 DWORD PTR _beg$1$[esp+40], esi
  00063	3b f5		 cmp	 esi, ebp
  00065	73 6a		 jae	 SHORT $LN42@strbreak
$LL4@strbreak:
  00067	8b 44 24 10	 mov	 eax, DWORD PTR _string$1$[esp+40]
  0006b	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]

; 1134 : 	{
; 1135 : 		if (string[i] == '"' && !in_quote)

  0006e	8a 01		 mov	 al, BYTE PTR [ecx]
  00070	3c 22		 cmp	 al, 34			; 00000022H
  00072	75 41		 jne	 SHORT $LN10@strbreak
  00074	84 db		 test	 bl, bl
  00076	75 06		 jne	 SHORT $LN8@strbreak

; 1136 : 		{
; 1137 : 			in_quote = (had_quotes = true);

  00078	b7 01		 mov	 bh, 1
  0007a	8a df		 mov	 bl, bh
  0007c	eb 4e		 jmp	 SHORT $LN2@strbreak
$LN8@strbreak:

; 1138 : 		} else if (string[i] == '"' && in_quote) {

  0007e	3c 22		 cmp	 al, 34			; 00000022H
  00080	75 33		 jne	 SHORT $LN10@strbreak
  00082	84 db		 test	 bl, bl
  00084	74 33		 je	 SHORT $LN41@strbreak

; 1139 : 			in_quote = false;
; 1140 : 			if (i == len-1)

  00086	8d 45 ff	 lea	 eax, DWORD PTR [ebp-1]
  00089	32 db		 xor	 bl, bl
  0008b	3b f0		 cmp	 esi, eax
  0008d	75 3d		 jne	 SHORT $LN2@strbreak
$do_copy$47:

; 1144 : 			{
; 1145 : do_copy:
; 1146 : 				size_t pos = i;

  0008f	8b d6		 mov	 edx, esi

; 1147 : 				i += spaces;

  00091	03 74 24 18	 add	 esi, DWORD PTR _spaces$1$[esp+40]

; 1148 : 
; 1149 : 				const char *start = had_quotes ? &(string[beg+1]) : &(string[beg]);

  00095	84 ff		 test	 bh, bh
  00097	0f 84 7f 00 00
	00		 je	 $LN18@strbreak
  0009d	8b 44 24 10	 mov	 eax, DWORD PTR _string$1$[esp+40]

; 1150 : 				size_t _end = had_quotes ? (i==len-1 ? 1 : 2) : 0;

  000a1	33 c9		 xor	 ecx, ecx
  000a3	8b 5c 24 14	 mov	 ebx, DWORD PTR _beg$1$[esp+40]
  000a7	40		 inc	 eax
  000a8	03 d8		 add	 ebx, eax
  000aa	8d 45 ff	 lea	 eax, DWORD PTR [ebp-1]
  000ad	3b f0		 cmp	 esi, eax
  000af	0f 95 c1	 setne	 cl
  000b2	41		 inc	 ecx
  000b3	eb 71		 jmp	 SHORT $LN21@strbreak
$LN10@strbreak:

; 1141 : 				goto do_copy;
; 1142 : 		} else {
; 1143 : 			if (!in_quote && (spaces = utf8getspaces(string + i)) > 0)

  000b5	84 db		 test	 bl, bl
  000b7	75 13		 jne	 SHORT $LN2@strbreak
$LN41@strbreak:
  000b9	51		 push	 ecx
  000ba	e8 00 00 00 00	 call	 ?utf8getspaces@@YAIPBD@Z ; utf8getspaces
  000bf	8b d0		 mov	 edx, eax
  000c1	83 c4 04	 add	 esp, 4
  000c4	89 54 24 18	 mov	 DWORD PTR _spaces$1$[esp+40], edx
  000c8	85 d2		 test	 edx, edx
  000ca	75 c3		 jne	 SHORT $do_copy$47
$LN2@strbreak:

; 1128 : 	{
; 1129 : 		i += spaces;
; 1130 : 	}
; 1131 : 
; 1132 : 	beg = i;
; 1133 : 	for (; i<len; i++)

  000cc	46		 inc	 esi
  000cd	3b f5		 cmp	 esi, ebp
  000cf	72 96		 jb	 SHORT $LL4@strbreak
$LN42@strbreak:

; 1168 : 				}
; 1169 : 				*right = '\0';
; 1170 : 				return 1;
; 1171 : 			}
; 1172 : 		}
; 1173 : 	}
; 1174 : 
; 1175 : 	//if we got here, there was nothing to break
; 1176 : 	set_amxstring_utf8(amx, params[2], &(string[beg]), strlen(&(string[beg])), LeftMax);

  000d1	8b 54 24 10	 mov	 edx, DWORD PTR _string$1$[esp+40]
  000d5	03 54 24 14	 add	 edx, DWORD PTR _beg$1$[esp+40]
  000d9	8b ca		 mov	 ecx, edx
  000db	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  000de	66 90		 npad	 2
$LL44@strbreak:
  000e0	8a 01		 mov	 al, BYTE PTR [ecx]
  000e2	41		 inc	 ecx
  000e3	84 c0		 test	 al, al
  000e5	75 f9		 jne	 SHORT $LL44@strbreak
  000e7	ff 74 24 1c	 push	 DWORD PTR _LeftMax$1$[esp+40]
  000eb	8b 44 24 34	 mov	 eax, DWORD PTR _params$[esp+40]
  000ef	2b ce		 sub	 ecx, esi
  000f1	51		 push	 ecx
  000f2	52		 push	 edx
  000f3	ff 70 08	 push	 DWORD PTR [eax+8]
  000f6	ff 74 24 3c	 push	 DWORD PTR _amx$[esp+52]
  000fa	e8 00 00 00 00	 call	 ??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z ; set_amxstring_utf8<char>
  000ff	83 c4 14	 add	 esp, 20			; 00000014H

; 1177 : 	if (RightMax)

  00102	83 7c 24 20 00	 cmp	 DWORD PTR _RightMax$1$[esp+40], 0
  00107	74 06		 je	 SHORT $LN16@strbreak
$LN35@strbreak:

; 1178 : 		*right = '\0';

  00109	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN16@strbreak:
  0010f	5f		 pop	 edi
  00110	5e		 pop	 esi
  00111	5d		 pop	 ebp

; 1179 : 
; 1180 : 	return 1;

  00112	b8 01 00 00 00	 mov	 eax, 1
  00117	5b		 pop	 ebx

; 1181 : }

  00118	83 c4 18	 add	 esp, 24			; 00000018H
  0011b	c3		 ret	 0
$LN18@strbreak:

; 1148 : 
; 1149 : 				const char *start = had_quotes ? &(string[beg+1]) : &(string[beg]);

  0011c	8b 5c 24 10	 mov	 ebx, DWORD PTR _string$1$[esp+40]
  00120	03 5c 24 14	 add	 ebx, DWORD PTR _beg$1$[esp+40]

; 1150 : 				size_t _end = had_quotes ? (i==len-1 ? 1 : 2) : 0;

  00124	33 c9		 xor	 ecx, ecx
$LN21@strbreak:

; 1151 : 				size_t end = (pos - _end > (size_t)LeftMax) ? (size_t)LeftMax : pos - _end;
; 1152 : 				
; 1153 : 				// If there is anything to copy, make sure we copy min(maxlen, slicelen).
; 1154 : 				size_t copylen = end >= beg

  00126	8b 44 24 14	 mov	 eax, DWORD PTR _beg$1$[esp+40]
  0012a	2b d1		 sub	 edx, ecx
  0012c	8b 4c 24 1c	 mov	 ecx, DWORD PTR _LeftMax$1$[esp+40]
  00130	3b d1		 cmp	 edx, ecx
  00132	0f 47 d1	 cmova	 edx, ecx
  00135	3b d0		 cmp	 edx, eax
  00137	72 09		 jb	 SHORT $LN26@strbreak
  00139	2b d0		 sub	 edx, eax
  0013b	3b d1		 cmp	 edx, ecx
  0013d	0f 47 d1	 cmova	 edx, ecx
  00140	eb 02		 jmp	 SHORT $LN27@strbreak
$LN26@strbreak:
  00142	33 d2		 xor	 edx, edx
$LN27@strbreak:

; 1155 : 				                 ? ((end - beg > size_t(LeftMax))
; 1156 : 				                    ? size_t(LeftMax)
; 1157 : 				                    : end - beg
; 1158 : 				                   )
; 1159 : 				                 : 0;
; 1160 : 				set_amxstring_utf8(amx, params[2], start, strlen(start), copylen);

  00144	8b cb		 mov	 ecx, ebx
  00146	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00149	89 44 24 24	 mov	 DWORD PTR tv344[esp+40], eax
  0014d	0f 1f 00	 npad	 3
$LL43@strbreak:
  00150	8a 01		 mov	 al, BYTE PTR [ecx]
  00152	41		 inc	 ecx
  00153	84 c0		 test	 al, al
  00155	75 f9		 jne	 SHORT $LL43@strbreak
  00157	2b 4c 24 24	 sub	 ecx, DWORD PTR tv344[esp+40]
  0015b	8b 44 24 30	 mov	 eax, DWORD PTR _params$[esp+36]
  0015f	52		 push	 edx
  00160	51		 push	 ecx
  00161	53		 push	 ebx
  00162	ff 70 08	 push	 DWORD PTR [eax+8]
  00165	ff 74 24 3c	 push	 DWORD PTR _amx$[esp+52]
  00169	e8 00 00 00 00	 call	 ??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z ; set_amxstring_utf8<char>

; 1161 : 
; 1162 : 				end = (len-i+1 > (size_t)RightMax) ? (size_t)RightMax : len-i+1;

  0016e	2b ee		 sub	 ebp, esi
  00170	83 c4 14	 add	 esp, 20			; 00000014H
  00173	8d 4d 01	 lea	 ecx, DWORD PTR [ebp+1]
  00176	3b 4c 24 20	 cmp	 ecx, DWORD PTR _RightMax$1$[esp+40]
  0017a	0f 47 4c 24 20	 cmova	 ecx, DWORD PTR _RightMax$1$[esp+40]

; 1163 : 				if (end)

  0017f	85 c9		 test	 ecx, ecx
  00181	74 86		 je	 SHORT $LN35@strbreak

; 1164 : 				{
; 1165 : 					start = &(string[i]);

  00183	8b 54 24 10	 mov	 edx, DWORD PTR _string$1$[esp+40]
  00187	03 d6		 add	 edx, esi
  00189	0f 1f 80 00 00
	00 00		 npad	 7
$LL5@strbreak:

; 1166 : 					while (end--)
; 1167 : 						*right++ = (unsigned char)*start++;

  00190	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00193	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  00196	89 07		 mov	 DWORD PTR [edi], eax
  00198	83 c7 04	 add	 edi, 4
  0019b	83 e9 01	 sub	 ecx, 1
  0019e	75 f0		 jne	 SHORT $LL5@strbreak

; 1178 : 		*right = '\0';

  001a0	89 0f		 mov	 DWORD PTR [edi], ecx

; 1179 : 
; 1180 : 	return 1;

  001a2	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  001a5	5f		 pop	 edi
  001a6	5e		 pop	 esi
  001a7	5d		 pop	 ebp
  001a8	5b		 pop	 ebx

; 1181 : }

  001a9	83 c4 18	 add	 esp, 24			; 00000018H
  001ac	c3		 ret	 0
?strbreak@@YAHPAUtagAMX@@PAH@Z ENDP			; strbreak
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?argparse@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_temp$ = -12						; size = 4
_input$1$ = -8						; size = 4
_buflen$1$ = -4						; size = 4
_amx$ = 8						; size = 4
_in_quote$1$ = 12					; size = 1
_params$ = 12						; size = 4
?argparse@@YAHPAUtagAMX@@PAH@Z PROC			; argparse, COMDAT

; 1062 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 1063 : 	int temp;
; 1064 : 	const char *input = get_amxstring(amx, params[1], 0, temp);

  00005	8b 74 24 18	 mov	 esi, DWORD PTR _amx$[esp+16]
  00009	8d 44 24 08	 lea	 eax, DWORD PTR _temp$[esp+20]
  0000d	57		 push	 edi
  0000e	8b 7c 24 20	 mov	 edi, DWORD PTR _params$[esp+20]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	ff 77 04	 push	 DWORD PTR [edi+4]
  00018	56		 push	 esi
  00019	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring

; 1065 : 	size_t input_len = size_t(temp);
; 1066 : 	size_t start_pos = size_t(params[2]);
; 1067 : 
; 1068 : 	cell *buffer = get_amxaddr(amx, params[3]);

  0001e	ff 77 0c	 push	 DWORD PTR [edi+12]
  00021	89 44 24 24	 mov	 DWORD PTR _input$1$[esp+44], eax
  00025	56		 push	 esi
  00026	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 1069 : 	size_t buflen = size_t(params[4]);
; 1070 : 
; 1071 : 	// Strip all left-hand whitespace.
; 1072 : 	size_t i = start_pos;

  0002b	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  0002e	8b d8		 mov	 ebx, eax
  00030	8b 47 10	 mov	 eax, DWORD PTR [edi+16]

; 1073 : 	size_t spaces;
; 1074 : 
; 1075 : 	if ((spaces = utf8getspaces(input + i)) > 0)

  00033	8b 7c 24 28	 mov	 edi, DWORD PTR _input$1$[esp+48]
  00037	89 44 24 2c	 mov	 DWORD PTR _buflen$1$[esp+48], eax
  0003b	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]
  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 ?utf8getspaces@@YAIPBD@Z ; utf8getspaces
  00044	83 c4 1c	 add	 esp, 28			; 0000001cH
  00047	85 c0		 test	 eax, eax
  00049	74 02		 je	 SHORT $LN5@argparse

; 1076 : 	{
; 1077 : 		i += spaces;

  0004b	03 f0		 add	 esi, eax
$LN5@argparse:

; 1078 : 	}
; 1079 : 
; 1080 : 	if (i >= input_len) {

  0004d	3b 74 24 0c	 cmp	 esi, DWORD PTR _temp$[esp+24]
  00051	72 10		 jb	 SHORT $LN6@argparse

; 1102 : 	}
; 1103 : 
; 1104 : 	*bufpos = '\0';

  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  0005b	83 c8 ff	 or	 eax, -1
  0005e	5b		 pop	 ebx

; 1106 : }

  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00062	c3		 ret	 0
$LN6@argparse:

; 1081 : 		*buffer = '\0';
; 1082 : 		return -1;
; 1083 : 	}
; 1084 : 
; 1085 : 	cell *bufpos = buffer;
; 1086 : 
; 1087 : 	bool in_quote = false;

  00063	32 c0		 xor	 al, al
  00065	55		 push	 ebp
  00066	88 44 24 24	 mov	 BYTE PTR _in_quote$1$[esp+24], al
  0006a	33 ed		 xor	 ebp, ebp
  0006c	0f 1f 40 00	 npad	 4
$LL4@argparse:

; 1088 : 	for (; i < input_len; i++) {

  00070	03 fe		 add	 edi, esi

; 1089 : 		// Ignore quotes, except as an indicator as to whether to stop
; 1090 : 		// at a space.
; 1091 : 		if (input[i] == '"') {

  00072	80 3f 22	 cmp	 BYTE PTR [edi], 34	; 00000022H
  00075	75 0b		 jne	 SHORT $LN7@argparse

; 1092 : 			in_quote = !in_quote;

  00077	84 c0		 test	 al, al
  00079	0f 94 c0	 sete	 al
  0007c	88 44 24 24	 mov	 BYTE PTR _in_quote$1$[esp+24], al

; 1093 : 			continue;

  00080	eb 2e		 jmp	 SHORT $LN2@argparse
$LN7@argparse:

; 1094 : 		}
; 1095 : 
; 1096 : 		// If not in quotes, and we see a space, stop.
; 1097 : 		if (utf8isspace(input + i) && !in_quote)

  00082	57		 push	 edi
  00083	e8 00 00 00 00	 call	 ?utf8isspace@@YA_NPBD@Z	; utf8isspace
  00088	83 c4 04	 add	 esp, 4
  0008b	84 c0		 test	 al, al
  0008d	74 07		 je	 SHORT $LN8@argparse
  0008f	80 7c 24 24 00	 cmp	 BYTE PTR _in_quote$1$[esp+24], 0
  00094	74 25		 je	 SHORT $LN12@argparse
$LN8@argparse:

; 1098 : 			break;
; 1099 : 
; 1100 : 		if (size_t(bufpos - buffer) < buflen)

  00096	8b c5		 mov	 eax, ebp
  00098	c1 f8 02	 sar	 eax, 2
  0009b	3b 44 24 18	 cmp	 eax, DWORD PTR _buflen$1$[esp+28]
  0009f	73 0b		 jae	 SHORT $LN16@argparse

; 1101 : 			*bufpos++ = (unsigned char)input[i];

  000a1	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  000a4	89 03		 mov	 DWORD PTR [ebx], eax
  000a6	83 c3 04	 add	 ebx, 4
  000a9	83 c5 04	 add	 ebp, 4
$LN16@argparse:
  000ac	8a 44 24 24	 mov	 al, BYTE PTR _in_quote$1$[esp+24]
$LN2@argparse:

; 1088 : 	for (; i < input_len; i++) {

  000b0	8b 7c 24 14	 mov	 edi, DWORD PTR _input$1$[esp+28]
  000b4	46		 inc	 esi
  000b5	3b 74 24 10	 cmp	 esi, DWORD PTR _temp$[esp+28]
  000b9	72 b5		 jb	 SHORT $LL4@argparse
$LN12@argparse:
  000bb	5d		 pop	 ebp
  000bc	5f		 pop	 edi

; 1105 : 	return i;

  000bd	8b c6		 mov	 eax, esi
  000bf	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  000c5	5e		 pop	 esi
  000c6	5b		 pop	 ebx

; 1106 : }

  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ca	c3		 ret	 0
?argparse@@YAHPAUtagAMX@@PAH@Z ENDP			; argparse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?amx_strtok2@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_token$1$ = -37						; size = 1
_string$1$ = -36					; size = 4
_trim$1$ = -32						; size = 4
_right$1$ = -28						; size = 4
_left$1$ = -24						; size = 4
_len$ = -20						; size = 4
_pos$1$ = -16						; size = 4
tv411 = -12						; size = 4
_right_pos$1$ = -12					; size = 4
_left_max$1$ = -8					; size = 4
_right_max$1$ = -4					; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?amx_strtok2@@YAHPAUtagAMX@@PAH@Z PROC			; amx_strtok2, COMDAT

; 985  : {

  00000	83 ec 28	 sub	 esp, 40			; 00000028H
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi

; 986  : 	int left_pos = 0, right_pos = 0, len, pos = -1;
; 987  : 	unsigned int i = 0;
; 988  : 	size_t spaces;
; 989  : 
; 990  : 	char *string = get_amxstring(amx, params[1], 0, len);

  00006	8b 74 24 3c	 mov	 esi, DWORD PTR _params$[esp+48]
  0000a	8d 44 24 20	 lea	 eax, DWORD PTR _len$[esp+52]
  0000e	57		 push	 edi
  0000f	50		 push	 eax
  00010	33 ff		 xor	 edi, edi
  00012	c7 44 24 2c ff
	ff ff ff	 mov	 DWORD PTR _pos$1$[esp+60], -1
  0001a	57		 push	 edi
  0001b	ff 76 04	 push	 DWORD PTR [esi+4]
  0001e	33 ed		 xor	 ebp, ebp
  00020	33 db		 xor	 ebx, ebx
  00022	ff 74 24 48	 push	 DWORD PTR _amx$[esp+64]
  00026	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring

; 991  : 	char *left = new char[len + 1], *right = new char[len + 1];

  0002b	8b 74 24 34	 mov	 esi, DWORD PTR _len$[esp+72]
  0002f	46		 inc	 esi
  00030	89 44 24 24	 mov	 DWORD PTR _string$1$[esp+72], eax
  00034	56		 push	 esi
  00035	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0003a	56		 push	 esi
  0003b	89 44 24 38	 mov	 DWORD PTR _left$1$[esp+80], eax
  0003f	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00044	89 44 24 34	 mov	 DWORD PTR _right$1$[esp+80], eax
  00048	83 c4 18	 add	 esp, 24			; 00000018H

; 992  : 	int left_max = params[3], right_max = params[5];

  0004b	8b 44 24 40	 mov	 eax, DWORD PTR _params$[esp+52]
  0004f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]

; 993  : 	char token = static_cast<char>(params[6]);

  00052	8a 50 18	 mov	 dl, BYTE PTR [eax+24]
  00055	89 4c 24 30	 mov	 DWORD PTR _left_max$1$[esp+56], ecx
  00059	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]

; 994  : 	
; 995  : 	/*	Trim flags:
; 996  : 			1 - ltrim left
; 997  : 			2 - rtrim left
; 998  : 			4 - ltrim right
; 999  : 			8 - rtrim right
; 1000 : 	*/
; 1001 : 	int trim = params[7];

  0005c	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0005f	89 4c 24 34	 mov	 DWORD PTR _right_max$1$[esp+56], ecx
  00063	88 54 24 13	 mov	 BYTE PTR _token$1$[esp+56], dl
  00067	89 44 24 18	 mov	 DWORD PTR _trim$1$[esp+56], eax

; 1002 : 
; 1003 : 	// ltrim left
; 1004 : 	if (trim & 1 && (spaces = utf8getspaces(string)) > 0)

  0006b	a8 01		 test	 al, 1
  0006d	74 15		 je	 SHORT $LN12@amx_strtok
  0006f	ff 74 24 14	 push	 DWORD PTR _string$1$[esp+56]
  00073	e8 00 00 00 00	 call	 ?utf8getspaces@@YAIPBD@Z ; utf8getspaces
  00078	8a 54 24 17	 mov	 dl, BYTE PTR _token$1$[esp+60]
  0007c	83 c4 04	 add	 esp, 4
  0007f	85 c0		 test	 eax, eax
  00081	0f 45 f8	 cmovne	 edi, eax
$LN12@amx_strtok:

; 1005 : 	{
; 1006 : 		i += spaces;
; 1007 : 	}
; 1008 : 
; 1009 : 	for (; i < (unsigned int) len; ++i)

  00084	8b 74 24 24	 mov	 esi, DWORD PTR _len$[esp+56]
  00088	3b fe		 cmp	 edi, esi
  0008a	73 21		 jae	 SHORT $LN3@amx_strtok
  0008c	8b 4c 24 20	 mov	 ecx, DWORD PTR _left$1$[esp+56]
  00090	2b cf		 sub	 ecx, edi
$LL4@amx_strtok:

; 1010 : 	{
; 1011 : 		if (string[i] == token)

  00092	8b 44 24 14	 mov	 eax, DWORD PTR _string$1$[esp+56]
  00096	8a 04 38	 mov	 al, BYTE PTR [eax+edi]
  00099	3a c2		 cmp	 al, dl
  0009b	74 0b		 je	 SHORT $LN22@amx_strtok

; 1015 : 			break;
; 1016 : 		}
; 1017 : 
; 1018 : 		left[left_pos++] = string[i];

  0009d	88 04 39	 mov	 BYTE PTR [ecx+edi], al
  000a0	45		 inc	 ebp
  000a1	47		 inc	 edi
  000a2	3b fe		 cmp	 edi, esi
  000a4	72 ec		 jb	 SHORT $LL4@amx_strtok

; 1010 : 	{
; 1011 : 		if (string[i] == token)

  000a6	eb 05		 jmp	 SHORT $LN3@amx_strtok
$LN22@amx_strtok:

; 1012 : 		{
; 1013 : 			pos = i;

  000a8	89 7c 24 28	 mov	 DWORD PTR _pos$1$[esp+56], edi

; 1014 : 			++i;

  000ac	47		 inc	 edi
$LN3@amx_strtok:

; 1019 : 	}
; 1020 : 
; 1021 : 	// rtrim left
; 1022 : 	if (trim & 2 && left_pos && utf8isspace(&left[left_pos - 1]))

  000ad	8b 44 24 18	 mov	 eax, DWORD PTR _trim$1$[esp+56]
  000b1	a8 02		 test	 al, 2
  000b3	74 45		 je	 SHORT $LN14@amx_strtok
  000b5	85 ed		 test	 ebp, ebp
  000b7	74 41		 je	 SHORT $LN14@amx_strtok
  000b9	8b 44 24 20	 mov	 eax, DWORD PTR _left$1$[esp+56]
  000bd	48		 dec	 eax
  000be	03 c5		 add	 eax, ebp
  000c0	50		 push	 eax
  000c1	e8 00 00 00 00	 call	 ?utf8isspace@@YA_NPBD@Z	; utf8isspace
  000c6	83 c4 04	 add	 esp, 4
  000c9	84 c0		 test	 al, al
  000cb	74 29		 je	 SHORT $LN37@amx_strtok
  000cd	8b 74 24 20	 mov	 esi, DWORD PTR _left$1$[esp+56]
$LL5@amx_strtok:
  000d1	8b c5		 mov	 eax, ebp

; 1023 : 	{
; 1024 : 		while (--left_pos >= 0 && utf8isspace(&left[left_pos]));

  000d3	83 ed 01	 sub	 ebp, 1
  000d6	89 44 24 2c	 mov	 DWORD PTR tv411[esp+56], eax
  000da	78 14		 js	 SHORT $LN6@amx_strtok
  000dc	8d 04 2e	 lea	 eax, DWORD PTR [esi+ebp]
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 ?utf8isspace@@YA_NPBD@Z	; utf8isspace
  000e5	83 c4 04	 add	 esp, 4
  000e8	84 c0		 test	 al, al
  000ea	75 e5		 jne	 SHORT $LL5@amx_strtok
  000ec	8b 44 24 2c	 mov	 eax, DWORD PTR tv411[esp+56]
$LN6@amx_strtok:
  000f0	8b 74 24 24	 mov	 esi, DWORD PTR _len$[esp+56]

; 1025 : 		
; 1026 : 		++left_pos;

  000f4	8b e8		 mov	 ebp, eax
$LN37@amx_strtok:
  000f6	8b 44 24 18	 mov	 eax, DWORD PTR _trim$1$[esp+56]
$LN14@amx_strtok:

; 1027 : 	}
; 1028 : 
; 1029 : 	// ltrim right
; 1030 : 	if (trim & 4 && (spaces = utf8getspaces(string + i)) > 0)

  000fa	a8 04		 test	 al, 4
  000fc	74 15		 je	 SHORT $LN15@amx_strtok
  000fe	8b 44 24 14	 mov	 eax, DWORD PTR _string$1$[esp+56]
  00102	03 c7		 add	 eax, edi
  00104	50		 push	 eax
  00105	e8 00 00 00 00	 call	 ?utf8getspaces@@YAIPBD@Z ; utf8getspaces
  0010a	83 c4 04	 add	 esp, 4
  0010d	85 c0		 test	 eax, eax
  0010f	74 02		 je	 SHORT $LN15@amx_strtok

; 1031 : 	{
; 1032 : 		i += spaces;

  00111	03 f8		 add	 edi, eax
$LN15@amx_strtok:

; 1033 : 	}
; 1034 : 
; 1035 : 	for (; i < (unsigned int) len; ++i)

  00113	3b fe		 cmp	 edi, esi
  00115	73 28		 jae	 SHORT $LN8@amx_strtok
  00117	8b 4c 24 1c	 mov	 ecx, DWORD PTR _right$1$[esp+56]
  0011b	8b de		 mov	 ebx, esi
  0011d	2b cf		 sub	 ecx, edi
  0011f	2b df		 sub	 ebx, edi
  00121	89 5c 24 2c	 mov	 DWORD PTR _right_pos$1$[esp+56], ebx
  00125	8b 5c 24 14	 mov	 ebx, DWORD PTR _string$1$[esp+56]
  00129	0f 1f 80 00 00
	00 00		 npad	 7
$LL9@amx_strtok:

; 1036 : 	{
; 1037 : 		right[right_pos++] = string[i];	

  00130	8a 04 3b	 mov	 al, BYTE PTR [ebx+edi]
  00133	88 04 39	 mov	 BYTE PTR [ecx+edi], al
  00136	47		 inc	 edi
  00137	3b fe		 cmp	 edi, esi
  00139	72 f5		 jb	 SHORT $LL9@amx_strtok
  0013b	8b 5c 24 2c	 mov	 ebx, DWORD PTR _right_pos$1$[esp+56]
$LN8@amx_strtok:

; 1038 : 	}
; 1039 : 
; 1040 : 	// rtrim right
; 1041 : 	if (trim & 8 && right_pos && utf8isspace(&right[right_pos - 1]))

  0013f	f6 44 24 18 08	 test	 BYTE PTR _trim$1$[esp+56], 8
  00144	8b 7c 24 1c	 mov	 edi, DWORD PTR _right$1$[esp+56]
  00148	74 2f		 je	 SHORT $LN16@amx_strtok
  0014a	85 db		 test	 ebx, ebx
  0014c	74 2b		 je	 SHORT $LN16@amx_strtok
  0014e	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  00151	03 c3		 add	 eax, ebx
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 ?utf8isspace@@YA_NPBD@Z	; utf8isspace
  00159	83 c4 04	 add	 esp, 4
  0015c	84 c0		 test	 al, al
  0015e	74 19		 je	 SHORT $LN16@amx_strtok
$LL10@amx_strtok:
  00160	8b f3		 mov	 esi, ebx

; 1042 : 	{
; 1043 : 		while (--right_pos >= 0 && utf8isspace(&right[right_pos]));

  00162	83 eb 01	 sub	 ebx, 1
  00165	78 10		 js	 SHORT $LN11@amx_strtok
  00167	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
  0016a	50		 push	 eax
  0016b	e8 00 00 00 00	 call	 ?utf8isspace@@YA_NPBD@Z	; utf8isspace
  00170	83 c4 04	 add	 esp, 4
  00173	84 c0		 test	 al, al
  00175	75 e9		 jne	 SHORT $LL10@amx_strtok
$LN11@amx_strtok:

; 1044 : 
; 1045 : 		++right_pos;

  00177	8b de		 mov	 ebx, esi
$LN16@amx_strtok:

; 1046 : 	}
; 1047 : 
; 1048 : 	right[right_pos] = 0;

  00179	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 1049 : 	left[left_pos] = 0;

  0017d	8b 5c 24 20	 mov	 ebx, DWORD PTR _left$1$[esp+56]

; 1050 : 
; 1051 : 	set_amxstring_utf8(amx, params[2], left, strlen(left), left_max);

  00181	8b cb		 mov	 ecx, ebx
  00183	c6 04 2b 00	 mov	 BYTE PTR [ebx+ebp], 0
  00187	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0018a	66 0f 1f 44 00
	00		 npad	 6
$LL33@amx_strtok:
  00190	8a 01		 mov	 al, BYTE PTR [ecx]
  00192	41		 inc	 ecx
  00193	84 c0		 test	 al, al
  00195	75 f9		 jne	 SHORT $LL33@amx_strtok
  00197	ff 74 24 30	 push	 DWORD PTR _left_max$1$[esp+56]
  0019b	8b 74 24 44	 mov	 esi, DWORD PTR _params$[esp+56]
  0019f	2b ca		 sub	 ecx, edx
  001a1	8b 6c 24 40	 mov	 ebp, DWORD PTR _amx$[esp+56]
  001a5	51		 push	 ecx
  001a6	53		 push	 ebx
  001a7	ff 76 08	 push	 DWORD PTR [esi+8]
  001aa	55		 push	 ebp
  001ab	e8 00 00 00 00	 call	 ??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z ; set_amxstring_utf8<char>

; 1052 : 	set_amxstring_utf8(amx, params[4], right, strlen(right), right_max);

  001b0	8b cf		 mov	 ecx, edi
  001b2	83 c4 14	 add	 esp, 20			; 00000014H
  001b5	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL34@amx_strtok:
  001b8	8a 01		 mov	 al, BYTE PTR [ecx]
  001ba	41		 inc	 ecx
  001bb	84 c0		 test	 al, al
  001bd	75 f9		 jne	 SHORT $LL34@amx_strtok
  001bf	ff 74 24 34	 push	 DWORD PTR _right_max$1$[esp+56]
  001c3	2b ca		 sub	 ecx, edx
  001c5	51		 push	 ecx
  001c6	57		 push	 edi
  001c7	ff 76 10	 push	 DWORD PTR [esi+16]
  001ca	55		 push	 ebp
  001cb	e8 00 00 00 00	 call	 ??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z ; set_amxstring_utf8<char>

; 1053 : 
; 1054 : 	delete [] left;

  001d0	53		 push	 ebx
  001d1	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 1055 : 	delete [] right;

  001d6	57		 push	 edi
  001d7	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 1056 : 
; 1057 : 	return pos;

  001dc	8b 44 24 44	 mov	 eax, DWORD PTR _pos$1$[esp+84]
  001e0	83 c4 1c	 add	 esp, 28			; 0000001cH
  001e3	5f		 pop	 edi
  001e4	5e		 pop	 esi
  001e5	5d		 pop	 ebp
  001e6	5b		 pop	 ebx

; 1058 : }

  001e7	83 c4 28	 add	 esp, 40			; 00000028H
  001ea	c3		 ret	 0
?amx_strtok2@@YAHPAUtagAMX@@PAH@Z ENDP			; amx_strtok2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?amx_strtok@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_len$ = -28						; size = 4
_string$1$ = -24					; size = 4
_right$1$ = -20						; size = 4
_left$1$ = -16						; size = 4
_trim$1$ = -12						; size = 4
_leftMax$1$ = -8					; size = 4
_rightMax$1$ = -4					; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?amx_strtok@@YAHPAUtagAMX@@PAH@Z PROC			; amx_strtok, COMDAT

; 927  : {

  00000	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	57		 push	 edi

; 928  : 	int left_pos = 0;
; 929  : 	int right_pos = 0;
; 930  : 	unsigned int i = 0;
; 931  : 	bool done_flag = false;
; 932  : 	size_t spaces;
; 933  : 	int len = 0;
; 934  : 
; 935  : 	//string[]
; 936  : 	char *string = get_amxstring(amx, params[1], 0, len);

  00007	8d 44 24 10	 lea	 eax, DWORD PTR _len$[esp+44]
  0000b	33 ed		 xor	 ebp, ebp
  0000d	50		 push	 eax
  0000e	8b 44 24 38	 mov	 eax, DWORD PTR _params$[esp+44]
  00012	33 ff		 xor	 edi, edi
  00014	55		 push	 ebp
  00015	32 db		 xor	 bl, bl
  00017	89 7c 24 18	 mov	 DWORD PTR _len$[esp+52], edi
  0001b	ff 70 04	 push	 DWORD PTR [eax+4]
  0001e	ff 74 24 3c	 push	 DWORD PTR _amx$[esp+52]
  00022	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring

; 937  : 	//left[]
; 938  : 	char *left = new char[len + 1];

  00027	8b 74 24 20	 mov	 esi, DWORD PTR _len$[esp+60]
  0002b	46		 inc	 esi
  0002c	89 44 24 24	 mov	 DWORD PTR _string$1$[esp+60], eax
  00030	56		 push	 esi
  00031	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 939  : 	//right[]
; 940  : 	char *right = new char[len + 1];

  00036	56		 push	 esi
  00037	89 44 24 34	 mov	 DWORD PTR _left$1$[esp+68], eax
  0003b	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00040	89 44 24 30	 mov	 DWORD PTR _right$1$[esp+68], eax

; 941  : 	int leftMax = params[3];
; 942  : 	int rightMax = params[5];
; 943  : 	//token
; 944  : 	char token = static_cast<char>(params[6]);
; 945  : 	//trim
; 946  : 	int trim = params[7];
; 947  : 	
; 948  : 	for (i = 0; i < (unsigned int)len; i++)

  00044	33 f6		 xor	 esi, esi
  00046	8b 44 24 4c	 mov	 eax, DWORD PTR _params$[esp+64]
  0004a	83 c4 18	 add	 esp, 24			; 00000018H
  0004d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00050	8a 78 18	 mov	 bh, BYTE PTR [eax+24]
  00053	89 4c 24 24	 mov	 DWORD PTR _leftMax$1$[esp+44], ecx
  00057	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0005a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0005d	89 4c 24 28	 mov	 DWORD PTR _rightMax$1$[esp+44], ecx
  00061	89 44 24 20	 mov	 DWORD PTR _trim$1$[esp+44], eax
  00065	39 74 24 10	 cmp	 DWORD PTR _len$[esp+44], esi
  00069	76 4c		 jbe	 SHORT $LN3@amx_strtok
  0006b	0f 1f 44 00 00	 npad	 5
$LL4@amx_strtok:

; 949  : 	{
; 950  : 		if (trim && !done_flag)

  00070	85 c0		 test	 eax, eax
  00072	0f 84 b4 00 00
	00		 je	 $LN6@amx_strtok
  00078	84 db		 test	 bl, bl
  0007a	75 21		 jne	 SHORT $LN15@amx_strtok

; 951  : 		{
; 952  : 			if ((spaces = utf8getspaces(string + i) > 0))

  0007c	8b 44 24 14	 mov	 eax, DWORD PTR _string$1$[esp+44]
  00080	03 c6		 add	 eax, esi
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 ?utf8getspaces@@YAIPBD@Z ; utf8getspaces
  00088	33 c9		 xor	 ecx, ecx
  0008a	83 c4 04	 add	 esp, 4
  0008d	3b c8		 cmp	 ecx, eax
  0008f	1b c0		 sbb	 eax, eax
  00091	f7 d8		 neg	 eax
  00093	0f 84 9b 00 00
	00		 je	 $LN16@amx_strtok

; 953  : 			{
; 954  : 				i += spaces;

  00099	03 f0		 add	 esi, eax

; 955  : 				done_flag = true;

  0009b	b3 01		 mov	 bl, 1
$LN15@amx_strtok:

; 963  : 		}
; 964  : 
; 965  : 		if (done_flag)
; 966  : 		{
; 967  : 			right[right_pos++] = string[i];

  0009d	8b 44 24 14	 mov	 eax, DWORD PTR _string$1$[esp+44]
  000a1	8b 4c 24 18	 mov	 ecx, DWORD PTR _right$1$[esp+44]
  000a5	8a 04 30	 mov	 al, BYTE PTR [eax+esi]
  000a8	88 04 29	 mov	 BYTE PTR [ecx+ebp], al
  000ab	45		 inc	 ebp
$LN2@amx_strtok:

; 941  : 	int leftMax = params[3];
; 942  : 	int rightMax = params[5];
; 943  : 	//token
; 944  : 	char token = static_cast<char>(params[6]);
; 945  : 	//trim
; 946  : 	int trim = params[7];
; 947  : 	
; 948  : 	for (i = 0; i < (unsigned int)len; i++)

  000ac	8b 44 24 20	 mov	 eax, DWORD PTR _trim$1$[esp+44]
  000b0	46		 inc	 esi
  000b1	3b 74 24 10	 cmp	 esi, DWORD PTR _len$[esp+44]
  000b5	72 b9		 jb	 SHORT $LL4@amx_strtok
$LN3@amx_strtok:

; 970  : 		}
; 971  : 	}
; 972  : 
; 973  : 	right[right_pos] = 0;
; 974  : 	left[left_pos] = 0;

  000b7	8b 74 24 1c	 mov	 esi, DWORD PTR _left$1$[esp+44]

; 975  : 	set_amxstring_utf8(amx, params[2], left, strlen(left), leftMax);

  000bb	8b ce		 mov	 ecx, esi
  000bd	8b 5c 24 18	 mov	 ebx, DWORD PTR _right$1$[esp+44]
  000c1	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  000c4	c6 04 2b 00	 mov	 BYTE PTR [ebx+ebp], 0
  000c8	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0
  000cc	0f 1f 40 00	 npad	 4
$LL17@amx_strtok:
  000d0	8a 01		 mov	 al, BYTE PTR [ecx]
  000d2	41		 inc	 ecx
  000d3	84 c0		 test	 al, al
  000d5	75 f9		 jne	 SHORT $LL17@amx_strtok
  000d7	ff 74 24 24	 push	 DWORD PTR _leftMax$1$[esp+44]
  000db	8b 6c 24 38	 mov	 ebp, DWORD PTR _params$[esp+44]
  000df	2b ca		 sub	 ecx, edx
  000e1	8b 7c 24 34	 mov	 edi, DWORD PTR _amx$[esp+44]
  000e5	51		 push	 ecx
  000e6	56		 push	 esi
  000e7	ff 75 08	 push	 DWORD PTR [ebp+8]
  000ea	57		 push	 edi
  000eb	e8 00 00 00 00	 call	 ??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z ; set_amxstring_utf8<char>

; 976  : 	set_amxstring_utf8(amx, params[4], right, strlen(right), rightMax);

  000f0	8b cb		 mov	 ecx, ebx
  000f2	83 c4 14	 add	 esp, 20			; 00000014H
  000f5	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL18@amx_strtok:
  000f8	8a 01		 mov	 al, BYTE PTR [ecx]
  000fa	41		 inc	 ecx
  000fb	84 c0		 test	 al, al
  000fd	75 f9		 jne	 SHORT $LL18@amx_strtok
  000ff	ff 74 24 28	 push	 DWORD PTR _rightMax$1$[esp+44]
  00103	2b ca		 sub	 ecx, edx
  00105	51		 push	 ecx
  00106	53		 push	 ebx
  00107	ff 75 10	 push	 DWORD PTR [ebp+16]
  0010a	57		 push	 edi
  0010b	e8 00 00 00 00	 call	 ??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z ; set_amxstring_utf8<char>

; 977  : 	delete [] left;

  00110	56		 push	 esi
  00111	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 978  : 	delete [] right;

  00116	53		 push	 ebx
  00117	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0011c	83 c4 1c	 add	 esp, 28			; 0000001cH

; 979  : 	
; 980  : 	return 1;

  0011f	b8 01 00 00 00	 mov	 eax, 1
  00124	5f		 pop	 edi
  00125	5e		 pop	 esi
  00126	5d		 pop	 ebp
  00127	5b		 pop	 ebx

; 981  : }

  00128	83 c4 1c	 add	 esp, 28			; 0000001cH
  0012b	c3		 ret	 0
$LN6@amx_strtok:

; 956  : 			}
; 957  : 		}
; 958  : 
; 959  : 		if (!done_flag && string[i] == token)

  0012c	84 db		 test	 bl, bl
  0012e	0f 85 69 ff ff
	ff		 jne	 $LN15@amx_strtok
$LN16@amx_strtok:
  00134	8b 44 24 14	 mov	 eax, DWORD PTR _string$1$[esp+44]
  00138	8a 04 30	 mov	 al, BYTE PTR [eax+esi]
  0013b	3a c7		 cmp	 al, bh
  0013d	75 08		 jne	 SHORT $LN8@amx_strtok

; 960  : 		{
; 961  : 			done_flag = true;

  0013f	b3 01		 mov	 bl, 1

; 962  : 			i++;

  00141	46		 inc	 esi
  00142	e9 56 ff ff ff	 jmp	 $LN15@amx_strtok
$LN8@amx_strtok:

; 968  : 		} else {
; 969  : 			left[left_pos++] = string[i];

  00147	8b 4c 24 1c	 mov	 ecx, DWORD PTR _left$1$[esp+44]
  0014b	88 04 39	 mov	 BYTE PTR [ecx+edi], al
  0014e	47		 inc	 edi
  0014f	e9 58 ff ff ff	 jmp	 $LN2@amx_strtok
?amx_strtok@@YAHPAUtagAMX@@PAH@Z ENDP			; amx_strtok
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?format_arguments@@YAPADPAUtagAMX@@HAAH@Z
_TEXT	SEGMENT
_numparam$1$ = -4					; size = 4
_amx$ = 8						; size = 4
_parm$ = 12						; size = 4
_len$ = 16						; size = 4
?format_arguments@@YAPADPAUtagAMX@@HAAH@Z PROC		; format_arguments, COMDAT

; 878  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 c0	 and	 esp, -64		; ffffffc0H
  00006	83 ec 34	 sub	 esp, 52			; 00000034H
  00009	53		 push	 ebx

; 879  : 	static char buffer[2][3072];
; 880  : 	static char format[16];
; 881  : 	char *ptr, *arg, *dest = *buffer;
; 882  : 	char *src = fo_getargstr(amx, 0, parm++);

  0000a	8b 5d 0c	 mov	 ebx, DWORD PTR _parm$[ebp]
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	53		 push	 ebx
  00010	6a 00		 push	 0
  00012	ff 75 08	 push	 DWORD PTR _amx$[ebp]
  00015	be 00 00 00 00	 mov	 esi, OFFSET ?buffer@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PAY0MAA@DA
  0001a	e8 00 00 00 00	 call	 ?fo_getargstr@@YAPADPAUtagAMX@@HH@Z ; fo_getargstr

; 883  : 	int numparam = fo_numargs(amx);

  0001f	ff 75 08	 push	 DWORD PTR _amx$[ebp]
  00022	43		 inc	 ebx
  00023	8b f8		 mov	 edi, eax
  00025	89 5d 0c	 mov	 DWORD PTR _parm$[ebp], ebx
  00028	e8 00 00 00 00	 call	 ?fo_numargs@@YAHPAUtagAMX@@@Z ; fo_numargs

; 884  : 
; 885  : 	while (*src)

  0002d	8a 0f		 mov	 cl, BYTE PTR [edi]
  0002f	83 c4 10	 add	 esp, 16			; 00000010H
  00032	89 44 24 3c	 mov	 DWORD PTR _numparam$1$[esp+64], eax
  00036	84 c9		 test	 cl, cl
  00038	0f 84 f5 00 00
	00		 je	 $LN3@format_arg
  0003e	66 90		 npad	 2
$LL2@format_arg:

; 886  : 	{
; 887  : 		if (*src == '%' && *(src + 1))

  00040	80 f9 25	 cmp	 cl, 37			; 00000025H
  00043	0f 85 dc 00 00
	00		 jne	 $LN10@format_arg
  00049	80 7f 01 00	 cmp	 BYTE PTR [edi+1], 0
  0004d	0f 84 d2 00 00
	00		 je	 $LN10@format_arg

; 888  : 		{
; 889  : 			ptr = format;
; 890  : 			*ptr++ = *src++;

  00053	47		 inc	 edi
  00054	88 0d 00 00 00
	00		 mov	 BYTE PTR ?format@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PADA, cl
  0005a	bb 01 00 00 00	 mov	 ebx, OFFSET ?format@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PADA+1

; 891  : 			
; 892  : 			if (*src == '%')

  0005f	38 0f		 cmp	 BYTE PTR [edi], cl
  00061	75 0d		 jne	 SHORT $LL4@format_arg

; 893  : 			{
; 894  : 				*dest++ = *src++;

  00063	88 0e		 mov	 BYTE PTR [esi], cl

; 895  : 				continue;

  00065	e9 bd 00 00 00	 jmp	 $LN45@format_arg
  0006a	66 0f 1f 44 00
	00		 npad	 6
$LL4@format_arg:

; 896  : 			}
; 897  : 			
; 898  : 			while (!isalpha(*ptr++ = *src++));

  00070	8a 07		 mov	 al, BYTE PTR [edi]
  00072	88 03		 mov	 BYTE PTR [ebx], al
  00074	0f be c0	 movsx	 eax, al
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 _isalpha
  0007d	83 c4 04	 add	 esp, 4
  00080	8d 5b 01	 lea	 ebx, DWORD PTR [ebx+1]
  00083	47		 inc	 edi
  00084	85 c0		 test	 eax, eax
  00086	74 e8		 je	 SHORT $LL4@format_arg

; 899  : 			
; 900  : 			*ptr='\0';
; 901  : 			if (numparam < parm) continue;

  00088	8b 55 0c	 mov	 edx, DWORD PTR _parm$[ebp]
  0008b	c6 03 00	 mov	 BYTE PTR [ebx], 0
  0008e	39 54 24 3c	 cmp	 DWORD PTR _numparam$1$[esp+64], edx
  00092	0f 8c 91 00 00
	00		 jl	 $LN24@format_arg

; 902  : 			arg = buffer[1];
; 903  : 			
; 904  : 			switch (*(ptr - 1))

  00098	8a 43 ff	 mov	 al, BYTE PTR [ebx-1]
  0009b	3c 66		 cmp	 al, 102			; 00000066H
  0009d	7c 48		 jl	 SHORT $LN15@format_arg
  0009f	3c 67		 cmp	 al, 103			; 00000067H
  000a1	7e 24		 jle	 SHORT $LN14@format_arg
  000a3	3c 73		 cmp	 al, 115			; 00000073H
  000a5	75 40		 jne	 SHORT $LN15@format_arg

; 905  : 			{
; 906  : 				case 's': sprintf(arg, format, fo_getargstr(amx, 1, parm++)); break;

  000a7	52		 push	 edx
  000a8	6a 01		 push	 1
  000aa	ff 75 08	 push	 DWORD PTR _amx$[ebp]
  000ad	e8 00 00 00 00	 call	 ?fo_getargstr@@YAPADPAUtagAMX@@HH@Z ; fo_getargstr
  000b2	50		 push	 eax
  000b3	68 00 00 00 00	 push	 OFFSET ?format@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PADA
  000b8	68 00 0c 00 00	 push	 OFFSET ?buffer@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PAY0MAA@DA+3072
  000bd	e8 00 00 00 00	 call	 _sprintf
  000c2	83 c4 18	 add	 esp, 24			; 00000018H
  000c5	eb 3c		 jmp	 SHORT $LN22@format_arg
$LN14@format_arg:

; 907  : 				case 'f': case 'g': sprintf(arg, format, fo_getargfloat(amx, parm++)); break;

  000c7	52		 push	 edx
  000c8	ff 75 08	 push	 DWORD PTR _amx$[ebp]
  000cb	e8 00 00 00 00	 call	 ?fo_getargfloat@@YAMPAUtagAMX@@H@Z ; fo_getargfloat
  000d0	dd 1c 24	 fstp	 QWORD PTR [esp]
  000d3	68 00 00 00 00	 push	 OFFSET ?format@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PADA
  000d8	68 00 0c 00 00	 push	 OFFSET ?buffer@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PAY0MAA@DA+3072
  000dd	e8 00 00 00 00	 call	 _sprintf
  000e2	83 c4 10	 add	 esp, 16			; 00000010H
  000e5	eb 1c		 jmp	 SHORT $LN22@format_arg
$LN15@format_arg:

; 908  : 				default: sprintf(arg, format, fo_getargnum(amx, parm++));

  000e7	52		 push	 edx
  000e8	ff 75 08	 push	 DWORD PTR _amx$[ebp]
  000eb	e8 00 00 00 00	 call	 ?fo_getargnum@@YAHPAUtagAMX@@H@Z ; fo_getargnum
  000f0	50		 push	 eax
  000f1	68 00 00 00 00	 push	 OFFSET ?format@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PADA
  000f6	68 00 0c 00 00	 push	 OFFSET ?buffer@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PAY0MAA@DA+3072
  000fb	e8 00 00 00 00	 call	 _sprintf
  00100	83 c4 14	 add	 esp, 20			; 00000014H
$LN22@format_arg:

; 909  : 			}
; 910  : 			
; 911  : 			while (*arg) *dest++ = *arg++;

  00103	8a 0d 00 0c 00
	00		 mov	 cl, BYTE PTR ?buffer@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PAY0MAA@DA+3072
  00109	ff 45 0c	 inc	 DWORD PTR _parm$[ebp]
  0010c	84 c9		 test	 cl, cl
  0010e	74 19		 je	 SHORT $LN24@format_arg
  00110	ba 00 0c 00 00	 mov	 edx, OFFSET ?buffer@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PAY0MAA@DA+3072
  00115	2b d6		 sub	 edx, esi
$LL8@format_arg:
  00117	88 0e		 mov	 BYTE PTR [esi], cl
  00119	46		 inc	 esi
  0011a	8a 04 32	 mov	 al, BYTE PTR [edx+esi]
  0011d	8a c8		 mov	 cl, al
  0011f	84 c0		 test	 al, al
  00121	75 f4		 jne	 SHORT $LL8@format_arg

; 912  : 			continue;

  00123	eb 04		 jmp	 SHORT $LN24@format_arg
$LN10@format_arg:

; 913  : 		}
; 914  : 		*dest++ = *src++;

  00125	88 0e		 mov	 BYTE PTR [esi], cl
$LN45@format_arg:
  00127	46		 inc	 esi
  00128	47		 inc	 edi
$LN24@format_arg:

; 884  : 
; 885  : 	while (*src)

  00129	8a 0f		 mov	 cl, BYTE PTR [edi]
  0012b	84 c9		 test	 cl, cl
  0012d	0f 85 0d ff ff
	ff		 jne	 $LL2@format_arg
$LN3@format_arg:

; 915  : 	}
; 916  : 
; 917  : 	*dest = '\0';
; 918  : 	len = dest - *buffer;

  00133	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  00136	c6 06 00	 mov	 BYTE PTR [esi], 0
  00139	81 ee 00 00 00
	00		 sub	 esi, OFFSET ?buffer@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PAY0MAA@DA

; 919  : 	
; 920  : 	return *buffer;
; 921  : }

  0013f	5f		 pop	 edi
  00140	89 30		 mov	 DWORD PTR [eax], esi
  00142	b8 00 00 00 00	 mov	 eax, OFFSET ?buffer@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PAY0MAA@DA
  00147	5e		 pop	 esi
  00148	5b		 pop	 ebx
  00149	8b e5		 mov	 esp, ebp
  0014b	5d		 pop	 ebp
  0014c	c3		 ret	 0
?format_arguments@@YAPADPAUtagAMX@@HAAH@Z ENDP		; format_arguments
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?fo_getargstr@@YAPADPAUtagAMX@@HH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_swap$ = 12						; size = 4
_pos$ = 16						; size = 4
?fo_getargstr@@YAPADPAUtagAMX@@HH@Z PROC		; fo_getargstr, COMDAT

; 860  : 	unsigned char *data = amx->base + (int)((AMX_HEADER *)amx->base)->dat;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _amx$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 861  : 	cell src_value= *(cell *)(data + (int)amx->frm + (pos + 3) * sizeof(cell));

  00008	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0000b	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  0000e	03 f8		 add	 edi, eax
  00010	8b 44 24 14	 mov	 eax, DWORD PTR _pos$[esp+4]
  00014	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00017	8b 74 38 0c	 mov	 esi, DWORD PTR [eax+edi+12]

; 862  : 	cell value;
; 863  : 	static char buffer[2][3072];
; 864  : 	char* b = buffer[swap];

  0001b	69 44 24 10 00
	0c 00 00	 imul	 eax, DWORD PTR _swap$[esp+4], 3072
  00023	8d 80 00 00 00
	00		 lea	 eax, DWORD PTR ?buffer@?1??fo_getargstr@@YAPADPAUtagAMX@@HH@Z@4PAY0MAA@DA[eax]
  00029	8b c8		 mov	 ecx, eax
  0002b	0f 1f 44 00 00	 npad	 5
$LL4@fo_getargs:

; 865  : 	int a = 0;
; 866  : 	
; 867  : 	do
; 868  : 	{
; 869  : 		value = src_value + a++ * sizeof(cell);
; 870  : 		value = *(cell *)(data + (int)value);

  00030	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  00033	8d 76 04	 lea	 esi, DWORD PTR [esi+4]

; 871  : 		*b++ = static_cast<char>(value);

  00036	88 11		 mov	 BYTE PTR [ecx], dl
  00038	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]

; 872  : 	} while (value);

  0003b	85 d2		 test	 edx, edx
  0003d	75 f1		 jne	 SHORT $LL4@fo_getargs

; 873  : 
; 874  : 	return buffer[swap];
; 875  : }

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	c3		 ret	 0
?fo_getargstr@@YAPADPAUtagAMX@@HH@Z ENDP		; fo_getargstr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?fo_getargfloat@@YAMPAUtagAMX@@H@Z
_TEXT	SEGMENT
_number$ = 8						; size = 4
_amx$ = 8						; size = 4
_pos$ = 12						; size = 4
?fo_getargfloat@@YAMPAUtagAMX@@H@Z PROC			; fo_getargfloat, COMDAT

; 851  : 	unsigned char *data = amx->base + (int)((AMX_HEADER *)amx->base)->dat;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _amx$[esp-4]
  00004	8b 01		 mov	 eax, DWORD PTR [ecx]

; 852  : 	cell value = *(cell *)(data + (int)amx->frm + (pos + 3) * sizeof(cell));

  00006	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00009	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0000c	03 d0		 add	 edx, eax
  0000e	8b 44 24 08	 mov	 eax, DWORD PTR _pos$[esp-4]
  00012	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 853  : 	cell number = *(cell *)(data + (int)value);

  00015	8b 44 10 0c	 mov	 eax, DWORD PTR [eax+edx+12]
  00019	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0001c	89 44 24 04	 mov	 DWORD PTR _number$[esp-4], eax

; 854  : 	
; 855  : 	return *(REAL *)((void *)&number);

  00020	d9 44 24 04	 fld	 DWORD PTR _number$[esp-4]

; 856  : }

  00024	c3		 ret	 0
?fo_getargfloat@@YAMPAUtagAMX@@H@Z ENDP			; fo_getargfloat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?fo_getargnum@@YAHPAUtagAMX@@H@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_pos$ = 12						; size = 4
?fo_getargnum@@YAHPAUtagAMX@@H@Z PROC			; fo_getargnum, COMDAT

; 843  : 	unsigned char *data = amx->base + (int)((AMX_HEADER *)amx->base)->dat;

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _amx$[esp-4]
  00004	56		 push	 esi
  00005	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 844  : 	cell value = *(cell *)(data + (int)amx->frm + (pos + 3) * sizeof(cell));

  00007	8b 52 14	 mov	 edx, DWORD PTR [edx+20]
  0000a	8b 71 10	 mov	 esi, DWORD PTR [ecx+16]
  0000d	03 f1		 add	 esi, ecx
  0000f	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pos$[esp]
  00013	8d 0c 8a	 lea	 ecx, DWORD PTR [edx+ecx*4]

; 845  : 	
; 846  : 	return *(cell *)(data + (int)value);

  00016	8b 44 31 0c	 mov	 eax, DWORD PTR [ecx+esi+12]
  0001a	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  0001d	5e		 pop	 esi

; 847  : }

  0001e	c3		 ret	 0
?fo_getargnum@@YAHPAUtagAMX@@H@Z ENDP			; fo_getargnum
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?fo_numargs@@YAHPAUtagAMX@@@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
?fo_numargs@@YAHPAUtagAMX@@@Z PROC			; fo_numargs, COMDAT

; 835  : 	unsigned char *data = amx->base + (int)((AMX_HEADER *)amx->base)->dat;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _amx$[esp-4]
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]

; 836  : 	cell bytes= *(cell *)(data + (int)amx->frm + 2 * sizeof(cell));

  00006	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00009	03 41 14	 add	 eax, DWORD PTR [ecx+20]

; 837  : 	
; 838  : 	return (int)(bytes / sizeof(cell));

  0000c	8b 44 10 08	 mov	 eax, DWORD PTR [eax+edx+8]
  00010	c1 e8 02	 shr	 eax, 2

; 839  : }

  00013	c3		 ret	 0
?fo_numargs@@YAHPAUtagAMX@@@Z ENDP			; fo_numargs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?mb_strtoupper@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_sourceLength$ = -4					; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?mb_strtoupper@@YAHPAUtagAMX@@PAH@Z PROC		; mb_strtoupper, COMDAT

; 812  : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp

; 813  : 	enum args { arg_count, arg_string, arg_maxlength };
; 814  : 
; 815  : 	auto sourceLength = 0;
; 816  : 	auto source = get_amxstring(amx, params[arg_string], 0, sourceLength);

  00003	8b 6c 24 14	 mov	 ebp, DWORD PTR _params$[esp+8]
  00007	8d 44 24 08	 lea	 eax, DWORD PTR _sourceLength$[esp+12]
  0000b	57		 push	 edi
  0000c	50		 push	 eax
  0000d	6a 00		 push	 0
  0000f	ff 75 04	 push	 DWORD PTR [ebp+4]
  00012	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _sourceLength$[esp+28], 0
  0001a	ff 74 24 20	 push	 DWORD PTR _amx$[esp+24]
  0001e	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring

; 817  : 	
; 818  : 	auto outputMaxLength = params[arg_maxlength];

  00023	8b 6d 08	 mov	 ebp, DWORD PTR [ebp+8]
  00026	8b d8		 mov	 ebx, eax

; 819  : 
; 820  : 	if (outputMaxLength <= 0)

  00028	85 ed		 test	 ebp, ebp

; 821  : 	{
; 822  : 		outputMaxLength = sourceLength;
; 823  : 	}
; 824  : 
; 825  : 	auto output = get_amxbuffer(1);

  0002a	6a 01		 push	 1
  0002c	0f 4e 6c 24 20	 cmovle	 ebp, DWORD PTR _sourceLength$[esp+36]
  00031	e8 00 00 00 00	 call	 ?get_amxbuffer@@YAPADH@Z ; get_amxbuffer

; 826  : 	auto outputLength = utf8toupper(source, sourceLength, output, MAX_BUFFER_LENGTH - 1, UTF8_LOCALE_DEFAULT, nullptr, TRUE);

  00036	6a 01		 push	 1
  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	68 ff 3f 00 00	 push	 16383			; 00003fffH
  00041	8b f8		 mov	 edi, eax
  00043	57		 push	 edi
  00044	ff 74 24 34	 push	 DWORD PTR _sourceLength$[esp+56]
  00048	53		 push	 ebx
  00049	e8 00 00 00 00	 call	 _utf8toupper

; 827  : 
; 828  : 	output[outputLength] = '\0';
; 829  : 
; 830  : 	return set_amxstring_utf8(amx, params[arg_string], output, outputLength, outputMaxLength);

  0004e	55		 push	 ebp
  0004f	50		 push	 eax
  00050	57		 push	 edi
  00051	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  00055	8b 44 24 54	 mov	 eax, DWORD PTR _params$[esp+72]
  00059	ff 70 04	 push	 DWORD PTR [eax+4]
  0005c	ff 74 24 54	 push	 DWORD PTR _amx$[esp+76]
  00060	e8 00 00 00 00	 call	 ??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z ; set_amxstring_utf8<char>
  00065	83 c4 44	 add	 esp, 68			; 00000044H
  00068	5f		 pop	 edi
  00069	5d		 pop	 ebp
  0006a	5b		 pop	 ebx

; 831  : }

  0006b	59		 pop	 ecx
  0006c	c3		 ret	 0
?mb_strtoupper@@YAHPAUtagAMX@@PAH@Z ENDP		; mb_strtoupper
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?strtoupper@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?strtoupper@@YAHPAUtagAMX@@PAH@Z PROC			; strtoupper, COMDAT

; 798  : 	cell *cptr = get_amxaddr(amx, params[1]);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _params$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	ff 70 04	 push	 DWORD PTR [eax+4]
  00009	ff 74 24 10	 push	 DWORD PTR _amx$[esp+8]
  0000d	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr
  00012	8b f0		 mov	 esi, eax
  00014	83 c4 08	 add	 esp, 8

; 799  : 	cell *begin = cptr;

  00017	8b fe		 mov	 edi, esi

; 800  : 	
; 801  : 	while (*cptr)

  00019	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0001c	74 16		 je	 SHORT $LN3@strtoupper
  0001e	66 90		 npad	 2
$LL2@strtoupper:

; 802  : 	{
; 803  : 		*cptr = toupper(*cptr);

  00020	ff 36		 push	 DWORD PTR [esi]
  00022	e8 00 00 00 00	 call	 _toupper
  00027	89 06		 mov	 DWORD PTR [esi], eax
  00029	83 c4 04	 add	 esp, 4

; 804  : 		cptr++;

  0002c	83 c6 04	 add	 esi, 4
  0002f	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00032	75 ec		 jne	 SHORT $LL2@strtoupper
$LN3@strtoupper:

; 805  : 	}
; 806  : 	
; 807  : 	return cptr - begin;

  00034	2b f7		 sub	 esi, edi
  00036	c1 fe 02	 sar	 esi, 2
  00039	5f		 pop	 edi
  0003a	8b c6		 mov	 eax, esi
  0003c	5e		 pop	 esi

; 808  : }

  0003d	c3		 ret	 0
?strtoupper@@YAHPAUtagAMX@@PAH@Z ENDP			; strtoupper
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?mb_strtolower@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_sourceLength$ = -4					; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?mb_strtolower@@YAHPAUtagAMX@@PAH@Z PROC		; mb_strtolower, COMDAT

; 775  : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp

; 776  : 	enum args { arg_count, arg_string, arg_maxlength };
; 777  : 
; 778  : 	auto sourceLength = 0;
; 779  : 	auto source = get_amxstring(amx, params[arg_string], 0, sourceLength);

  00003	8b 6c 24 14	 mov	 ebp, DWORD PTR _params$[esp+8]
  00007	8d 44 24 08	 lea	 eax, DWORD PTR _sourceLength$[esp+12]
  0000b	57		 push	 edi
  0000c	50		 push	 eax
  0000d	6a 00		 push	 0
  0000f	ff 75 04	 push	 DWORD PTR [ebp+4]
  00012	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _sourceLength$[esp+28], 0
  0001a	ff 74 24 20	 push	 DWORD PTR _amx$[esp+24]
  0001e	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring

; 780  : 
; 781  : 	auto outputMaxLength = params[arg_maxlength];

  00023	8b 6d 08	 mov	 ebp, DWORD PTR [ebp+8]
  00026	8b d8		 mov	 ebx, eax

; 782  : 
; 783  : 	if (outputMaxLength <= 0)

  00028	85 ed		 test	 ebp, ebp

; 784  : 	{
; 785  : 		outputMaxLength = sourceLength;
; 786  : 	}
; 787  : 
; 788  : 	auto output = get_amxbuffer(1);

  0002a	6a 01		 push	 1
  0002c	0f 4e 6c 24 20	 cmovle	 ebp, DWORD PTR _sourceLength$[esp+36]
  00031	e8 00 00 00 00	 call	 ?get_amxbuffer@@YAPADH@Z ; get_amxbuffer

; 789  : 	auto outputLength = utf8tolower(source, sourceLength, output, MAX_BUFFER_LENGTH - 1, UTF8_LOCALE_DEFAULT, nullptr, TRUE);

  00036	6a 01		 push	 1
  00038	6a 00		 push	 0
  0003a	6a 00		 push	 0
  0003c	68 ff 3f 00 00	 push	 16383			; 00003fffH
  00041	8b f8		 mov	 edi, eax
  00043	57		 push	 edi
  00044	ff 74 24 34	 push	 DWORD PTR _sourceLength$[esp+56]
  00048	53		 push	 ebx
  00049	e8 00 00 00 00	 call	 _utf8tolower

; 790  : 	
; 791  : 	output[outputLength] = '\0';
; 792  : 
; 793  : 	return set_amxstring_utf8(amx, params[arg_string], output, outputLength, outputMaxLength);

  0004e	55		 push	 ebp
  0004f	50		 push	 eax
  00050	57		 push	 edi
  00051	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  00055	8b 44 24 54	 mov	 eax, DWORD PTR _params$[esp+72]
  00059	ff 70 04	 push	 DWORD PTR [eax+4]
  0005c	ff 74 24 54	 push	 DWORD PTR _amx$[esp+76]
  00060	e8 00 00 00 00	 call	 ??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z ; set_amxstring_utf8<char>
  00065	83 c4 44	 add	 esp, 68			; 00000044H
  00068	5f		 pop	 edi
  00069	5d		 pop	 ebp
  0006a	5b		 pop	 ebx

; 794  : }

  0006b	59		 pop	 ecx
  0006c	c3		 ret	 0
?mb_strtolower@@YAHPAUtagAMX@@PAH@Z ENDP		; mb_strtolower
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?strtolower@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?strtolower@@YAHPAUtagAMX@@PAH@Z PROC			; strtolower, COMDAT

; 761  : 	cell *cptr = get_amxaddr(amx, params[1]);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _params$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	ff 70 04	 push	 DWORD PTR [eax+4]
  00009	ff 74 24 10	 push	 DWORD PTR _amx$[esp+8]
  0000d	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr
  00012	8b f0		 mov	 esi, eax
  00014	83 c4 08	 add	 esp, 8

; 762  : 	cell *begin = cptr;

  00017	8b fe		 mov	 edi, esi

; 763  : 	
; 764  : 	while (*cptr)

  00019	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0001c	74 16		 je	 SHORT $LN3@strtolower
  0001e	66 90		 npad	 2
$LL2@strtolower:

; 765  : 	{
; 766  : 		*cptr = tolower(*cptr);

  00020	ff 36		 push	 DWORD PTR [esi]
  00022	e8 00 00 00 00	 call	 _tolower
  00027	89 06		 mov	 DWORD PTR [esi], eax
  00029	83 c4 04	 add	 esp, 4

; 767  : 		cptr++;

  0002c	83 c6 04	 add	 esi, 4
  0002f	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00032	75 ec		 jne	 SHORT $LL2@strtolower
$LN3@strtolower:

; 768  : 	}
; 769  : 
; 770  : 	return cptr - begin;

  00034	2b f7		 sub	 esi, edi
  00036	c1 fe 02	 sar	 esi, 2
  00039	5f		 pop	 edi
  0003a	8b c6		 mov	 eax, esi
  0003c	5e		 pop	 esi

; 771  : }

  0003d	c3		 ret	 0
?strtolower@@YAHPAUtagAMX@@PAH@Z ENDP			; strtolower
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?parse@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_parse$ = -8						; size = 4
_state$ = -4						; size = 4
_c$ = -4						; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?parse@@YAHPAUtagAMX@@PAH@Z PROC			; parse, COMDAT

; 732  : {

  00000	83 ec 08	 sub	 esp, 8
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi

; 733  : 	int inum = *params / sizeof(cell), iarg = 2, c;

  00006	8b 74 24 1c	 mov	 esi, DWORD PTR _params$[esp+16]

; 734  : 	char* arg, *parse = get_amxstring(amx, params[1], 0, c);

  0000a	8d 44 24 10	 lea	 eax, DWORD PTR _c$[esp+20]
  0000e	57		 push	 edi
  0000f	50		 push	 eax
  00010	6a 00		 push	 0
  00012	ff 76 04	 push	 DWORD PTR [esi+4]
  00015	8b 2e		 mov	 ebp, DWORD PTR [esi]
  00017	bb 02 00 00 00	 mov	 ebx, 2
  0001c	ff 74 24 28	 push	 DWORD PTR _amx$[esp+32]
  00020	c1 ed 02	 shr	 ebp, 2
  00023	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  00028	83 c4 10	 add	 esp, 16			; 00000010H
  0002b	89 44 24 10	 mov	 DWORD PTR _parse$[esp+24], eax

; 735  : 	cell *cptr;
; 736  : 	int state;
; 737  : 	
; 738  : 	while (*parse)

  0002f	80 38 00	 cmp	 BYTE PTR [eax], 0
  00032	74 73		 je	 SHORT $LN18@parse
$LL2@parse:

; 739  : 	{
; 740  : 		arg = parse_arg(&parse,state);

  00034	8d 44 24 14	 lea	 eax, DWORD PTR _state$[esp+24]
  00038	50		 push	 eax
  00039	8d 44 24 14	 lea	 eax, DWORD PTR _parse$[esp+28]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?parse_arg@@YAPADPAPADAAH@Z ; parse_arg
  00043	83 c4 08	 add	 esp, 8
  00046	8b f8		 mov	 edi, eax

; 741  : 		
; 742  : 		if (state)

  00048	83 7c 24 14 00	 cmp	 DWORD PTR _state$[esp+24], 0
  0004d	74 4f		 je	 SHORT $LN6@parse

; 743  : 		{
; 744  : 			if (inum <= iarg)

  0004f	3b eb		 cmp	 ebp, ebx
  00051	7e 54		 jle	 SHORT $LN18@parse

; 745  : 				return ((iarg - 2)>>1);
; 746  : 			
; 747  : 			cptr = get_amxaddr(amx, params[iarg++]);

  00053	ff 34 9e	 push	 DWORD PTR [esi+ebx*4]
  00056	ff 74 24 20	 push	 DWORD PTR _amx$[esp+24]
  0005a	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr
  0005f	8b f0		 mov	 esi, eax

; 748  : 			c = *get_amxaddr(amx, params[iarg++]);

  00061	8b 44 24 28	 mov	 eax, DWORD PTR _params$[esp+28]
  00065	ff 74 98 04	 push	 DWORD PTR [eax+ebx*4+4]
  00069	ff 74 24 28	 push	 DWORD PTR _amx$[esp+32]
  0006d	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr
  00072	83 c4 10	 add	 esp, 16			; 00000010H
  00075	83 c3 02	 add	 ebx, 2
  00078	8b 08		 mov	 ecx, DWORD PTR [eax]

; 749  : 			
; 750  : 			while (c-- && *arg)

  0007a	85 c9		 test	 ecx, ecx
  0007c	74 16		 je	 SHORT $LN19@parse
  0007e	66 90		 npad	 2
$LL4@parse:
  00080	8a 07		 mov	 al, BYTE PTR [edi]
  00082	49		 dec	 ecx
  00083	84 c0		 test	 al, al
  00085	74 0d		 je	 SHORT $LN19@parse

; 751  : 				*cptr++ = (unsigned char)*arg++;

  00087	0f b6 c0	 movzx	 eax, al
  0008a	47		 inc	 edi
  0008b	89 06		 mov	 DWORD PTR [esi], eax
  0008d	83 c6 04	 add	 esi, 4
  00090	85 c9		 test	 ecx, ecx
  00092	75 ec		 jne	 SHORT $LL4@parse
$LN19@parse:

; 752  : 			*cptr = 0;

  00094	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0009a	8b 74 24 20	 mov	 esi, DWORD PTR _params$[esp+20]
$LN6@parse:

; 735  : 	cell *cptr;
; 736  : 	int state;
; 737  : 	
; 738  : 	while (*parse)

  0009e	8b 44 24 10	 mov	 eax, DWORD PTR _parse$[esp+24]
  000a2	80 38 00	 cmp	 BYTE PTR [eax], 0
  000a5	75 8d		 jne	 SHORT $LL2@parse
$LN18@parse:
  000a7	5f		 pop	 edi
  000a8	5e		 pop	 esi

; 753  : 		}
; 754  : 	}
; 755  : 
; 756  : 	return ((iarg - 2)>>1);

  000a9	8d 43 fe	 lea	 eax, DWORD PTR [ebx-2]
  000ac	5d		 pop	 ebp
  000ad	d1 f8		 sar	 eax, 1
  000af	5b		 pop	 ebx

; 757  : }

  000b0	83 c4 08	 add	 esp, 8
  000b3	c3		 ret	 0
?parse@@YAHPAUtagAMX@@PAH@Z ENDP			; parse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?format@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_buf$1$ = -12						; size = 4
_param$ = -8						; size = 4
_fmt$1$ = -4						; size = 4
_amx$ = 8						; size = 4
_copy$1$ = 12						; size = 1
_params$ = 12						; size = 4
?format@@YAHPAUtagAMX@@PAH@Z PROC			; format, COMDAT

; 691  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp

; 692  : 	cell *buf = get_amxaddr(amx, params[1]);

  00005	8b 6c 24 18	 mov	 ebp, DWORD PTR _amx$[esp+16]
  00009	56		 push	 esi
  0000a	8b 74 24 20	 mov	 esi, DWORD PTR _params$[esp+20]
  0000e	57		 push	 edi
  0000f	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00012	57		 push	 edi
  00013	55		 push	 ebp
  00014	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 693  : 	cell *fmt = get_amxaddr(amx, params[3]);

  00019	ff 76 0c	 push	 DWORD PTR [esi+12]
  0001c	89 44 24 1c	 mov	 DWORD PTR _buf$1$[esp+40], eax
  00020	55		 push	 ebp
  00021	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 694  : 	size_t maxlen = params[2];
; 695  : 	/** 
; 696  : 	 * SPECIAL CASE - check if the buffers overlap.
; 697  : 	 *  some users, for whatever reason, do things like:
; 698  : 	 *  format(buf, 255, buf....
; 699  : 	 *  this is considered "deprecated" but we have to support it.
; 700  : 	 * we do this by checking to see if reading from buf will overlap
; 701  : 	 */
; 702  : 	cell addr_start = params[1];
; 703  : 	cell addr_end = params[1] + maxlen * sizeof(cell);
; 704  : 	cell max = params[0] / sizeof(cell);

  00026	8b 16		 mov	 edx, DWORD PTR [esi]

; 705  : 	bool copy = false;
; 706  : 	for (cell i = 3; i <= max; i++)

  00028	b9 03 00 00 00	 mov	 ecx, 3
  0002d	89 44 24 28	 mov	 DWORD PTR _fmt$1$[esp+44], eax
  00031	83 c4 10	 add	 esp, 16			; 00000010H
  00034	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00037	c1 ea 02	 shr	 edx, 2
  0003a	c6 44 24 24 00	 mov	 BYTE PTR _copy$1$[esp+24], 0
  0003f	8d 1c 87	 lea	 ebx, DWORD PTR [edi+eax*4]
  00042	3b d1		 cmp	 edx, ecx
  00044	72 10		 jb	 SHORT $LN18@format
$LL4@format:

; 707  : 	{
; 708  : 		//does this clip the bounds?!?!? WELL, DOES IT!?!?! i am a loud dog
; 709  : 		if (params[i] >= addr_start && params[i] <= addr_end)

  00046	8b 04 8e	 mov	 eax, DWORD PTR [esi+ecx*4]
  00049	3b c7		 cmp	 eax, edi
  0004b	7c 04		 jl	 SHORT $LN2@format
  0004d	3b c3		 cmp	 eax, ebx
  0004f	7e 5d		 jle	 SHORT $LN10@format
$LN2@format:

; 705  : 	bool copy = false;
; 706  : 	for (cell i = 3; i <= max; i++)

  00051	41		 inc	 ecx
  00052	3b ca		 cmp	 ecx, edx
  00054	7e f0		 jle	 SHORT $LL4@format
$LN18@format:
  00056	8b 44 24 10	 mov	 eax, DWORD PTR _buf$1$[esp+28]
$LN15@format:

; 717  : 	int param = 4;
; 718  : 	size_t total = 0;
; 719  : 
; 720  : 	total = atcprintf(buf, maxlen, fmt, amx, params, &param);

  0005a	8d 4c 24 14	 lea	 ecx, DWORD PTR _param$[esp+28]
  0005e	c7 44 24 14 04
	00 00 00	 mov	 DWORD PTR _param$[esp+28], 4
  00066	51		 push	 ecx
  00067	56		 push	 esi
  00068	55		 push	 ebp
  00069	ff 74 24 24	 push	 DWORD PTR _fmt$1$[esp+40]
  0006d	ff 76 08	 push	 DWORD PTR [esi+8]
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ??$atcprintf@HH@@YAIPAHIPBHPAUtagAMX@@00@Z ; atcprintf<int,int>
  00076	83 c4 18	 add	 esp, 24			; 00000018H
  00079	8b f8		 mov	 edi, eax

; 721  : 
; 722  : 	if (copy)

  0007b	80 7c 24 24 00	 cmp	 BYTE PTR _copy$1$[esp+24], 0
  00080	74 22		 je	 SHORT $LN16@format

; 723  : 	{
; 724  : 		/* copy back */
; 725  : 		cell *old = get_amxaddr(amx, params[1]);
; 726  : 		memcpy(old, g_cpbuf, (total+1) * sizeof(cell));

  00082	8d 0c bd 04 00
	00 00		 lea	 ecx, DWORD PTR [edi*4+4]
  00089	51		 push	 ecx
  0008a	68 00 00 00 00	 push	 OFFSET ?g_cpbuf@@3PAHA
  0008f	ff 76 04	 push	 DWORD PTR [esi+4]
  00092	55		 push	 ebp
  00093	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr
  00098	83 c4 08	 add	 esp, 8
  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 _memcpy
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@format:

; 727  : 	}
; 728  : 	return total;

  000a4	8b c7		 mov	 eax, edi
  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
  000a8	5d		 pop	 ebp
  000a9	5b		 pop	 ebx

; 729  : }

  000aa	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ad	c3		 ret	 0
$LN10@format:

; 710  : 		{
; 711  : 			copy = true;

  000ae	c6 44 24 24 01	 mov	 BYTE PTR _copy$1$[esp+24], 1

; 712  : 			break;
; 713  : 		}
; 714  : 	}
; 715  : 	if (copy)
; 716  : 		buf = g_cpbuf;

  000b3	b8 00 00 00 00	 mov	 eax, OFFSET ?g_cpbuf@@3PAHA
  000b8	eb a0		 jmp	 SHORT $LN15@format
?format@@YAHPAUtagAMX@@PAH@Z ENDP			; format
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?formatex@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_param$ = 12						; size = 4
_params$ = 12						; size = 4
?formatex@@YAHPAUtagAMX@@PAH@Z PROC			; formatex, COMDAT

; 681  : {

  00000	53		 push	 ebx

; 682  : 	cell *buf = get_amxaddr(amx, params[1]);

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _params$[esp]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 7c 24 10	 mov	 edi, DWORD PTR _amx$[esp+8]
  0000b	ff 73 04	 push	 DWORD PTR [ebx+4]
  0000e	57		 push	 edi
  0000f	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 683  : 	size_t maxlen = static_cast<size_t>(params[2]);
; 684  :     cell *fmt = get_amxaddr(amx, params[3]);

  00014	ff 73 0c	 push	 DWORD PTR [ebx+12]
  00017	8b f0		 mov	 esi, eax
  00019	57		 push	 edi
  0001a	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 685  : 	int param = 4;
; 686  : 	size_t total = atcprintf(buf, maxlen, fmt, amx, params, &param);

  0001f	8d 4c 24 24	 lea	 ecx, DWORD PTR _param$[esp+24]
  00023	c7 44 24 24 04
	00 00 00	 mov	 DWORD PTR _param$[esp+24], 4
  0002b	51		 push	 ecx
  0002c	53		 push	 ebx
  0002d	57		 push	 edi
  0002e	50		 push	 eax
  0002f	ff 73 08	 push	 DWORD PTR [ebx+8]
  00032	56		 push	 esi
  00033	e8 00 00 00 00	 call	 ??$atcprintf@HH@@YAIPAHIPBHPAUtagAMX@@00@Z ; atcprintf<int,int>
  00038	83 c4 28	 add	 esp, 40			; 00000028H
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx

; 687  : 	return static_cast<cell>(total);
; 688  : }

  0003e	c3		 ret	 0
?formatex@@YAHPAUtagAMX@@PAH@Z ENDP			; formatex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?equali@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_string1Length$ = -8					; size = 4
_string2Length$ = -4					; size = 4
_amx$ = 8						; size = 4
_string1Folded$1$ = 12					; size = 4
_params$ = 12						; size = 4
?equali@@YAHPAUtagAMX@@PAH@Z PROC			; equali, COMDAT

; 650  : {

  00000	83 ec 08	 sub	 esp, 8
  00003	53		 push	 ebx
  00004	55		 push	 ebp

; 651  : 	enum args { arg_count, arg_string1, arg_string2, arg_numbytes };
; 652  : 
; 653  : 	auto string1Length = 0;
; 654  : 	auto string2Length = 0;
; 655  : 
; 656  : 	auto string1 = get_amxstring(amx, params[arg_string1], 0, string1Length);

  00005	8b 6c 24 18	 mov	 ebp, DWORD PTR _params$[esp+12]
  00009	8d 44 24 08	 lea	 eax, DWORD PTR _string1Length$[esp+16]
  0000d	56		 push	 esi
  0000e	8b 74 24 18	 mov	 esi, DWORD PTR _amx$[esp+16]
  00012	57		 push	 edi
  00013	50		 push	 eax
  00014	6a 00		 push	 0
  00016	ff 75 04	 push	 DWORD PTR [ebp+4]
  00019	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _string1Length$[esp+36], 0
  00021	56		 push	 esi
  00022	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _string2Length$[esp+40], 0
  0002a	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  0002f	8b f8		 mov	 edi, eax

; 657  : 	auto string2 = get_amxstring(amx, params[arg_string2], 1, string2Length);

  00031	8d 44 24 24	 lea	 eax, DWORD PTR _string2Length$[esp+40]
  00035	50		 push	 eax
  00036	6a 01		 push	 1
  00038	ff 75 08	 push	 DWORD PTR [ebp+8]
  0003b	56		 push	 esi
  0003c	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring

; 658  : 
; 659  : 	auto string1Folded = get_amxbuffer(2);

  00041	6a 02		 push	 2
  00043	8b d8		 mov	 ebx, eax
  00045	e8 00 00 00 00	 call	 ?get_amxbuffer@@YAPADH@Z ; get_amxbuffer

; 660  : 	auto string2Folded = get_amxbuffer(3);

  0004a	6a 03		 push	 3
  0004c	89 44 24 48	 mov	 DWORD PTR _string1Folded$1$[esp+60], eax
  00050	e8 00 00 00 00	 call	 ?get_amxbuffer@@YAPADH@Z ; get_amxbuffer

; 661  : 
; 662  : 	string1Length = utf8casefold(string1, string1Length, string1Folded, MAX_BUFFER_LENGTH - 1, UTF8_LOCALE_DEFAULT, nullptr, TRUE);

  00055	6a 01		 push	 1
  00057	6a 00		 push	 0
  00059	6a 00		 push	 0
  0005b	68 ff 3f 00 00	 push	 16383			; 00003fffH
  00060	ff 74 24 58	 push	 DWORD PTR _string1Folded$1$[esp+76]
  00064	8b f0		 mov	 esi, eax
  00066	ff 74 24 4c	 push	 DWORD PTR _string1Length$[esp+84]
  0006a	57		 push	 edi
  0006b	e8 00 00 00 00	 call	 _utf8casefold
  00070	83 c4 44	 add	 esp, 68			; 00000044H
  00073	8b f8		 mov	 edi, eax

; 663  : 	string2Length = utf8casefold(string2, string2Length, string2Folded, MAX_BUFFER_LENGTH - 1, UTF8_LOCALE_DEFAULT, nullptr, TRUE);

  00075	6a 01		 push	 1
  00077	6a 00		 push	 0
  00079	6a 00		 push	 0
  0007b	68 ff 3f 00 00	 push	 16383			; 00003fffH
  00080	56		 push	 esi
  00081	ff 74 24 28	 push	 DWORD PTR _string2Length$[esp+44]
  00085	53		 push	 ebx
  00086	e8 00 00 00 00	 call	 _utf8casefold

; 664  : 
; 665  : 	string1Folded[string1Length] = '\0';

  0008b	8b 4c 24 3c	 mov	 ecx, DWORD PTR _string1Folded$1$[esp+48]
  0008f	83 c4 1c	 add	 esp, 28			; 0000001cH
  00092	c6 04 39 00	 mov	 BYTE PTR [ecx+edi], 0

; 666  : 	string2Folded[string2Length] = '\0';

  00096	c6 04 06 00	 mov	 BYTE PTR [esi+eax], 0

; 667  : 	
; 668  : 	if (params[arg_numbytes] > 0)

  0009a	8b 45 0c	 mov	 eax, DWORD PTR [ebp+12]
  0009d	85 c0		 test	 eax, eax
  0009f	7e 1f		 jle	 SHORT $LL2@equali

; 669  : 	{
; 670  : 		return static_cast<cell>(strncmp(string1Folded, string2Folded, params[arg_numbytes]) == 0);

  000a1	50		 push	 eax
  000a2	56		 push	 esi
  000a3	51		 push	 ecx
  000a4	e8 00 00 00 00	 call	 _strncmp
  000a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ac	f7 d8		 neg	 eax
  000ae	1b c0		 sbb	 eax, eax
  000b0	40		 inc	 eax
  000b1	5f		 pop	 edi
  000b2	5e		 pop	 esi
  000b3	5d		 pop	 ebp
  000b4	5b		 pop	 ebx

; 675  : 	}
; 676  : }

  000b5	83 c4 08	 add	 esp, 8
  000b8	c3		 ret	 0
  000b9	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@equali:

; 671  : 	}
; 672  : 	else
; 673  : 		{
; 674  : 		return static_cast<cell>(strcmp(string1Folded, string2Folded) == 0);

  000c0	8a 01		 mov	 al, BYTE PTR [ecx]
  000c2	3a 06		 cmp	 al, BYTE PTR [esi]
  000c4	75 27		 jne	 SHORT $LN6@equali
  000c6	84 c0		 test	 al, al
  000c8	74 12		 je	 SHORT $LN7@equali
  000ca	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  000cd	3a 46 01	 cmp	 al, BYTE PTR [esi+1]
  000d0	75 1b		 jne	 SHORT $LN6@equali
  000d2	83 c1 02	 add	 ecx, 2
  000d5	83 c6 02	 add	 esi, 2
  000d8	84 c0		 test	 al, al
  000da	75 e4		 jne	 SHORT $LL2@equali
$LN7@equali:
  000dc	5f		 pop	 edi
  000dd	33 c9		 xor	 ecx, ecx
  000df	33 c0		 xor	 eax, eax
  000e1	5e		 pop	 esi
  000e2	85 c9		 test	 ecx, ecx
  000e4	5d		 pop	 ebp
  000e5	0f 94 c0	 sete	 al
  000e8	5b		 pop	 ebx

; 675  : 	}
; 676  : }

  000e9	83 c4 08	 add	 esp, 8
  000ec	c3		 ret	 0
$LN6@equali:

; 671  : 	}
; 672  : 	else
; 673  : 		{
; 674  : 		return static_cast<cell>(strcmp(string1Folded, string2Folded) == 0);

  000ed	1b c9		 sbb	 ecx, ecx
  000ef	33 c0		 xor	 eax, eax
  000f1	5f		 pop	 edi
  000f2	83 c9 01	 or	 ecx, 1
  000f5	5e		 pop	 esi
  000f6	85 c9		 test	 ecx, ecx
  000f8	5d		 pop	 ebp
  000f9	0f 94 c0	 sete	 al
  000fc	5b		 pop	 ebx

; 675  : 	}
; 676  : }

  000fd	83 c4 08	 add	 esp, 8
  00100	c3		 ret	 0
?equali@@YAHPAUtagAMX@@PAH@Z ENDP			; equali
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?equal@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?equal@@YAHPAUtagAMX@@PAH@Z PROC			; equal, COMDAT

; 628  : {

  00000	53		 push	 ebx

; 629  : 	cell *a = get_amxaddr(amx, params[1]);

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _params$[esp]
  00005	56		 push	 esi
  00006	ff 73 04	 push	 DWORD PTR [ebx+4]
  00009	ff 74 24 10	 push	 DWORD PTR _amx$[esp+8]
  0000d	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 630  : 	cell *b = get_amxaddr(amx, params[2]);

  00012	ff 73 08	 push	 DWORD PTR [ebx+8]
  00015	8b f0		 mov	 esi, eax
  00017	ff 74 24 18	 push	 DWORD PTR _amx$[esp+16]
  0001b	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 631  : 	int c = params[3];

  00020	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00023	83 c4 10	 add	 esp, 16			; 00000010H
  00026	8b d0		 mov	 edx, eax

; 632  : 	
; 633  : 	if (c)

  00028	85 c9		 test	 ecx, ecx
  0002a	74 26		 je	 SHORT $LN9@equal

; 634  : 	{
; 635  : 		while (--c && *a && (*a == *b))

  0002c	83 e9 01	 sub	 ecx, 1
  0002f	74 15		 je	 SHORT $LN16@equal
$LL2@equal:
  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	85 c0		 test	 eax, eax
  00035	74 0f		 je	 SHORT $LN16@equal
  00037	3b 02		 cmp	 eax, DWORD PTR [edx]
  00039	75 0b		 jne	 SHORT $LN16@equal

; 636  : 			++a, ++b;

  0003b	83 c6 04	 add	 esi, 4
  0003e	83 c2 04	 add	 edx, 4
  00041	83 e9 01	 sub	 ecx, 1
  00044	75 eb		 jne	 SHORT $LL2@equal
$LN16@equal:
  00046	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00048	33 c0		 xor	 eax, eax
  0004a	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0004c	5e		 pop	 esi
  0004d	0f 94 c0	 sete	 al
  00050	5b		 pop	 ebx

; 644  : 	
; 645  : 	return ret ? 0 : 1;
; 646  : }

  00051	c3		 ret	 0
$LN9@equal:

; 637  : 		return (*a-*b) ? 0 : 1;
; 638  : 	}
; 639  : 	
; 640  : 	int ret;
; 641  : 	
; 642  : 	while (!(ret = *a - *b) && *b)

  00052	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00054	8b 02		 mov	 eax, DWORD PTR [edx]
  00056	2b c8		 sub	 ecx, eax
  00058	75 17		 jne	 SHORT $LN17@equal
  0005a	2b d6		 sub	 edx, esi
  0005c	0f 1f 40 00	 npad	 4
$LL4@equal:
  00060	85 c0		 test	 eax, eax
  00062	74 0d		 je	 SHORT $LN17@equal
  00064	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 643  : 		++a, ++b;

  00067	83 c6 04	 add	 esi, 4
  0006a	8b 04 32	 mov	 eax, DWORD PTR [edx+esi]
  0006d	2b c8		 sub	 ecx, eax
  0006f	74 ef		 je	 SHORT $LL4@equal
$LN17@equal:
  00071	33 c0		 xor	 eax, eax
  00073	85 c9		 test	 ecx, ecx
  00075	5e		 pop	 esi
  00076	0f 94 c0	 sete	 al
  00079	5b		 pop	 ebx

; 644  : 	
; 645  : 	return ret ? 0 : 1;
; 646  : }

  0007a	c3		 ret	 0
?equal@@YAHPAUtagAMX@@PAH@Z ENDP			; equal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?setc@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?setc@@YAHPAUtagAMX@@PAH@Z PROC				; setc, COMDAT

; 616  : {

  00000	56		 push	 esi

; 617  : 	cell *src = get_amxaddr(amx, params[1]);

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR _params$[esp]
  00005	57		 push	 edi
  00006	ff 76 04	 push	 DWORD PTR [esi+4]
  00009	ff 74 24 10	 push	 DWORD PTR _amx$[esp+8]
  0000d	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 618  : 	int c = params[2];
; 619  : 	cell ch = params[3];
; 620  : 	
; 621  : 	while (c--)

  00012	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00015	83 c4 08	 add	 esp, 8
  00018	8b f8		 mov	 edi, eax
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 05		 je	 SHORT $LN10@setc

; 617  : 	cell *src = get_amxaddr(amx, params[1]);

  0001e	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00021	f3 ab		 rep stosd
$LN10@setc:

; 622  : 		*src++ = ch;
; 623  : 	
; 624  : 	return 1;

  00023	5f		 pop	 edi
  00024	b8 01 00 00 00	 mov	 eax, 1
  00029	5e		 pop	 esi

; 625  : }

  0002a	c3		 ret	 0
?setc@@YAHPAUtagAMX@@PAH@Z ENDP				; setc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?copyc@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?copyc@@YAHPAUtagAMX@@PAH@Z PROC			; copyc, COMDAT

; 601  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi

; 602  : 	cell *src = get_amxaddr(amx, params[3]);

  00003	8b 74 24 10	 mov	 esi, DWORD PTR _amx$[esp+8]
  00007	57		 push	 edi
  00008	8b 7c 24 18	 mov	 edi, DWORD PTR _params$[esp+12]
  0000c	ff 77 0c	 push	 DWORD PTR [edi+12]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 603  : 	cell *dest = get_amxaddr(amx, params[1]);

  00015	ff 77 04	 push	 DWORD PTR [edi+4]
  00018	8b d8		 mov	 ebx, eax
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 604  : 	cell *start = dest;
; 605  : 	int c = params[2];

  00020	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00023	83 c4 10	 add	 esp, 16			; 00000010H

; 606  : 	cell ch = params[4];

  00026	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  00029	8b e8		 mov	 ebp, eax

; 607  : 	
; 608  : 	while (c-- && *src && *src != ch)

  0002b	85 d2		 test	 edx, edx
  0002d	74 17		 je	 SHORT $LN10@copyc
  0002f	2b d8		 sub	 ebx, eax
$LL2@copyc:
  00031	8b 0c 03	 mov	 ecx, DWORD PTR [ebx+eax]
  00034	4a		 dec	 edx
  00035	85 c9		 test	 ecx, ecx
  00037	74 0d		 je	 SHORT $LN10@copyc
  00039	3b ce		 cmp	 ecx, esi
  0003b	74 09		 je	 SHORT $LN10@copyc

; 609  : 		*dest++ =* src++;

  0003d	89 08		 mov	 DWORD PTR [eax], ecx
  0003f	83 c0 04	 add	 eax, 4
  00042	85 d2		 test	 edx, edx
  00044	75 eb		 jne	 SHORT $LL2@copyc
$LN10@copyc:
  00046	5f		 pop	 edi

; 610  : 	*dest = 0;

  00047	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 611  : 	
; 612  : 	return (dest - start);

  0004d	2b c5		 sub	 eax, ebp
  0004f	5e		 pop	 esi
  00050	5d		 pop	 ebp
  00051	c1 f8 02	 sar	 eax, 2
  00054	5b		 pop	 ebx

; 613  : }

  00055	c3		 ret	 0
?copyc@@YAHPAUtagAMX@@PAH@Z ENDP			; copyc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?copy@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?copy@@YAHPAUtagAMX@@PAH@Z PROC				; copy, COMDAT

; 584  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	57		 push	 edi

; 585  : 	cell *src = get_amxaddr(amx, params[3]);

  00003	8b 7c 24 14	 mov	 edi, DWORD PTR _params$[esp+8]
  00007	ff 77 0c	 push	 DWORD PTR [edi+12]
  0000a	ff 74 24 14	 push	 DWORD PTR _amx$[esp+12]
  0000e	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 586  : 	int c = params[2];
; 587  : 
; 588  : 	cell *dest = get_amxaddr(amx, params[1]);

  00013	ff 77 04	 push	 DWORD PTR [edi+4]
  00016	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  00019	8b e8		 mov	 ebp, eax
  0001b	ff 74 24 1c	 push	 DWORD PTR _amx$[esp+20]
  0001f	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 589  : 	cell *start = dest;

  00027	8b d0		 mov	 edx, eax

; 590  : 
; 591  : 	while (c-- && *src)

  00029	85 db		 test	 ebx, ebx
  0002b	74 14		 je	 SHORT $LN10@copy
  0002d	2b e8		 sub	 ebp, eax
  0002f	90		 npad	 1
$LL2@copy:
  00030	8b 0c 28	 mov	 ecx, DWORD PTR [eax+ebp]
  00033	4b		 dec	 ebx
  00034	85 c9		 test	 ecx, ecx
  00036	74 09		 je	 SHORT $LN10@copy

; 592  : 	{
; 593  : 		*dest++ = *src++;

  00038	89 08		 mov	 DWORD PTR [eax], ecx
  0003a	83 c0 04	 add	 eax, 4
  0003d	85 db		 test	 ebx, ebx
  0003f	75 ef		 jne	 SHORT $LL2@copy
$LN10@copy:
  00041	5f		 pop	 edi

; 594  : 	}
; 595  : 	*dest = '\0';

  00042	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 596  : 
; 597  : 	return (dest - start);

  00048	2b c2		 sub	 eax, edx
  0004a	5d		 pop	 ebp
  0004b	c1 f8 02	 sar	 eax, 2
  0004e	5b		 pop	 ebx

; 598  : }

  0004f	c3		 ret	 0
?copy@@YAHPAUtagAMX@@PAH@Z ENDP				; copy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?add@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?add@@YAHPAUtagAMX@@PAH@Z PROC				; add, COMDAT

; 558  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi

; 559  : 	cell *src = get_amxaddr(amx, params[3]);

  00003	8b 74 24 10	 mov	 esi, DWORD PTR _amx$[esp+8]
  00007	57		 push	 edi
  00008	8b 7c 24 18	 mov	 edi, DWORD PTR _params$[esp+12]
  0000c	ff 77 0c	 push	 DWORD PTR [edi+12]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 560  : 	cell *dest = get_amxaddr(amx, params[1]);

  00015	ff 77 04	 push	 DWORD PTR [edi+4]
  00018	8b d8		 mov	 ebx, eax
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 561  : 	cell *start = dest;
; 562  : 	int c = params[2], d = params[4];

  00020	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00023	83 c4 10	 add	 esp, 16			; 00000010H
  00026	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  00029	8b e8		 mov	 ebp, eax

; 563  : 	
; 564  : 	while (*dest && c--)

  0002b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002e	74 0f		 je	 SHORT $LN24@add
$LL2@add:
  00030	8b ca		 mov	 ecx, edx
  00032	4a		 dec	 edx
  00033	85 c9		 test	 ecx, ecx
  00035	74 08		 je	 SHORT $LN24@add

; 565  : 		++dest;

  00037	83 c0 04	 add	 eax, 4
  0003a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0003d	75 f1		 jne	 SHORT $LL2@add
$LN24@add:

; 566  : 	
; 567  : 	if (d)

  0003f	85 f6		 test	 esi, esi
  00041	74 31		 je	 SHORT $LN12@add

; 568  : 	{
; 569  : 		while (c-- && d-- && *src)

  00043	85 d2		 test	 edx, edx
  00045	74 44		 je	 SHORT $LN26@add
  00047	2b d8		 sub	 ebx, eax
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@add:
  00050	8b ce		 mov	 ecx, esi
  00052	4a		 dec	 edx
  00053	4e		 dec	 esi
  00054	85 c9		 test	 ecx, ecx
  00056	74 33		 je	 SHORT $LN26@add
  00058	8b 0c 03	 mov	 ecx, DWORD PTR [ebx+eax]
  0005b	85 c9		 test	 ecx, ecx
  0005d	74 2c		 je	 SHORT $LN26@add

; 570  : 			*dest++ =* src++;

  0005f	89 08		 mov	 DWORD PTR [eax], ecx
  00061	83 c0 04	 add	 eax, 4
  00064	85 d2		 test	 edx, edx
  00066	75 e8		 jne	 SHORT $LL4@add

; 578  : 	*dest = 0;

  00068	5f		 pop	 edi
  00069	89 10		 mov	 DWORD PTR [eax], edx

; 579  : 	
; 580  : 	return (dest-start);

  0006b	2b c5		 sub	 eax, ebp
  0006d	5e		 pop	 esi
  0006e	5d		 pop	 ebp
  0006f	c1 f8 02	 sar	 eax, 2
  00072	5b		 pop	 ebx

; 581  : }

  00073	c3		 ret	 0
$LN12@add:

; 571  : 		*dest = 0;
; 572  : 		
; 573  : 		return (dest - start);
; 574  : 	}
; 575  : 
; 576  : 	while (c-- && *src)

  00074	85 d2		 test	 edx, edx
  00076	74 13		 je	 SHORT $LN26@add
$LL6@add:
  00078	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0007a	4a		 dec	 edx
  0007b	85 c9		 test	 ecx, ecx
  0007d	74 0c		 je	 SHORT $LN26@add

; 577  : 		*dest++ =* src++;

  0007f	89 08		 mov	 DWORD PTR [eax], ecx
  00081	83 c3 04	 add	 ebx, 4
  00084	83 c0 04	 add	 eax, 4
  00087	85 d2		 test	 edx, edx
  00089	75 ed		 jne	 SHORT $LL6@add
$LN26@add:
  0008b	5f		 pop	 edi

; 578  : 	*dest = 0;

  0008c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 579  : 	
; 580  : 	return (dest-start);

  00092	2b c5		 sub	 eax, ebp
  00094	5e		 pop	 esi
  00095	5d		 pop	 ebp
  00096	c1 f8 02	 sar	 eax, 2
  00099	5b		 pop	 ebx

; 581  : }

  0009a	c3		 ret	 0
?add@@YAHPAUtagAMX@@PAH@Z ENDP				; add
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?float_to_str@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_szTemp$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?float_to_str@@YAHPAUtagAMX@@PAH@Z PROC			; float_to_str, COMDAT

; 550  : {

  00000	83 ec 24	 sub	 esp, 36			; 00000024H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 20	 mov	 DWORD PTR __$ArrayPad$[esp+36], eax
  0000e	56		 push	 esi
  0000f	8b 74 24 30	 mov	 esi, DWORD PTR _params$[esp+36]

; 551  : 	char szTemp[32];
; 552  : 	sprintf(szTemp, "%f", amx_ctof(params[1]));

  00013	8d 44 24 04	 lea	 eax, DWORD PTR _szTemp$[esp+40]
  00017	57		 push	 edi
  00018	8b 7c 24 30	 mov	 edi, DWORD PTR _amx$[esp+40]
  0001c	83 ec 08	 sub	 esp, 8
  0001f	f3 0f 10 46 04	 movss	 xmm0, DWORD PTR [esi+4]
  00024	0f 5a c0	 cvtps2pd xmm0, xmm0
  00027	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_02NJPGOMH@?$CFf?$AA@
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _sprintf

; 553  : 	
; 554  : 	return set_amxstring(amx, params[2], szTemp, params[3]);

  00037	ff 76 0c	 push	 DWORD PTR [esi+12]
  0003a	8d 44 24 1c	 lea	 eax, DWORD PTR _szTemp$[esp+64]
  0003e	50		 push	 eax
  0003f	ff 76 08	 push	 DWORD PTR [esi+8]
  00042	57		 push	 edi
  00043	e8 00 00 00 00	 call	 ?set_amxstring@@YAHPAUtagAMX@@HPBDH@Z ; set_amxstring

; 555  : }

  00048	8b 4c 24 48	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+76]
  0004c	83 c4 20	 add	 esp, 32			; 00000020H
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	33 cc		 xor	 ecx, esp
  00053	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00058	83 c4 24	 add	 esp, 36			; 00000024H
  0005b	c3		 ret	 0
?float_to_str@@YAHPAUtagAMX@@PAH@Z ENDP			; float_to_str
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?str_to_float@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_part2$1$ = -8						; size = 4
_fl$ = -8						; size = 4
_part1$1$ = -4						; size = 4
_amx$ = 8						; size = 4
_fl$1 = 12						; size = 4
_params$ = 12						; size = 4
_neg$1$ = 15						; size = 1
?str_to_float@@YAHPAUtagAMX@@PAH@Z PROC			; str_to_float, COMDAT

; 493  : {

  00000	83 ec 08	 sub	 esp, 8

; 494  : 	cell *str = get_amxaddr(amx, params[1]);

  00003	8b 44 24 10	 mov	 eax, DWORD PTR _params$[esp+4]
  00007	56		 push	 esi
  00008	ff 70 04	 push	 DWORD PTR [eax+4]
  0000b	ff 74 24 14	 push	 DWORD PTR _amx$[esp+12]
  0000f	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr
  00014	8b c8		 mov	 ecx, eax

; 495  : 
; 496  : 	bool neg = false;

  00016	c6 44 24 1f 00	 mov	 BYTE PTR _neg$1$[esp+16], 0

; 497  : 	unsigned long part1 = 0;

  0001b	33 f6		 xor	 esi, esi
  0001d	83 c4 08	 add	 esp, 8
  00020	89 74 24 08	 mov	 DWORD PTR _part1$1$[esp+12], esi

; 498  : 
; 499  : 	if (*str == '-')

  00024	8b 01		 mov	 eax, DWORD PTR [ecx]
  00026	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00029	75 07		 jne	 SHORT $LN6@str_to_flo

; 500  : 	{
; 501  : 		neg = true;

  0002b	c6 44 24 17 01	 mov	 BYTE PTR _neg$1$[esp+8], 1

; 502  : 		++str;

  00030	eb 05		 jmp	 SHORT $LN30@str_to_flo
$LN6@str_to_flo:

; 503  : 	}
; 504  : 	else if (*str == '+')

  00032	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  00035	75 03		 jne	 SHORT $LN18@str_to_flo
$LN30@str_to_flo:

; 505  : 		++str;

  00037	83 c1 04	 add	 ecx, 4
$LN18@str_to_flo:

; 506  : 
; 507  : 	while (*str)

  0003a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003c	85 d2		 test	 edx, edx
  0003e	74 5f		 je	 SHORT $LN3@str_to_flo
$LL2@str_to_flo:

; 508  : 	{
; 509  : 		if (*str == '.')

  00040	83 fa 2e	 cmp	 edx, 46			; 0000002eH
  00043	74 57		 je	 SHORT $LN20@str_to_flo

; 512  : 			break;
; 513  : 		}
; 514  : 		
; 515  : 		if (*str < '0' || *str > '9')

  00045	83 fa 30	 cmp	 edx, 48			; 00000030H
  00048	7c 1d		 jl	 SHORT $LN21@str_to_flo
  0004a	83 fa 39	 cmp	 edx, 57			; 00000039H
  0004d	7f 18		 jg	 SHORT $LN21@str_to_flo

; 519  : 		}
; 520  : 
; 521  : 		part1 *= 10;

  0004f	8d 34 b6	 lea	 esi, DWORD PTR [esi+esi*4]

; 522  : 		part1 += *str - '0';
; 523  : 
; 524  : 		++str;

  00052	83 c1 04	 add	 ecx, 4
  00055	8d 76 e8	 lea	 esi, DWORD PTR [esi-24]
  00058	8d 34 72	 lea	 esi, DWORD PTR [edx+esi*2]
  0005b	89 74 24 08	 mov	 DWORD PTR _part1$1$[esp+12], esi
  0005f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00061	85 d2		 test	 edx, edx
  00063	75 db		 jne	 SHORT $LL2@str_to_flo

; 531  : 	{
; 532  : 		if (*str < '0' || *str > '9')

  00065	eb 38		 jmp	 SHORT $LN3@str_to_flo
$LN21@str_to_flo:
  00067	66 0f 6e c6	 movd	 xmm0, esi

; 516  : 		{
; 517  : 			REAL fl = neg ? -static_cast<REAL>(part1) : static_cast<REAL>(part1);

  0006b	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0006f	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00072	80 7c 24 17 00	 cmp	 BYTE PTR _neg$1$[esp+8], 0
  00077	f2 0f 58 04 f5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[esi*8]
  00080	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00084	74 07		 je	 SHORT $LN16@str_to_flo
  00086	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
$LN16@str_to_flo:
  0008d	f3 0f 11 44 24
	14		 movss	 DWORD PTR _fl$1[esp+8], xmm0

; 518  : 			return amx_ftoc(fl);

  00093	8b 44 24 14	 mov	 eax, DWORD PTR _fl$1[esp+8]
  00097	5e		 pop	 esi

; 547  : }

  00098	83 c4 08	 add	 esp, 8
  0009b	c3		 ret	 0
$LN20@str_to_flo:

; 510  : 		{
; 511  : 			++str;

  0009c	83 c1 04	 add	 ecx, 4
$LN3@str_to_flo:

; 525  : 	}
; 526  : 
; 527  : 	unsigned long part2 = 0;
; 528  : 	unsigned long div = 1;
; 529  : 	
; 530  : 	while (*str)

  0009f	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a1	33 c0		 xor	 eax, eax
  000a3	57		 push	 edi
  000a4	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  000a7	85 d2		 test	 edx, edx
  000a9	74 32		 je	 SHORT $LN22@str_to_flo
  000ab	33 f6		 xor	 esi, esi
  000ad	0f 1f 00	 npad	 3
$LL4@str_to_flo:

; 531  : 	{
; 532  : 		if (*str < '0' || *str > '9')

  000b0	83 fa 30	 cmp	 edx, 48			; 00000030H
  000b3	7c 1c		 jl	 SHORT $LN29@str_to_flo
  000b5	83 fa 39	 cmp	 edx, 57			; 00000039H
  000b8	7f 17		 jg	 SHORT $LN29@str_to_flo

; 533  : 			break;
; 534  : 
; 535  : 		part2 *= 10;

  000ba	8d 34 b6	 lea	 esi, DWORD PTR [esi+esi*4]

; 536  : 		part2 += *str - '0';
; 537  : 		div *= 10;
; 538  : 		++str;

  000bd	83 c1 04	 add	 ecx, 4
  000c0	8d 76 e8	 lea	 esi, DWORD PTR [esi-24]
  000c3	8d 3c bf	 lea	 edi, DWORD PTR [edi+edi*4]
  000c6	8d 34 72	 lea	 esi, DWORD PTR [edx+esi*2]
  000c9	03 ff		 add	 edi, edi
  000cb	8b 11		 mov	 edx, DWORD PTR [ecx]
  000cd	85 d2		 test	 edx, edx
  000cf	75 df		 jne	 SHORT $LL4@str_to_flo
$LN29@str_to_flo:
  000d1	89 74 24 08	 mov	 DWORD PTR _part2$1$[esp+16], esi
  000d5	8b 74 24 0c	 mov	 esi, DWORD PTR _part1$1$[esp+16]
  000d9	8b 44 24 08	 mov	 eax, DWORD PTR _part2$1$[esp+16]
$LN22@str_to_flo:
  000dd	66 0f 6e c0	 movd	 xmm0, eax

; 539  : 	}
; 540  : 
; 541  : 	REAL fl = static_cast<REAL>(part1) + (static_cast<REAL>(part2) / div);

  000e1	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000e5	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000e8	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  000f1	66 0f 5a c8	 cvtpd2ps xmm1, xmm0
  000f5	66 0f 6e c7	 movd	 xmm0, edi
  000f9	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000fd	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00100	f2 0f 58 04 fd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edi*8]
  00109	5f		 pop	 edi
  0010a	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0010e	f3 0f 5e c8	 divss	 xmm1, xmm0
  00112	66 0f 6e c6	 movd	 xmm0, esi
  00116	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0011a	c1 ee 1f	 shr	 esi, 31			; 0000001fH

; 542  : 	
; 543  : 	if (neg)

  0011d	80 7c 24 17 00	 cmp	 BYTE PTR _neg$1$[esp+8], 0
  00122	f2 0f 58 04 f5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[esi*8]
  0012b	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0012f	f3 0f 58 c8	 addss	 xmm1, xmm0
  00133	f3 0f 11 4c 24
	04		 movss	 DWORD PTR _fl$[esp+12], xmm1
  00139	74 0d		 je	 SHORT $LN14@str_to_flo

; 544  : 		fl = -fl;

  0013b	0f 57 0d 00 00
	00 00		 xorps	 xmm1, DWORD PTR __xmm@80000000800000008000000080000000
  00142	f3 0f 11 4c 24
	04		 movss	 DWORD PTR _fl$[esp+12], xmm1
$LN14@str_to_flo:

; 545  : 	
; 546  : 	return amx_ftoc(fl);

  00148	8b 44 24 04	 mov	 eax, DWORD PTR _fl$[esp+12]
  0014c	5e		 pop	 esi

; 547  : }

  0014d	83 c4 08	 add	 esp, 8
  00150	c3		 ret	 0
?str_to_float@@YAHPAUtagAMX@@PAH@Z ENDP			; str_to_float
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?numtostr@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_szTemp$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?numtostr@@YAHPAUtagAMX@@PAH@Z PROC			; numtostr, COMDAT

; 485  : {

  00000	83 ec 24	 sub	 esp, 36			; 00000024H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 20	 mov	 DWORD PTR __$ArrayPad$[esp+36], eax
  0000e	56		 push	 esi
  0000f	8b 74 24 30	 mov	 esi, DWORD PTR _params$[esp+36]

; 486  : 	char szTemp[32];
; 487  : 	sprintf(szTemp, "%d", (int)params[1]);

  00013	8d 44 24 04	 lea	 eax, DWORD PTR _szTemp$[esp+40]
  00017	57		 push	 edi
  00018	8b 7c 24 30	 mov	 edi, DWORD PTR _amx$[esp+40]
  0001c	ff 76 04	 push	 DWORD PTR [esi+4]
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _sprintf

; 488  : 
; 489  : 	return set_amxstring(amx, params[2], szTemp, params[3]);

  0002a	ff 76 0c	 push	 DWORD PTR [esi+12]
  0002d	8d 44 24 18	 lea	 eax, DWORD PTR _szTemp$[esp+60]
  00031	50		 push	 eax
  00032	ff 76 08	 push	 DWORD PTR [esi+8]
  00035	57		 push	 edi
  00036	e8 00 00 00 00	 call	 ?set_amxstring@@YAHPAUtagAMX@@HPBDH@Z ; set_amxstring

; 490  : }

  0003b	8b 4c 24 44	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+72]
  0003f	83 c4 1c	 add	 esp, 28			; 0000001cH
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	33 cc		 xor	 ecx, esp
  00046	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004b	83 c4 24	 add	 esp, 36			; 00000024H
  0004e	c3		 ret	 0
?numtostr@@YAHPAUtagAMX@@PAH@Z ENDP			; numtostr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?amx_strtof@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_result$ = -4						; size = 4
_len$ = -4						; size = 4
_amx$ = 8						; size = 4
_pEnd$ = 12						; size = 4
_params$ = 12						; size = 4
?amx_strtof@@YAHPAUtagAMX@@PAH@Z PROC			; amx_strtof, COMDAT

; 471  : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	56		 push	 esi

; 472  : 	int len;
; 473  : 	char *pString = get_amxstring(amx, params[1], 0, len);

  00003	8b 74 24 10	 mov	 esi, DWORD PTR _amx$[esp+8]
  00007	8d 44 24 08	 lea	 eax, DWORD PTR _len$[esp+12]
  0000b	57		 push	 edi
  0000c	8b 7c 24 18	 mov	 edi, DWORD PTR _params$[esp+12]
  00010	50		 push	 eax
  00011	6a 00		 push	 0
  00013	ff 77 04	 push	 DWORD PTR [edi+4]
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring

; 474  : 	cell *endPos = get_amxaddr(amx, params[2]);

  0001c	ff 77 08	 push	 DWORD PTR [edi+8]
  0001f	8b d8		 mov	 ebx, eax
  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr
  00027	8b f0		 mov	 esi, eax

; 475  : 
; 476  : 	char *pEnd = NULL;

  00029	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR _pEnd$[esp+36], 0

; 477  : 	float result = strtod(pString, &pEnd);

  00031	8d 44 24 30	 lea	 eax, DWORD PTR _pEnd$[esp+36]
  00035	50		 push	 eax
  00036	53		 push	 ebx
  00037	e8 00 00 00 00	 call	 _strtod

; 478  : 
; 479  : 	*endPos = pEnd - pString;

  0003c	8b 44 24 38	 mov	 eax, DWORD PTR _pEnd$[esp+44]
  00040	83 c4 20	 add	 esp, 32			; 00000020H
  00043	2b c3		 sub	 eax, ebx
  00045	89 06		 mov	 DWORD PTR [esi], eax
  00047	d9 5c 24 0c	 fstp	 DWORD PTR _result$[esp+16]

; 480  : 
; 481  : 	return amx_ftoc(result);

  0004b	8b 44 24 0c	 mov	 eax, DWORD PTR _result$[esp+16]
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx

; 482  : }

  00052	59		 pop	 ecx
  00053	c3		 ret	 0
?amx_strtof@@YAHPAUtagAMX@@PAH@Z ENDP			; amx_strtof
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?amx_strtol@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_len$ = -4						; size = 4
_amx$ = 8						; size = 4
_pEnd$ = 12						; size = 4
_params$ = 12						; size = 4
?amx_strtol@@YAHPAUtagAMX@@PAH@Z PROC			; amx_strtol, COMDAT

; 452  : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp

; 453  : 	int len;
; 454  : 	int base = params[3];

  00003	8b 6c 24 14	 mov	 ebp, DWORD PTR _params$[esp+8]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 5d 0c	 mov	 ebx, DWORD PTR [ebp+12]

; 455  : 
; 456  : 	if (base != 0 && (base < 2 || base > 36))

  0000c	85 db		 test	 ebx, ebx
  0000e	74 0c		 je	 SHORT $LN2@amx_strtol
  00010	83 fb 02	 cmp	 ebx, 2
  00013	7c 05		 jl	 SHORT $LN3@amx_strtol
  00015	83 fb 24	 cmp	 ebx, 36			; 00000024H
  00018	7e 02		 jle	 SHORT $LN2@amx_strtol
$LN3@amx_strtol:

; 457  : 		base = 0;

  0001a	33 db		 xor	 ebx, ebx
$LN2@amx_strtol:

; 458  : 
; 459  : 	char *pString = get_amxstring(amx, params[1], 0, len);

  0001c	8b 74 24 18	 mov	 esi, DWORD PTR _amx$[esp+16]
  00020	8d 44 24 10	 lea	 eax, DWORD PTR _len$[esp+20]
  00024	50		 push	 eax
  00025	6a 00		 push	 0
  00027	ff 75 04	 push	 DWORD PTR [ebp+4]
  0002a	56		 push	 esi
  0002b	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring

; 460  : 	cell *endPos = get_amxaddr(amx, params[2]);

  00030	ff 75 08	 push	 DWORD PTR [ebp+8]
  00033	8b f8		 mov	 edi, eax
  00035	56		 push	 esi
  00036	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr
  0003b	8b f0		 mov	 esi, eax

; 461  : 
; 462  : 	char *pEnd = NULL;

  0003d	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR _pEnd$[esp+40], 0

; 463  : 	long result = strtol(pString, &pEnd, base);

  00045	53		 push	 ebx
  00046	8d 44 24 38	 lea	 eax, DWORD PTR _pEnd$[esp+44]
  0004a	50		 push	 eax
  0004b	57		 push	 edi
  0004c	e8 00 00 00 00	 call	 _strtol

; 464  : 
; 465  : 	*endPos = pEnd - pString;

  00051	8b 4c 24 40	 mov	 ecx, DWORD PTR _pEnd$[esp+52]
  00055	83 c4 24	 add	 esp, 36			; 00000024H
  00058	2b cf		 sub	 ecx, edi
  0005a	89 0e		 mov	 DWORD PTR [esi], ecx
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5d		 pop	 ebp
  0005f	5b		 pop	 ebx

; 466  : 
; 467  : 	return result;
; 468  : }

  00060	59		 pop	 ecx
  00061	c3		 ret	 0
?amx_strtol@@YAHPAUtagAMX@@PAH@Z ENDP			; amx_strtol
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?strtonum@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_iLen$ = -4						; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?strtonum@@YAHPAUtagAMX@@PAH@Z PROC			; strtonum, COMDAT

; 446  : {

  00000	51		 push	 ecx

; 447  : 	int iLen;
; 448  : 	return atoi(get_amxstring(amx, params[1], 0, iLen));

  00001	8d 04 24	 lea	 eax, DWORD PTR _iLen$[esp+4]
  00004	50		 push	 eax
  00005	8b 44 24 10	 mov	 eax, DWORD PTR _params$[esp+4]
  00009	6a 00		 push	 0
  0000b	ff 70 04	 push	 DWORD PTR [eax+4]
  0000e	ff 74 24 14	 push	 DWORD PTR _amx$[esp+12]
  00012	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 _atoi

; 449  : }

  0001d	83 c4 18	 add	 esp, 24			; 00000018H
  00020	c3		 ret	 0
?strtonum@@YAHPAUtagAMX@@PAH@Z ENDP			; strtonum
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?containi@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_searchLength$ = -12					; size = 4
_sourceLength$ = -8					; size = 4
_search$1$ = -4						; size = 4
_amx$ = 8						; size = 4
_source$1$ = 12						; size = 4
_params$ = 12						; size = 4
?containi@@YAHPAUtagAMX@@PAH@Z PROC			; containi, COMDAT

; 414  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	55		 push	 ebp
  00004	56		 push	 esi

; 415  : 	enum args { arg_count, arg_source, arg_search };
; 416  : 
; 417  : 	auto sourceLength = 0;
; 418  : 	auto searchLength = 0;
; 419  : 
; 420  : 	auto source = get_amxstring(amx, params[arg_source], 0, sourceLength);

  00005	8b 74 24 18	 mov	 esi, DWORD PTR _amx$[esp+16]
  00009	8d 44 24 0c	 lea	 eax, DWORD PTR _sourceLength$[esp+20]
  0000d	57		 push	 edi
  0000e	8b 7c 24 20	 mov	 edi, DWORD PTR _params$[esp+20]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _sourceLength$[esp+32], 0
  0001d	ff 77 04	 push	 DWORD PTR [edi+4]
  00020	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR _searchLength$[esp+36], 0
  00028	56		 push	 esi
  00029	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  0002e	89 44 24 30	 mov	 DWORD PTR _source$1$[esp+36], eax

; 421  : 	auto search = get_amxstring(amx, params[arg_search], 1, searchLength);

  00032	8d 44 24 1c	 lea	 eax, DWORD PTR _searchLength$[esp+40]
  00036	50		 push	 eax
  00037	6a 01		 push	 1
  00039	ff 77 08	 push	 DWORD PTR [edi+8]
  0003c	56		 push	 esi
  0003d	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring

; 422  : 
; 423  : 	if (sourceLength && searchLength)

  00042	8b 74 24 30	 mov	 esi, DWORD PTR _sourceLength$[esp+56]
  00046	83 c4 20	 add	 esp, 32			; 00000020H
  00049	89 44 24 14	 mov	 DWORD PTR _search$1$[esp+24], eax
  0004d	85 f6		 test	 esi, esi
  0004f	74 6c		 je	 SHORT $LN3@containi
  00051	83 7c 24 0c 00	 cmp	 DWORD PTR _searchLength$[esp+24], 0
  00056	74 65		 je	 SHORT $LN3@containi

; 424  : 	{
; 425  : 		auto sourceFolded = get_amxbuffer(2);

  00058	6a 02		 push	 2
  0005a	e8 00 00 00 00	 call	 ?get_amxbuffer@@YAPADH@Z ; get_amxbuffer

; 426  : 		auto searchFolded = get_amxbuffer(3);

  0005f	6a 03		 push	 3
  00061	8b e8		 mov	 ebp, eax
  00063	e8 00 00 00 00	 call	 ?get_amxbuffer@@YAPADH@Z ; get_amxbuffer

; 427  : 
; 428  : 		sourceLength = utf8casefold(source, sourceLength, sourceFolded, MAX_BUFFER_LENGTH - 1, UTF8_LOCALE_DEFAULT, nullptr, TRUE);

  00068	6a 01		 push	 1
  0006a	6a 00		 push	 0
  0006c	6a 00		 push	 0
  0006e	68 ff 3f 00 00	 push	 16383			; 00003fffH
  00073	55		 push	 ebp
  00074	56		 push	 esi
  00075	ff 74 24 40	 push	 DWORD PTR _source$1$[esp+52]
  00079	8b f8		 mov	 edi, eax
  0007b	e8 00 00 00 00	 call	 _utf8casefold

; 429  : 		searchLength = utf8casefold(search, searchLength, searchFolded, MAX_BUFFER_LENGTH - 1, UTF8_LOCALE_DEFAULT, nullptr, TRUE);

  00080	6a 01		 push	 1
  00082	6a 00		 push	 0
  00084	6a 00		 push	 0
  00086	68 ff 3f 00 00	 push	 16383			; 00003fffH
  0008b	57		 push	 edi
  0008c	ff 74 24 44	 push	 DWORD PTR _searchLength$[esp+80]
  00090	8b f0		 mov	 esi, eax
  00092	ff 74 24 50	 push	 DWORD PTR _search$1$[esp+84]
  00096	e8 00 00 00 00	 call	 _utf8casefold
  0009b	83 c4 40	 add	 esp, 64			; 00000040H

; 430  : 
; 431  : 		sourceFolded[sourceLength] = '\0';

  0009e	c6 04 2e 00	 mov	 BYTE PTR [esi+ebp], 0

; 432  : 		searchFolded[searchLength] = '\0';

  000a2	c6 04 07 00	 mov	 BYTE PTR [edi+eax], 0
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h

; 537  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  000a6	57		 push	 edi
  000a7	55		 push	 ebp
  000a8	e8 00 00 00 00	 call	 _strstr
  000ad	83 c4 08	 add	 esp, 8
; File e:\nightfire_sdk\amx\amxmodx\string.cpp

; 436  : 		if (result)

  000b0	85 c0		 test	 eax, eax
  000b2	74 09		 je	 SHORT $LN3@containi

; 437  : 		{
; 438  : 			return result - sourceFolded;

  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi
  000b6	2b c5		 sub	 eax, ebp
  000b8	5d		 pop	 ebp

; 443  : }

  000b9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bc	c3		 ret	 0
$LN3@containi:
  000bd	5f		 pop	 edi
  000be	5e		 pop	 esi

; 439  : 		}
; 440  : 	}
; 441  : 	
; 442  : 	return -1;

  000bf	83 c8 ff	 or	 eax, -1
  000c2	5d		 pop	 ebp

; 443  : }

  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c6	c3		 ret	 0
?containi@@YAHPAUtagAMX@@PAH@Z ENDP			; containi
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?contain@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?contain@@YAHPAUtagAMX@@PAH@Z PROC			; contain, COMDAT

; 389  : {

  00000	53		 push	 ebx

; 390  : 	register cell *a = get_amxaddr(amx, params[2]);

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _params$[esp]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 7c 24 10	 mov	 edi, DWORD PTR _amx$[esp+8]
  0000b	ff 73 08	 push	 DWORD PTR [ebx+8]
  0000e	57		 push	 edi
  0000f	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 391  : 	register cell *b = get_amxaddr(amx, params[1]);

  00014	ff 73 04	 push	 DWORD PTR [ebx+4]
  00017	8b f0		 mov	 esi, eax
  00019	57		 push	 edi
  0001a	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr
  0001f	83 c4 10	 add	 esp, 16			; 00000010H

; 392  : 	register cell *c = b;

  00022	8b d0		 mov	 edx, eax

; 393  : 	cell* str = b;

  00024	8b d8		 mov	 ebx, eax

; 394  : 	cell* substr = a;

  00026	8b fe		 mov	 edi, esi

; 395  : 	
; 396  : 	while (*c)

  00028	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002b	74 29		 je	 SHORT $LN12@contain
  0002d	0f 1f 00	 npad	 3
$LL2@contain:

; 397  : 	{
; 398  : 		if (*c == *a)

  00030	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00032	3b 0e		 cmp	 ecx, DWORD PTR [esi]
  00034	75 14		 jne	 SHORT $LN4@contain

; 399  : 		{
; 400  : 			c++;
; 401  : 			if (!*++a)

  00036	83 c6 04	 add	 esi, 4
  00039	83 c2 04	 add	 edx, 4
  0003c	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0003f	75 10		 jne	 SHORT $LN5@contain

; 402  : 				return b - str;

  00041	5f		 pop	 edi
  00042	2b c3		 sub	 eax, ebx
  00044	5e		 pop	 esi
  00045	c1 f8 02	 sar	 eax, 2
  00048	5b		 pop	 ebx

; 410  : }

  00049	c3		 ret	 0
$LN4@contain:

; 403  : 		} else {
; 404  : 			c = ++b;

  0004a	83 c0 04	 add	 eax, 4

; 405  : 			a = substr;

  0004d	8b f7		 mov	 esi, edi
  0004f	8b d0		 mov	 edx, eax
$LN5@contain:

; 395  : 	
; 396  : 	while (*c)

  00051	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00054	75 da		 jne	 SHORT $LL2@contain
$LN12@contain:
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 406  : 		}
; 407  : 	}
; 408  : 	
; 409  : 	return -1;

  00058	83 c8 ff	 or	 eax, -1
  0005b	5b		 pop	 ebx

; 410  : }

  0005c	c3		 ret	 0
?contain@@YAHPAUtagAMX@@PAH@Z ENDP			; contain
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?replace_stringex@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_searchLength$ = -20					; size = 4
_replaceLength$ = -16					; size = 4
_search$1$ = -8						; size = 4
_textMaxLength$1$ = -4					; size = 4
_amx$ = 8						; size = 4
_caseSensitive$ = 12					; size = 1
_textLength$ = 12					; size = 4
_params$ = 12						; size = 4
?replace_stringex@@YAHPAUtagAMX@@PAH@Z PROC		; replace_stringex, COMDAT

; 353  : {

  00000	83 ec 14	 sub	 esp, 20			; 00000014H
  00003	53		 push	 ebx
  00004	55		 push	 ebp

; 354  : 	enum args { arg_count, arg_text, arg_maxlength, arg_search, arg_replace, arg_searchlen, arg_replacelen, arg_casesensitive };
; 355  : 
; 356  : 	auto textLength    = 0;
; 357  : 	auto searchLength  = 0;
; 358  : 	auto replaceLength = 0;
; 359  : 
; 360  : 	auto text    = get_amxstring(amx, params[arg_text]   , 0, textLength);

  00005	8b 6c 24 24	 mov	 ebp, DWORD PTR _params$[esp+24]
  00009	8d 44 24 24	 lea	 eax, DWORD PTR _textLength$[esp+24]
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b 7c 24 28	 mov	 edi, DWORD PTR _amx$[esp+32]
  00013	50		 push	 eax
  00014	6a 00		 push	 0
  00016	ff 75 04	 push	 DWORD PTR [ebp+4]
  00019	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _searchLength$[esp+48], 0
  00021	57		 push	 edi
  00022	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR _replaceLength$[esp+52], 0
  0002a	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  0002f	8b d8		 mov	 ebx, eax

; 361  : 	auto search  = get_amxstring(amx, params[arg_search] , 1, searchLength);

  00031	8d 44 24 20	 lea	 eax, DWORD PTR _searchLength$[esp+52]
  00035	50		 push	 eax
  00036	6a 01		 push	 1
  00038	ff 75 0c	 push	 DWORD PTR [ebp+12]
  0003b	57		 push	 edi
  0003c	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  00041	89 44 24 3c	 mov	 DWORD PTR _search$1$[esp+68], eax

; 362  : 	auto replace = get_amxstring(amx, params[arg_replace], 2, replaceLength);

  00045	8d 44 24 34	 lea	 eax, DWORD PTR _replaceLength$[esp+68]
  00049	50		 push	 eax
  0004a	6a 02		 push	 2
  0004c	ff 75 10	 push	 DWORD PTR [ebp+16]
  0004f	57		 push	 edi
  00050	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring

; 363  : 
; 364  : 	auto textMaxLength = params[arg_maxlength];
; 365  : 	auto caseSensitive = params[arg_casesensitive] != 0;
; 366  : 
; 367  : 	if (params[arg_searchlen]  != -1) { searchLength  = params[arg_searchlen]; }

  00055	8b 74 24 40	 mov	 esi, DWORD PTR _searchLength$[esp+84]
  00059	83 c4 30	 add	 esp, 48			; 00000030H
  0005c	83 7d 1c 00	 cmp	 DWORD PTR [ebp+28], 0

; 368  : 	if (params[arg_replacelen] != -1) { replaceLength = params[arg_replacelen]; }

  00060	8b 4c 24 14	 mov	 ecx, DWORD PTR _replaceLength$[esp+36]
  00064	8b 55 08	 mov	 edx, DWORD PTR [ebp+8]
  00067	0f 95 44 24 2c	 setne	 BYTE PTR _caseSensitive$[esp+32]
  0006c	83 7d 14 ff	 cmp	 DWORD PTR [ebp+20], -1
  00070	89 54 24 20	 mov	 DWORD PTR _textMaxLength$1$[esp+36], edx
  00074	0f 45 75 14	 cmovne	 esi, DWORD PTR [ebp+20]
  00078	83 7d 18 ff	 cmp	 DWORD PTR [ebp+24], -1
  0007c	0f 45 4d 18	 cmovne	 ecx, DWORD PTR [ebp+24]

; 369  : 
; 370  : 	if (searchLength <= 0)

  00080	85 f6		 test	 esi, esi
  00082	7f 1b		 jg	 SHORT $LN4@replace_st

; 371  : 	{
; 372  : 		LogError(amx, AMX_ERR_NATIVE, "Cannot replace searches of empty strings.");

  00084	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IBLGDDPF@Cannot?5replace?5searches?5of?5empty@
  00089	6a 0a		 push	 10			; 0000000aH
  0008b	57		 push	 edi
  0008c	e8 00 00 00 00	 call	 _LogError
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@replace_st:

; 373  : 		return -1;

  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5d		 pop	 ebp
  00097	83 c8 ff	 or	 eax, -1
  0009a	5b		 pop	 ebx

; 386  : }

  0009b	83 c4 14	 add	 esp, 20			; 00000014H
  0009e	c3		 ret	 0
$LN4@replace_st:

; 374  : 	}
; 375  : 
; 376  : 	auto ptr = UTIL_ReplaceEx(text, textMaxLength + 1, search, searchLength, replace, replaceLength, caseSensitive); // + EOS

  0009f	ff 74 24 2c	 push	 DWORD PTR _caseSensitive$[esp+32]
  000a3	51		 push	 ecx
  000a4	50		 push	 eax
  000a5	56		 push	 esi
  000a6	ff 74 24 2c	 push	 DWORD PTR _search$1$[esp+52]
  000aa	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  000ad	50		 push	 eax
  000ae	53		 push	 ebx
  000af	e8 00 00 00 00	 call	 ?UTIL_ReplaceEx@@YAPADPADIPBDI1I_N@Z ; UTIL_ReplaceEx
  000b4	8b f0		 mov	 esi, eax
  000b6	83 c4 1c	 add	 esp, 28			; 0000001cH

; 377  : 
; 378  : 	if (!ptr)

  000b9	85 f6		 test	 esi, esi
  000bb	74 d7		 je	 SHORT $LN7@replace_st

; 379  : 	{
; 380  : 		return -1;
; 381  : 	}
; 382  : 
; 383  : 	set_amxstring(amx, params[arg_text], text, textMaxLength);

  000bd	ff 74 24 20	 push	 DWORD PTR _textMaxLength$1$[esp+36]
  000c1	53		 push	 ebx
  000c2	ff 75 04	 push	 DWORD PTR [ebp+4]
  000c5	57		 push	 edi
  000c6	e8 00 00 00 00	 call	 ?set_amxstring@@YAHPAUtagAMX@@HPBDH@Z ; set_amxstring
  000cb	83 c4 10	 add	 esp, 16			; 00000010H

; 384  : 
; 385  : 	return ptr - text;

  000ce	2b f3		 sub	 esi, ebx
  000d0	8b c6		 mov	 eax, esi
  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	5d		 pop	 ebp
  000d5	5b		 pop	 ebx

; 386  : }

  000d6	83 c4 14	 add	 esp, 20			; 00000014H
  000d9	c3		 ret	 0
?replace_stringex@@YAHPAUtagAMX@@PAH@Z ENDP		; replace_stringex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?replace_string@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_replaceLength$ = -12					; size = 4
_searchLength$ = -8					; size = 4
_textMaxLength$1$ = -4					; size = 4
_amx$ = 8						; size = 4
_caseSensitive$ = 12					; size = 1
_textLength$ = 12					; size = 4
_params$ = 12						; size = 4
?replace_string@@YAHPAUtagAMX@@PAH@Z PROC		; replace_string, COMDAT

; 324  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx

; 325  : 	enum args { arg_count, arg_text, arg_maxlength, arg_search, arg_replace, arg_casesensitive };
; 326  : 
; 327  : 	auto textLength    = 0;
; 328  : 	auto searchLength  = 0;
; 329  : 	auto replaceLength = 0;
; 330  : 
; 331  : 	auto text    = get_amxstring(amx, params[arg_text]   , 0, textLength);

  00004	8b 5c 24 18	 mov	 ebx, DWORD PTR _params$[esp+12]
  00008	8d 44 24 18	 lea	 eax, DWORD PTR _textLength$[esp+12]
  0000c	55		 push	 ebp
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b 7c 24 20	 mov	 edi, DWORD PTR _amx$[esp+24]
  00013	50		 push	 eax
  00014	6a 00		 push	 0
  00016	ff 73 04	 push	 DWORD PTR [ebx+4]
  00019	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _searchLength$[esp+40], 0
  00021	57		 push	 edi
  00022	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR _replaceLength$[esp+44], 0
  0002a	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  0002f	8b e8		 mov	 ebp, eax

; 332  : 	auto search  = get_amxstring(amx, params[arg_search] , 1, searchLength);

  00031	8d 44 24 24	 lea	 eax, DWORD PTR _searchLength$[esp+44]
  00035	50		 push	 eax
  00036	6a 01		 push	 1
  00038	ff 73 0c	 push	 DWORD PTR [ebx+12]
  0003b	57		 push	 edi
  0003c	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  00041	8b f0		 mov	 esi, eax

; 333  : 	auto replace = get_amxstring(amx, params[arg_replace], 2, replaceLength);

  00043	8d 44 24 30	 lea	 eax, DWORD PTR _replaceLength$[esp+60]
  00047	50		 push	 eax
  00048	6a 02		 push	 2
  0004a	ff 73 10	 push	 DWORD PTR [ebx+16]
  0004d	57		 push	 edi
  0004e	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  00053	83 c4 30	 add	 esp, 48			; 00000030H
  00056	8b c8		 mov	 ecx, eax

; 334  : 
; 335  : 	auto textMaxLength = params[arg_maxlength];
; 336  : 	auto caseSensitive = params[arg_casesensitive] != 0;

  00058	83 7b 14 00	 cmp	 DWORD PTR [ebx+20], 0
  0005c	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0005f	0f 95 44 24 24	 setne	 BYTE PTR _caseSensitive$[esp+24]
  00064	89 44 24 18	 mov	 DWORD PTR _textMaxLength$1$[esp+28], eax

; 337  : 
; 338  : 	if (!*search)

  00068	80 3e 00	 cmp	 BYTE PTR [esi], 0
  0006b	75 1b		 jne	 SHORT $LN2@replace_st

; 339  : 	{
; 340  : 		LogError(amx, AMX_ERR_NATIVE, "Cannot replace searches of empty strings.");

  0006d	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IBLGDDPF@Cannot?5replace?5searches?5of?5empty@
  00072	6a 0a		 push	 10			; 0000000aH
  00074	57		 push	 edi
  00075	e8 00 00 00 00	 call	 _LogError
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 341  : 		return -1;

  0007d	83 c8 ff	 or	 eax, -1
  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5d		 pop	 ebp
  00083	5b		 pop	 ebx

; 349  : }

  00084	83 c4 0c	 add	 esp, 12			; 0000000cH
  00087	c3		 ret	 0
$LN2@replace_st:

; 342  : 	}
; 343  : 
; 344  : 	auto count = UTIL_ReplaceAll(text, textMaxLength + 1, search, searchLength, replace, replaceLength, caseSensitive); // + EOS

  00088	ff 74 24 24	 push	 DWORD PTR _caseSensitive$[esp+24]
  0008c	40		 inc	 eax
  0008d	ff 74 24 14	 push	 DWORD PTR _replaceLength$[esp+32]
  00091	51		 push	 ecx
  00092	ff 74 24 20	 push	 DWORD PTR _searchLength$[esp+40]
  00096	56		 push	 esi
  00097	50		 push	 eax
  00098	55		 push	 ebp
  00099	e8 00 00 00 00	 call	 ?UTIL_ReplaceAll@@YAIPADIPBDI1I_N@Z ; UTIL_ReplaceAll

; 345  : 
; 346  : 	set_amxstring(amx, params[arg_text], text, textMaxLength);

  0009e	ff 74 24 34	 push	 DWORD PTR _textMaxLength$1$[esp+56]
  000a2	8b f0		 mov	 esi, eax
  000a4	55		 push	 ebp
  000a5	ff 73 04	 push	 DWORD PTR [ebx+4]
  000a8	57		 push	 edi
  000a9	e8 00 00 00 00	 call	 ?set_amxstring@@YAHPAUtagAMX@@HPBDH@Z ; set_amxstring
  000ae	83 c4 2c	 add	 esp, 44			; 0000002cH

; 347  : 
; 348  : 	return count;

  000b1	8b c6		 mov	 eax, esi
  000b3	5f		 pop	 edi
  000b4	5e		 pop	 esi
  000b5	5d		 pop	 ebp
  000b6	5b		 pop	 ebx

; 349  : }

  000b7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ba	c3		 ret	 0
?replace_string@@YAHPAUtagAMX@@PAH@Z ENDP		; replace_string
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?replace@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_len$1$ = -24						; size = 4
tv250 = -20						; size = 4
_textLen$1$ = -16					; size = 4
_whatLen$1$ = -12					; size = 4
_with$1$ = -8						; size = 4
tv249 = -4						; size = 4
_amx$ = 8						; size = 4
_withLen$1$ = 12					; size = 4
_params$ = 12						; size = 4
?replace@@YAHPAUtagAMX@@PAH@Z PROC			; replace, COMDAT

; 274  : {

  00000	83 ec 18	 sub	 esp, 24			; 00000018H
  00003	53		 push	 ebx

; 275  : 	cell *text = get_amxaddr(amx, params[1]);

  00004	8b 5c 24 20	 mov	 ebx, DWORD PTR _amx$[esp+24]
  00008	55		 push	 ebp
  00009	56		 push	 esi
  0000a	8b 74 24 2c	 mov	 esi, DWORD PTR _params$[esp+32]
  0000e	57		 push	 edi
  0000f	ff 76 04	 push	 DWORD PTR [esi+4]
  00012	53		 push	 ebx
  00013	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 276  : 	cell len = params[2];
; 277  : 	cell *what = get_amxaddr(amx, params[3]);

  00018	ff 76 0c	 push	 DWORD PTR [esi+12]
  0001b	8b f8		 mov	 edi, eax
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	53		 push	 ebx
  00021	89 44 24 20	 mov	 DWORD PTR _len$1$[esp+56], eax
  00025	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 278  : 	cell *with = get_amxaddr(amx, params[4]);

  0002a	ff 76 10	 push	 DWORD PTR [esi+16]
  0002d	8b e8		 mov	 ebp, eax
  0002f	53		 push	 ebx
  00030	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 279  : 	cell *textptr = text;
; 280  : 
; 281  : 	int withLen = amxstring_len(with);

  00035	50		 push	 eax
  00036	89 44 24 3c	 mov	 DWORD PTR _with$1$[esp+68], eax
  0003a	e8 00 00 00 00	 call	 ?amxstring_len@@YAHPAH@Z ; amxstring_len

; 282  : 	int whatLen = amxstring_len(what);

  0003f	55		 push	 ebp
  00040	89 44 24 50	 mov	 DWORD PTR _withLen$1$[esp+68], eax
  00044	e8 00 00 00 00	 call	 ?amxstring_len@@YAHPAH@Z ; amxstring_len
  00049	8b f0		 mov	 esi, eax

; 283  : 	int textLen = amxstring_len(text);

  0004b	57		 push	 edi
  0004c	89 74 24 40	 mov	 DWORD PTR _whatLen$1$[esp+76], esi
  00050	e8 00 00 00 00	 call	 ?amxstring_len@@YAHPAH@Z ; amxstring_len
  00055	83 c4 24	 add	 esp, 36			; 00000024H
  00058	89 44 24 18	 mov	 DWORD PTR _textLen$1$[esp+40], eax

; 284  : 
; 285  : 	if (whatLen > textLen)

  0005c	3b f0		 cmp	 esi, eax
  0005e	7f 15		 jg	 SHORT $LN15@replace

; 286  : 		return 0;
; 287  : 
; 288  : 	if (whatLen < 1)

  00060	83 fe 01	 cmp	 esi, 1
  00063	7d 1a		 jge	 SHORT $LN5@replace

; 289  : 	{
; 290  : 		LogError(amx, AMX_ERR_NATIVE, "No search string specified.");

  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@KJALMONH@No?5search?5string?5specified?4?$AA@
  0006a	6a 0a		 push	 10			; 0000000aH
  0006c	53		 push	 ebx
  0006d	e8 00 00 00 00	 call	 _LogError
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@replace:

; 317  : 	}
; 318  : 	
; 319  : 	return 0;

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5d		 pop	 ebp
  00078	33 c0		 xor	 eax, eax
  0007a	5b		 pop	 ebx

; 320  : }

  0007b	83 c4 18	 add	 esp, 24			; 00000018H
  0007e	c3		 ret	 0
$LN5@replace:

; 291  : 		return 0;
; 292  : 	}
; 293  : 
; 294  : 	if (textLen - whatLen + withLen > len)

  0007f	8b 54 24 30	 mov	 edx, DWORD PTR _withLen$1$[esp+36]
  00083	8b c8		 mov	 ecx, eax
  00085	8b 44 24 10	 mov	 eax, DWORD PTR _len$1$[esp+40]
  00089	2b ce		 sub	 ecx, esi
  0008b	03 d1		 add	 edx, ecx
  0008d	89 4c 24 14	 mov	 DWORD PTR tv250[esp+40], ecx
  00091	89 54 24 24	 mov	 DWORD PTR tv249[esp+40], edx
  00095	3b d0		 cmp	 edx, eax
  00097	7e 1c		 jle	 SHORT $LN6@replace

; 295  : 	{
; 296  : 		LogError(amx, AMX_ERR_NATIVE, "replace() buffer not big enough (%d>=%d)", (textLen - whatLen + withLen), len);

  00099	50		 push	 eax
  0009a	52		 push	 edx
  0009b	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@NFNJDNGL@replace?$CI?$CJ?5buffer?5not?5big?5enough?5@
  000a0	6a 0a		 push	 10			; 0000000aH
  000a2	53		 push	 ebx
  000a3	e8 00 00 00 00	 call	 _LogError
  000a8	83 c4 14	 add	 esp, 20			; 00000014H

; 317  : 	}
; 318  : 	
; 319  : 	return 0;

  000ab	33 c0		 xor	 eax, eax
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5d		 pop	 ebp
  000b0	5b		 pop	 ebx

; 320  : }

  000b1	83 c4 18	 add	 esp, 24			; 00000018H
  000b4	c3		 ret	 0
$LN6@replace:

; 297  : 		return 0;
; 298  : 	}
; 299  : 
; 300  : 	cell browsed = 0;
; 301  : 	while (*text && (browsed <= (textLen-whatLen)))

  000b5	8b 07		 mov	 eax, DWORD PTR [edi]
  000b7	33 db		 xor	 ebx, ebx
  000b9	85 c0		 test	 eax, eax
  000bb	74 b8		 je	 SHORT $LN15@replace
  000bd	0f 1f 00	 npad	 3
$LL2@replace:
  000c0	3b d9		 cmp	 ebx, ecx
  000c2	7f b1		 jg	 SHORT $LN15@replace

; 302  : 	{
; 303  : 		if (*text == *what)

  000c4	3b 45 00	 cmp	 eax, DWORD PTR [ebp]
  000c7	75 13		 jne	 SHORT $LN8@replace

; 304  : 		{
; 305  : 			if (fastcellcmp(text, what, whatLen))

  000c9	56		 push	 esi
  000ca	55		 push	 ebp
  000cb	57		 push	 edi
  000cc	e8 00 00 00 00	 call	 ?fastcellcmp@@YA_NPAH0H@Z ; fastcellcmp
  000d1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d4	84 c0		 test	 al, al
  000d6	75 17		 jne	 SHORT $LN11@replace
  000d8	8b 4c 24 14	 mov	 ecx, DWORD PTR tv250[esp+40]
$LN8@replace:

; 297  : 		return 0;
; 298  : 	}
; 299  : 
; 300  : 	cell browsed = 0;
; 301  : 	while (*text && (browsed <= (textLen-whatLen)))

  000dc	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 313  : 			}
; 314  : 		}
; 315  : 		text++;

  000df	83 c7 04	 add	 edi, 4

; 316  : 		browsed++;

  000e2	43		 inc	 ebx
  000e3	85 c0		 test	 eax, eax
  000e5	75 d9		 jne	 SHORT $LL2@replace
  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi
  000e9	5d		 pop	 ebp
  000ea	5b		 pop	 ebx

; 320  : }

  000eb	83 c4 18	 add	 esp, 24			; 00000018H
  000ee	c3		 ret	 0
$LN11@replace:

; 306  : 			{
; 307  : 				cell *saveptr = text + whatLen;
; 308  : 				cell restlen = textLen - (browsed + whatLen);
; 309  : 				textptr = text + withLen;

  000ef	8b 44 24 30	 mov	 eax, DWORD PTR _withLen$1$[esp+36]

; 310  : 				memmove(textptr, saveptr, (restlen + 1) * sizeof(cell));

  000f3	8b 4c 24 1c	 mov	 ecx, DWORD PTR _whatLen$1$[esp+40]
  000f7	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  000fe	8b 44 24 18	 mov	 eax, DWORD PTR _textLen$1$[esp+40]
  00102	2b c3		 sub	 eax, ebx
  00104	2b c1		 sub	 eax, ecx
  00106	8d 04 85 04 00
	00 00		 lea	 eax, DWORD PTR [eax*4+4]
  0010d	50		 push	 eax
  0010e	8d 04 8f	 lea	 eax, DWORD PTR [edi+ecx*4]
  00111	50		 push	 eax
  00112	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]
  00115	51		 push	 ecx
  00116	e8 00 00 00 00	 call	 _memmove

; 311  : 				memcpy(text, with, withLen * sizeof(cell));

  0011b	56		 push	 esi
  0011c	ff 74 24 30	 push	 DWORD PTR _with$1$[esp+56]
  00120	57		 push	 edi
  00121	e8 00 00 00 00	 call	 _memcpy

; 312  : 				return (textLen - whatLen + withLen);

  00126	8b 44 24 3c	 mov	 eax, DWORD PTR tv249[esp+64]
  0012a	83 c4 18	 add	 esp, 24			; 00000018H
  0012d	5f		 pop	 edi
  0012e	5e		 pop	 esi
  0012f	5d		 pop	 ebp
  00130	5b		 pop	 ebx

; 320  : }

  00131	83 c4 18	 add	 esp, 24			; 00000018H
  00134	c3		 ret	 0
?replace@@YAHPAUtagAMX@@PAH@Z ENDP			; replace
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?fastcellcmp@@YA_NPAH0H@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_len$ = 16						; size = 4
?fastcellcmp@@YA_NPAH0H@Z PROC				; fastcellcmp, COMDAT

; 263  : {

  00000	56		 push	 esi

; 264  : 	while (len--)

  00001	8b 74 24 10	 mov	 esi, DWORD PTR _len$[esp]
  00005	57		 push	 edi
  00006	85 f6		 test	 esi, esi
  00008	74 1c		 je	 SHORT $LN8@fastcellcm
  0000a	8b 7c 24 0c	 mov	 edi, DWORD PTR _a$[esp+4]
  0000e	8b 54 24 10	 mov	 edx, DWORD PTR _b$[esp+4]
  00012	2b fa		 sub	 edi, edx
$LL2@fastcellcm:

; 265  : 	{
; 266  : 		if (*a++ != *b++)

  00014	8b 0c 17	 mov	 ecx, DWORD PTR [edi+edx]
  00017	8d 52 04	 lea	 edx, DWORD PTR [edx+4]
  0001a	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  0001d	4e		 dec	 esi
  0001e	3b c8		 cmp	 ecx, eax
  00020	75 09		 jne	 SHORT $LN7@fastcellcm

; 264  : 	while (len--)

  00022	85 f6		 test	 esi, esi
  00024	75 ee		 jne	 SHORT $LL2@fastcellcm
$LN8@fastcellcm:
  00026	5f		 pop	 edi

; 268  : 	}
; 269  : 
; 270  : 	return true;

  00027	b0 01		 mov	 al, 1
  00029	5e		 pop	 esi

; 271  : }

  0002a	c3		 ret	 0
$LN7@fastcellcm:
  0002b	5f		 pop	 edi

; 267  : 			return false;

  0002c	32 c0		 xor	 al, al
  0002e	5e		 pop	 esi

; 271  : }

  0002f	c3		 ret	 0
?fastcellcmp@@YA_NPAH0H@Z ENDP				; fastcellcmp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?parse_arg@@YAPADPAPADAAH@Z
_TEXT	SEGMENT
_line$ = 8						; size = 4
_state$ = 12						; size = 4
?parse_arg@@YAPADPAPADAAH@Z PROC			; parse_arg, COMDAT

; 224  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 225  : 	static char arg[3072];
; 226  : 	char* dest = arg;
; 227  : 	state = 0;
; 228  : 	
; 229  : 	while (**line)

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR _line$[esp+4]
  00006	bb 00 00 00 00	 mov	 ebx, OFFSET ?arg@?1??parse_arg@@YAPADPAPADAAH@Z@4PADA
  0000b	57		 push	 edi
  0000c	8b 7c 24 14	 mov	 edi, DWORD PTR _state$[esp+8]
  00010	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	80 38 00	 cmp	 BYTE PTR [eax], 0
  0001b	74 4f		 je	 SHORT $LN22@parse_arg
  0001d	0f 1f 00	 npad	 3
$LL2@parse_arg:

; 230  : 	{
; 231  : 		if (utf8isspace(*line))

  00020	ff 36		 push	 DWORD PTR [esi]
  00022	e8 00 00 00 00	 call	 ?utf8isspace@@YA_NPBD@Z	; utf8isspace
  00027	83 c4 04	 add	 esp, 4
  0002a	84 c0		 test	 al, al
  0002c	74 0d		 je	 SHORT $LN4@parse_arg

; 232  : 		{
; 233  : 			if (state == 1)

  0002e	8b 07		 mov	 eax, DWORD PTR [edi]
  00030	83 f8 01	 cmp	 eax, 1
  00033	74 37		 je	 SHORT $LN22@parse_arg

; 234  : 				break;
; 235  : 			else if (!state)

  00035	85 c0		 test	 eax, eax
  00037	75 0d		 jne	 SHORT $LN9@parse_arg

; 236  : 			{
; 237  : 				(*line)++;
; 238  : 				continue;

  00039	eb 28		 jmp	 SHORT $LN25@parse_arg
$LN4@parse_arg:

; 239  : 			}
; 240  : 		}
; 241  : 		else if (state != 2)

  0003b	83 3f 02	 cmp	 DWORD PTR [edi], 2
  0003e	74 06		 je	 SHORT $LN9@parse_arg

; 242  : 			state = 1;

  00040	c7 07 01 00 00
	00		 mov	 DWORD PTR [edi], 1
$LN9@parse_arg:

; 243  : 		
; 244  : 		if (**line == '"')

  00046	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00048	8a 01		 mov	 al, BYTE PTR [ecx]
  0004a	3c 22		 cmp	 al, 34			; 00000022H
  0004c	75 12		 jne	 SHORT $LN10@parse_arg

; 245  : 		{
; 246  : 			(*line)++;

  0004e	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00051	89 06		 mov	 DWORD PTR [esi], eax

; 247  : 			
; 248  : 			if (state == 2)

  00053	83 3f 02	 cmp	 DWORD PTR [edi], 2
  00056	74 14		 je	 SHORT $LN22@parse_arg

; 249  : 				break;
; 250  : 			
; 251  : 			state = 2;

  00058	c7 07 02 00 00
	00		 mov	 DWORD PTR [edi], 2

; 252  : 			continue;

  0005e	eb 05		 jmp	 SHORT $LN18@parse_arg
$LN10@parse_arg:

; 253  : 		}
; 254  : 		
; 255  : 		*dest++ = *(*line)++;

  00060	88 03		 mov	 BYTE PTR [ebx], al
  00062	43		 inc	 ebx
$LN25@parse_arg:
  00063	ff 06		 inc	 DWORD PTR [esi]
$LN18@parse_arg:

; 225  : 	static char arg[3072];
; 226  : 	char* dest = arg;
; 227  : 	state = 0;
; 228  : 	
; 229  : 	while (**line)

  00065	8b 06		 mov	 eax, DWORD PTR [esi]
  00067	80 38 00	 cmp	 BYTE PTR [eax], 0
  0006a	75 b4		 jne	 SHORT $LL2@parse_arg
$LN22@parse_arg:
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi

; 256  : 	}
; 257  : 	
; 258  : 	*dest = '\0';

  0006e	c6 03 00	 mov	 BYTE PTR [ebx], 0

; 259  : 	return arg;

  00071	b8 00 00 00 00	 mov	 eax, OFFSET ?arg@?1??parse_arg@@YAPADPAPADAAH@Z@4PADA
  00076	5b		 pop	 ebx

; 260  : }

  00077	c3		 ret	 0
?parse_arg@@YAPADPAPADAAH@Z ENDP			; parse_arg
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?utf8getspaces@@YAIPBD@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?utf8getspaces@@YAIPBD@Z PROC				; utf8getspaces, COMDAT

; 220  : 	return utf8iscategory(string, SIZE_MAX, UTF8_CATEGORY_ISSPACE);

  00000	68 00 00 40 40	 push	 1077936128		; 40400000H
  00005	6a ff		 push	 -1
  00007	ff 74 24 0c	 push	 DWORD PTR _string$[esp+4]
  0000b	e8 00 00 00 00	 call	 _utf8iscategory
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH

; 221  : }

  00013	c3		 ret	 0
?utf8getspaces@@YAIPBD@Z ENDP				; utf8getspaces
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?utf8isspace@@YA_NPBD@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?utf8isspace@@YA_NPBD@Z PROC				; utf8isspace, COMDAT

; 215  : 	return utf8iscategory(string, 1, UTF8_CATEGORY_ISSPACE) != 0;

  00000	68 00 00 40 40	 push	 1077936128		; 40400000H
  00005	6a 01		 push	 1
  00007	ff 74 24 0c	 push	 DWORD PTR _string$[esp+4]
  0000b	e8 00 00 00 00	 call	 _utf8iscategory
  00010	83 c4 0c	 add	 esp, 12			; 0000000cH
  00013	f7 d8		 neg	 eax
  00015	1b c0		 sbb	 eax, eax
  00017	f7 d8		 neg	 eax

; 216  : }

  00019	c3		 ret	 0
?utf8isspace@@YA_NPBD@Z ENDP				; utf8isspace
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?get_amxbuffer@@YAPADH@Z
_TEXT	SEGMENT
_id$ = 8						; size = 4
?get_amxbuffer@@YAPADH@Z PROC				; get_amxbuffer, COMDAT

; 175  : 	static char buffer[4][MAX_BUFFER_LENGTH];
; 176  : 	return buffer[id];

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _id$[esp-4]
  00004	c1 e0 0e	 shl	 eax, 14			; 0000000eH
  00007	05 00 00 00 00	 add	 eax, OFFSET ?buffer@?1??get_amxbuffer@@YAPADH@Z@4PAY0EAAA@DA

; 177  : }

  0000c	c3		 ret	 0
?get_amxbuffer@@YAPADH@Z ENDP				; get_amxbuffer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_amx_addr$ = 12						; size = 4
_source$ = 16						; size = 4
_sourcelen$ = 20					; size = 4
_maxlen$ = 24						; size = 4
??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z PROC	; set_amxstring_utf8<char>, COMDAT

; 111  : 	size_t len = sourcelen;
; 112  : 	bool needtocheck = false;
; 113  : 
; 114  : 	register cell* dest = (cell *)(amx->base + (int)(((AMX_HEADER *)amx->base)->dat + amx_addr));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _amx$[esp-4]
  00004	53		 push	 ebx
  00005	55		 push	 ebp
  00006	8b 6c 24 1c	 mov	 ebp, DWORD PTR _maxlen$[esp+4]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	56		 push	 esi
  0000d	8b f5		 mov	 esi, ebp
  0000f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00012	03 c8		 add	 ecx, eax
  00014	8b 44 24 1c	 mov	 eax, DWORD PTR _sourcelen$[esp+8]
  00018	03 4c 24 14	 add	 ecx, DWORD PTR _amx_addr$[esp+8]
  0001c	3b c5		 cmp	 eax, ebp

; 115  : 	register cell* start = dest;

  0001e	8b d9		 mov	 ebx, ecx
  00020	0f 46 f0	 cmovbe	 esi, eax

; 116  : 
; 117  : 	if (len > maxlen)
; 118  : 	{
; 119  : 		len = maxlen;
; 120  : 		needtocheck = true;
; 121  : 	}
; 122  : 
; 123  : 	maxlen = len;

  00023	8b d6		 mov	 edx, esi

; 124  : 
; 125  : 	while (maxlen-- && *source)

  00025	85 d2		 test	 edx, edx
  00027	74 20		 je	 SHORT $LN8@set_amxstr
  00029	57		 push	 edi
  0002a	8b 7c 24 1c	 mov	 edi, DWORD PTR _source$[esp+12]
  0002e	66 90		 npad	 2
$LL2@set_amxstr:
  00030	8a 07		 mov	 al, BYTE PTR [edi]
  00032	4a		 dec	 edx
  00033	84 c0		 test	 al, al
  00035	74 0d		 je	 SHORT $LN14@set_amxstr

; 126  : 	{
; 127  : 		*dest++ = *(unsigned char*)source++;

  00037	0f b6 c0	 movzx	 eax, al
  0003a	47		 inc	 edi
  0003b	89 01		 mov	 DWORD PTR [ecx], eax
  0003d	83 c1 04	 add	 ecx, 4
  00040	85 d2		 test	 edx, edx
  00042	75 ec		 jne	 SHORT $LL2@set_amxstr
$LN14@set_amxstr:
  00044	8b 44 24 20	 mov	 eax, DWORD PTR _sourcelen$[esp+12]
  00048	5f		 pop	 edi
$LN8@set_amxstr:
  00049	3b c5		 cmp	 eax, ebp

; 128  : 	}
; 129  : 
; 130  : 	if (needtocheck && (start[len - 1] & 1 << 7))

  0004b	76 17		 jbe	 SHORT $LN12@set_amxstr
  0004d	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  00050	f6 04 83 80	 test	 BYTE PTR [ebx+eax*4], 128 ; 00000080H
  00054	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  00057	74 0b		 je	 SHORT $LN12@set_amxstr

; 131  : 	{
; 132  : 		len -= UTIL_CheckValidChar(start + len - 1);

  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ??$UTIL_CheckValidChar@H@@YAHPAH@Z ; UTIL_CheckValidChar<int>
  0005f	83 c4 04	 add	 esp, 4
  00062	2b f0		 sub	 esi, eax
$LN12@set_amxstr:

; 133  : 	}
; 134  : 
; 135  : 	start[len] = '\0';

  00064	c7 04 b3 00 00
	00 00		 mov	 DWORD PTR [ebx+esi*4], 0

; 136  : 
; 137  : 	return len;

  0006b	8b c6		 mov	 eax, esi
  0006d	5e		 pop	 esi
  0006e	5d		 pop	 ebp
  0006f	5b		 pop	 ebx

; 138  : }

  00070	c3		 ret	 0
??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z ENDP	; set_amxstring_utf8<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ??$set_amxstring_utf8@H@@YAHPAUtagAMX@@HPBHII@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_amx_addr$ = 12						; size = 4
_source$ = 16						; size = 4
_sourcelen$ = 20					; size = 4
_maxlen$ = 24						; size = 4
??$set_amxstring_utf8@H@@YAHPAUtagAMX@@HPBHII@Z PROC	; set_amxstring_utf8<int>, COMDAT

; 111  : 	size_t len = sourcelen;
; 112  : 	bool needtocheck = false;
; 113  : 
; 114  : 	register cell* dest = (cell *)(amx->base + (int)(((AMX_HEADER *)amx->base)->dat + amx_addr));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _amx$[esp-4]
  00004	53		 push	 ebx
  00005	55		 push	 ebp
  00006	8b 6c 24 1c	 mov	 ebp, DWORD PTR _maxlen$[esp+4]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	56		 push	 esi
  0000d	8b f5		 mov	 esi, ebp
  0000f	57		 push	 edi
  00010	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00013	03 d0		 add	 edx, eax
  00015	8b 44 24 20	 mov	 eax, DWORD PTR _sourcelen$[esp+12]
  00019	03 54 24 18	 add	 edx, DWORD PTR _amx_addr$[esp+12]
  0001d	3b c5		 cmp	 eax, ebp

; 115  : 	register cell* start = dest;

  0001f	8b da		 mov	 ebx, edx
  00021	0f 46 f0	 cmovbe	 esi, eax

; 116  : 
; 117  : 	if (len > maxlen)
; 118  : 	{
; 119  : 		len = maxlen;
; 120  : 		needtocheck = true;
; 121  : 	}
; 122  : 
; 123  : 	maxlen = len;

  00024	8b fe		 mov	 edi, esi

; 124  : 
; 125  : 	while (maxlen-- && *source)

  00026	85 ff		 test	 edi, edi
  00028	74 1f		 je	 SHORT $LN8@set_amxstr
  0002a	8b 4c 24 1c	 mov	 ecx, DWORD PTR _source$[esp+12]
  0002e	66 90		 npad	 2
$LL2@set_amxstr:
  00030	4f		 dec	 edi
  00031	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00034	74 0f		 je	 SHORT $LN14@set_amxstr

; 126  : 	{
; 127  : 		*dest++ = *(unsigned char*)source++;

  00036	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00039	83 c1 04	 add	 ecx, 4
  0003c	89 02		 mov	 DWORD PTR [edx], eax
  0003e	83 c2 04	 add	 edx, 4
  00041	85 ff		 test	 edi, edi
  00043	75 eb		 jne	 SHORT $LL2@set_amxstr
$LN14@set_amxstr:
  00045	8b 44 24 20	 mov	 eax, DWORD PTR _sourcelen$[esp+12]
$LN8@set_amxstr:
  00049	3b c5		 cmp	 eax, ebp

; 128  : 	}
; 129  : 
; 130  : 	if (needtocheck && (start[len - 1] & 1 << 7))

  0004b	76 17		 jbe	 SHORT $LN12@set_amxstr
  0004d	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  00050	f6 04 83 80	 test	 BYTE PTR [ebx+eax*4], 128 ; 00000080H
  00054	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  00057	74 0b		 je	 SHORT $LN12@set_amxstr

; 131  : 	{
; 132  : 		len -= UTIL_CheckValidChar(start + len - 1);

  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ??$UTIL_CheckValidChar@H@@YAHPAH@Z ; UTIL_CheckValidChar<int>
  0005f	83 c4 04	 add	 esp, 4
  00062	2b f0		 sub	 esi, eax
$LN12@set_amxstr:

; 133  : 	}
; 134  : 
; 135  : 	start[len] = '\0';

  00064	5f		 pop	 edi
  00065	c7 04 b3 00 00
	00 00		 mov	 DWORD PTR [ebx+esi*4], 0

; 136  : 
; 137  : 	return len;

  0006c	8b c6		 mov	 eax, esi
  0006e	5e		 pop	 esi
  0006f	5d		 pop	 ebp
  00070	5b		 pop	 ebx

; 138  : }

  00071	c3		 ret	 0
??$set_amxstring_utf8@H@@YAHPAUtagAMX@@HPBHII@Z ENDP	; set_amxstring_utf8<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?copy_amxmemory@@YAXPAH0H@Z
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_len$ = 16						; size = 4
?copy_amxmemory@@YAXPAH0H@Z PROC			; copy_amxmemory, COMDAT

; 209  : 	while (len--)

  00000	8b 54 24 0c	 mov	 edx, DWORD PTR _len$[esp-4]
  00004	85 d2		 test	 edx, edx
  00006	74 1a		 je	 SHORT $LN6@copy_amxme
  00008	8b 44 24 08	 mov	 eax, DWORD PTR _src$[esp-4]
  0000c	56		 push	 esi
  0000d	8b 74 24 08	 mov	 esi, DWORD PTR _dest$[esp]
  00011	2b f0		 sub	 esi, eax
$LL2@copy_amxme:

; 210  : 		*dest++=*src++;

  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
  00015	8d 40 04	 lea	 eax, DWORD PTR [eax+4]
  00018	89 4c 06 fc	 mov	 DWORD PTR [esi+eax-4], ecx
  0001c	83 ea 01	 sub	 edx, 1
  0001f	75 f2		 jne	 SHORT $LL2@copy_amxme
  00021	5e		 pop	 esi
$LN6@copy_amxme:

; 211  : }

  00022	c3		 ret	 0
?copy_amxmemory@@YAXPAH0H@Z ENDP			; copy_amxmemory
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?set_amxstring_utf8_cell@@YAHPAUtagAMX@@HPBHII@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_amx_addr$ = 12						; size = 4
_source$ = 16						; size = 4
_sourcelen$ = 20					; size = 4
_maxlen$ = 24						; size = 4
?set_amxstring_utf8_cell@@YAHPAUtagAMX@@HPBHII@Z PROC	; set_amxstring_utf8_cell, COMDAT

; 147  : 	return set_amxstring_utf8(amx, amx_addr, source, sourcelen, maxlen);

  00000	e9 00 00 00 00	 jmp	 ??$set_amxstring_utf8@H@@YAHPAUtagAMX@@HPBHII@Z ; set_amxstring_utf8<int>
?set_amxstring_utf8_cell@@YAHPAUtagAMX@@HPBHII@Z ENDP	; set_amxstring_utf8_cell
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?set_amxstring_utf8_char@@YAHPAUtagAMX@@HPBDII@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_amx_addr$ = 12						; size = 4
_source$ = 16						; size = 4
_sourcelen$ = 20					; size = 4
_maxlen$ = 24						; size = 4
?set_amxstring_utf8_char@@YAHPAUtagAMX@@HPBDII@Z PROC	; set_amxstring_utf8_char, COMDAT

; 142  : 	return set_amxstring_utf8(amx, amx_addr, source, sourcelen, maxlen);

  00000	e9 00 00 00 00	 jmp	 ??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z ; set_amxstring_utf8<char>
?set_amxstring_utf8_char@@YAHPAUtagAMX@@HPBDII@Z ENDP	; set_amxstring_utf8_char
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?set_amxstring_simple@@YAHPAHPBDH@Z
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_source$ = 12						; size = 4
_max$ = 16						; size = 4
?set_amxstring_simple@@YAHPAHPBDH@Z PROC		; set_amxstring_simple, COMDAT

; 71   : 	cell* start = dest;
; 72   : 
; 73   : 	while (max-- && *source)

  00000	8b 54 24 0c	 mov	 edx, DWORD PTR _max$[esp-4]
  00004	8b 44 24 04	 mov	 eax, DWORD PTR _dest$[esp-4]
  00008	57		 push	 edi
  00009	8b f8		 mov	 edi, eax
  0000b	85 d2		 test	 edx, edx
  0000d	74 1a		 je	 SHORT $LN10@set_amxstr
  0000f	56		 push	 esi
  00010	8b 74 24 10	 mov	 esi, DWORD PTR _source$[esp+4]
$LL2@set_amxstr:
  00014	8a 0e		 mov	 cl, BYTE PTR [esi]
  00016	4a		 dec	 edx
  00017	84 c9		 test	 cl, cl
  00019	74 0d		 je	 SHORT $LN11@set_amxstr

; 74   : 	{
; 75   : 		*dest++ = (unsigned char)*source++;

  0001b	0f b6 c9	 movzx	 ecx, cl
  0001e	46		 inc	 esi
  0001f	89 08		 mov	 DWORD PTR [eax], ecx
  00021	83 c0 04	 add	 eax, 4
  00024	85 d2		 test	 edx, edx
  00026	75 ec		 jne	 SHORT $LL2@set_amxstr
$LN11@set_amxstr:
  00028	5e		 pop	 esi
$LN10@set_amxstr:

; 76   : 	}
; 77   : 
; 78   : 	*dest = 0;

  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 79   : 
; 80   : 	return dest - start;

  0002f	2b c7		 sub	 eax, edi
  00031	c1 f8 02	 sar	 eax, 2
  00034	5f		 pop	 edi

; 81   : }

  00035	c3		 ret	 0
?set_amxstring_simple@@YAHPAHPBDH@Z ENDP		; set_amxstring_simple
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?set_amxstring@@YAHPAUtagAMX@@HPBDH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_amx_addr$ = 12						; size = 4
_source$ = 16						; size = 4
_max$ = 20						; size = 4
?set_amxstring@@YAHPAUtagAMX@@HPBDH@Z PROC		; set_amxstring, COMDAT

; 85   : 	register cell* dest = (cell *)(amx->base + (int)(((AMX_HEADER *)amx->base)->dat + amx_addr));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _amx$[esp-4]

; 86   : 	register cell* start = dest;
; 87   : 
; 88   : #if defined BINLOG_ENABLED
; 89   : 	if (g_binlog_level & 2)
; 90   : 	{
; 91   : 		CPluginMngr::CPlugin *pl = g_plugins.findPluginFast(amx);
; 92   : 		if (pl)
; 93   : 			g_BinLog.WriteOp(BinLog_SetString, pl->getId(), amx_addr, max, source);
; 94   : 	}
; 95   : #endif
; 96   : 	
; 97   : 	while (max-- && *source)

  00004	8b 54 24 10	 mov	 edx, DWORD PTR _max$[esp-4]
  00008	57		 push	 edi
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0000e	03 c1		 add	 eax, ecx
  00010	03 44 24 0c	 add	 eax, DWORD PTR _amx_addr$[esp]
  00014	8b f8		 mov	 edi, eax
  00016	85 d2		 test	 edx, edx
  00018	74 1b		 je	 SHORT $LN10@set_amxstr
  0001a	56		 push	 esi
  0001b	8b 74 24 14	 mov	 esi, DWORD PTR _source$[esp+4]
  0001f	90		 npad	 1
$LL2@set_amxstr:
  00020	8a 0e		 mov	 cl, BYTE PTR [esi]
  00022	4a		 dec	 edx
  00023	84 c9		 test	 cl, cl
  00025	74 0d		 je	 SHORT $LN11@set_amxstr

; 98   : 		*dest++ = (unsigned char)*source++;

  00027	0f b6 c9	 movzx	 ecx, cl
  0002a	46		 inc	 esi
  0002b	89 08		 mov	 DWORD PTR [eax], ecx
  0002d	83 c0 04	 add	 eax, 4
  00030	85 d2		 test	 edx, edx
  00032	75 ec		 jne	 SHORT $LL2@set_amxstr
$LN11@set_amxstr:
  00034	5e		 pop	 esi
$LN10@set_amxstr:

; 99   : 	
; 100  : 	*dest = 0;

  00035	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 101  : 	
; 102  : 	return dest - start;

  0003b	2b c7		 sub	 eax, edi
  0003d	c1 f8 02	 sar	 eax, 2
  00040	5f		 pop	 edi

; 103  : }

  00041	c3		 ret	 0
?set_amxstring@@YAHPAUtagAMX@@HPBDH@Z ENDP		; set_amxstring
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?amxstring_len@@YAHPAH@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?amxstring_len@@YAHPAH@Z PROC				; amxstring_len, COMDAT

; 56   : 	register int c = 0;
; 57   : 
; 58   : 	while (a[c])

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _a$[esp-4]
  00004	33 c0		 xor	 eax, eax
  00006	39 01		 cmp	 DWORD PTR [ecx], eax
  00008	74 0d		 je	 SHORT $LN3@amxstring_
  0000a	66 0f 1f 44 00
	00		 npad	 6
$LL2@amxstring_:

; 59   : 		++c;

  00010	40		 inc	 eax
  00011	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  00015	75 f9		 jne	 SHORT $LL2@amxstring_
$LN3@amxstring_:

; 60   : 	
; 61   : 	return c;
; 62   : }

  00017	c3		 ret	 0
?amxstring_len@@YAHPAH@Z ENDP				; amxstring_len
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT _get_amxstring_r
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_amx_addr$ = 12						; size = 4
_destination$ = 16					; size = 4
_maxlen$ = 20						; size = 4
_get_amxstring_r PROC					; COMDAT

; 152  : 	register cell *source = (cell *)(amx->base + (int)(((AMX_HEADER *)amx->base)->dat + amx_addr));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _amx$[esp-4]

; 153  : 	register char *dest = destination;

  00004	8b 54 24 0c	 mov	 edx, DWORD PTR _destination$[esp-4]
  00008	56		 push	 esi

; 154  : 	char *start = dest;
; 155  : 
; 156  : 	while (maxlen-- && *source)

  00009	8b 74 24 14	 mov	 esi, DWORD PTR _maxlen$[esp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00012	03 c8		 add	 ecx, eax
  00014	03 4c 24 0c	 add	 ecx, DWORD PTR _amx_addr$[esp]
  00018	85 f6		 test	 esi, esi
  0001a	74 16		 je	 SHORT $LN10@get_amxstr
  0001c	0f 1f 40 00	 npad	 4
$LL2@get_amxstr:
  00020	4e		 dec	 esi
  00021	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00024	74 0c		 je	 SHORT $LN10@get_amxstr

; 157  : 		*dest++=(char)(*source++);

  00026	8a 01		 mov	 al, BYTE PTR [ecx]
  00028	83 c1 04	 add	 ecx, 4
  0002b	88 02		 mov	 BYTE PTR [edx], al
  0002d	42		 inc	 edx
  0002e	85 f6		 test	 esi, esi
  00030	75 ee		 jne	 SHORT $LL2@get_amxstr
$LN10@get_amxstr:

; 158  : 
; 159  : 	*dest = '\0';

  00032	c6 02 00	 mov	 BYTE PTR [edx], 0

; 160  : 
; 161  : #if defined BINLOG_ENABLED
; 162  : 	if (g_binlog_level & 2)
; 163  : 	{
; 164  : 		CPluginMngr::CPlugin *pl = g_plugins.findPluginFast(amx);
; 165  : 		if (pl)
; 166  : 			g_BinLog.WriteOp(BinLog_GetString, pl->getId(), amx_addr, destination);
; 167  : 	}
; 168  : #endif
; 169  : 
; 170  : 	return dest - start;

  00035	2b 54 24 10	 sub	 edx, DWORD PTR _destination$[esp]
  00039	8b c2		 mov	 eax, edx
  0003b	5e		 pop	 esi

; 171  : }

  0003c	c3		 ret	 0
_get_amxstring_r ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?get_amxvector_null@@YAPAHPAUtagAMX@@H@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_amx_addr$ = 12						; size = 4
?get_amxvector_null@@YAPAHPAUtagAMX@@H@Z PROC		; get_amxvector_null, COMDAT

; 197  : {

  00000	56		 push	 esi

; 198  : 	cell *addr = get_amxaddr(amx, amx_addr);

  00001	ff 74 24 0c	 push	 DWORD PTR _amx_addr$[esp]
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR _amx$[esp+4]
  00009	56		 push	 esi
  0000a	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 199  : 	if (addr == g_plugins.findPluginFast(amx)->getNullVectorOfs())

  0000f	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  00012	83 c4 08	 add	 esp, 8
  00015	33 d2		 xor	 edx, edx
  00017	3b 81 d0 00 00
	00		 cmp	 eax, DWORD PTR [ecx+208]
  0001d	5e		 pop	 esi
  0001e	0f 44 c2	 cmove	 eax, edx

; 200  : 	{
; 201  : 		return nullptr;
; 202  : 	}
; 203  : 
; 204  : 	return addr;
; 205  : }

  00021	c3		 ret	 0
?get_amxvector_null@@YAPAHPAUtagAMX@@H@Z ENDP		; get_amxvector_null
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?get_amxstring_null@@YAPADPAUtagAMX@@HHAAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_amx_addr$ = 12						; size = 4
_id$ = 16						; size = 4
_len$ = 20						; size = 4
?get_amxstring_null@@YAPADPAUtagAMX@@HHAAH@Z PROC	; get_amxstring_null, COMDAT

; 187  : {

  00000	56		 push	 esi

; 188  : 	if (get_amxaddr(amx, amx_addr) == g_plugins.findPluginFast(amx)->getNullStringOfs())

  00001	ff 74 24 0c	 push	 DWORD PTR _amx_addr$[esp]
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR _amx$[esp+4]
  00009	56		 push	 esi
  0000a	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr
  0000f	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  00012	83 c4 08	 add	 esp, 8
  00015	3b 81 cc 00 00
	00		 cmp	 eax, DWORD PTR [ecx+204]
  0001b	75 04		 jne	 SHORT $LN2@get_amxstr

; 189  : 	{
; 190  : 		return nullptr;

  0001d	33 c0		 xor	 eax, eax
  0001f	5e		 pop	 esi

; 194  : }

  00020	c3		 ret	 0
$LN2@get_amxstr:

; 191  : 	}
; 192  : 
; 193  : 	return get_amxstring(amx, amx_addr, id, len);

  00021	ff 74 24 14	 push	 DWORD PTR _len$[esp]
  00025	ff 74 24 14	 push	 DWORD PTR _id$[esp+4]
  00029	ff 74 24 14	 push	 DWORD PTR _amx_addr$[esp+8]
  0002d	56		 push	 esi
  0002e	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  00033	83 c4 10	 add	 esp, 16			; 00000010H
  00036	5e		 pop	 esi

; 194  : }

  00037	c3		 ret	 0
?get_amxstring_null@@YAPADPAUtagAMX@@HHAAH@Z ENDP	; get_amxstring_null
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_amx_addr$ = 12						; size = 4
_id$ = 16						; size = 4
_len$ = 20						; size = 4
?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z PROC		; get_amxstring, COMDAT

; 180  : {

  00000	56		 push	 esi

; 181  : 	auto buffer = get_amxbuffer(id);

  00001	ff 74 24 10	 push	 DWORD PTR _id$[esp]
  00005	e8 00 00 00 00	 call	 ?get_amxbuffer@@YAPADH@Z ; get_amxbuffer

; 182  : 	len = get_amxstring_r(amx, amx_addr, buffer, MAX_BUFFER_LENGTH - 1);

  0000a	68 ff 3f 00 00	 push	 16383			; 00003fffH
  0000f	8b f0		 mov	 esi, eax
  00011	56		 push	 esi
  00012	ff 74 24 18	 push	 DWORD PTR _amx_addr$[esp+12]
  00016	ff 74 24 18	 push	 DWORD PTR _amx$[esp+16]
  0001a	e8 00 00 00 00	 call	 _get_amxstring_r
  0001f	8b 4c 24 28	 mov	 ecx, DWORD PTR _len$[esp+20]
  00023	83 c4 14	 add	 esp, 20			; 00000014H
  00026	89 01		 mov	 DWORD PTR [ecx], eax

; 183  : 	return buffer;

  00028	8b c6		 mov	 eax, esi
  0002a	5e		 pop	 esi

; 184  : }

  0002b	c3		 ret	 0
?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ENDP		; get_amxstring
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?format_amxstring@@YAPADPAUtagAMX@@PAHHAAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
_parm$ = 16						; size = 4
_len$ = 20						; size = 4
?format_amxstring@@YAPADPAUtagAMX@@PAHHAAH@Z PROC	; format_amxstring, COMDAT

; 40   : #if !defined BINLOG_ENABLED
; 41   : 	return g_langMngr.FormatAmxString(amx, params, parm, len);

  00000	ff 74 24 10	 push	 DWORD PTR _len$[esp-4]
  00004	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_langMngr@@3VCLangMngr@@A ; g_langMngr
  00009	ff 74 24 10	 push	 DWORD PTR _parm$[esp]
  0000d	ff 74 24 10	 push	 DWORD PTR _params$[esp+4]
  00011	ff 74 24 10	 push	 DWORD PTR _amx$[esp+8]
  00015	e8 00 00 00 00	 call	 ?FormatAmxString@CLangMngr@@QAEPADPAUtagAMX@@PAHHAAH@Z ; CLangMngr::FormatAmxString

; 42   : #else
; 43   : 	char *ans = g_langMngr.FormatAmxString(amx, params, parm, len);
; 44   : 	if (g_binlog_level & 4)
; 45   : 	{
; 46   : 		CPluginMngr::CPlugin *pl = g_plugins.findPluginFast(amx);
; 47   : 		if (pl)
; 48   : 			g_BinLog.WriteOp(BinLog_FormatString, pl->getId(), parm, len, ans);
; 49   : 	}
; 50   : 	return ans;
; 51   : #endif
; 52   : }

  0001a	c3		 ret	 0
?format_amxstring@@YAPADPAUtagAMX@@PAHHAAH@Z ENDP	; format_amxstring
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_amx_addr$ = 12						; size = 4
?get_amxaddr@@YAPAHPAUtagAMX@@H@Z PROC			; get_amxaddr, COMDAT

; 66   : 	return (cell *)(amx->base + (int)(((AMX_HEADER *)amx->base)->dat + amx_addr));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _amx$[esp-4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00009	03 c1		 add	 eax, ecx
  0000b	03 44 24 08	 add	 eax, DWORD PTR _amx_addr$[esp-4]

; 67   : }

  0000f	c3		 ret	 0
?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ENDP			; get_amxaddr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?stristr@@YAPBDPBD0@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
_substr$ = 12						; size = 4
?stristr@@YAPBDPBD0@Z PROC				; stristr, COMDAT

; 17   : {

  00000	53		 push	 ebx

; 18   : 	register char *needle = (char *)substr;

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _substr$[esp]
  00005	55		 push	 ebp

; 19   : 	register char *prevloc = (char *)str;

  00006	8b 6c 24 0c	 mov	 ebp, DWORD PTR _str$[esp+4]
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 20   : 	register char *haystack = (char *)str;

  0000c	8b f5		 mov	 esi, ebp

; 21   : 
; 22   : 	while (*haystack)

  0000e	80 7d 00 00	 cmp	 BYTE PTR [ebp], 0
  00012	74 35		 je	 SHORT $LN12@stristr
$LL2@stristr:

; 23   : 	{
; 24   : 		if (tolower(*haystack) == tolower(*needle))

  00014	0f be 03	 movsx	 eax, BYTE PTR [ebx]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 _tolower
  0001d	8b f8		 mov	 edi, eax
  0001f	0f be 06	 movsx	 eax, BYTE PTR [esi]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 _tolower
  00028	83 c4 08	 add	 esp, 8
  0002b	3b c7		 cmp	 eax, edi
  0002d	75 0e		 jne	 SHORT $LN4@stristr

; 25   : 		{
; 26   : 			haystack++;
; 27   : 			if (!*++needle)

  0002f	43		 inc	 ebx
  00030	46		 inc	 esi
  00031	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00034	75 0e		 jne	 SHORT $LN5@stristr

; 28   : 				return prevloc;

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	8b c5		 mov	 eax, ebp
  0003a	5d		 pop	 ebp
  0003b	5b		 pop	 ebx

; 36   : }

  0003c	c3		 ret	 0
$LN4@stristr:

; 29   : 		} else {
; 30   : 			haystack = ++prevloc;
; 31   : 			needle = (char *)substr;

  0003d	8b 5c 24 18	 mov	 ebx, DWORD PTR _substr$[esp+12]
  00041	45		 inc	 ebp
  00042	8b f5		 mov	 esi, ebp
$LN5@stristr:

; 21   : 
; 22   : 	while (*haystack)

  00044	80 3e 00	 cmp	 BYTE PTR [esi], 0
  00047	75 cb		 jne	 SHORT $LL2@stristr
$LN12@stristr:
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5d		 pop	 ebp

; 32   : 		}
; 33   : 	}
; 34   : 
; 35   : 	return NULL;

  0004c	33 c0		 xor	 eax, eax
  0004e	5b		 pop	 ebx

; 36   : }

  0004f	c3		 ret	 0
?stristr@@YAPBDPBD0@Z ENDP				; stristr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\cplugin.h
;	COMDAT ?findPluginFast@CPluginMngr@@QAEPAVCPlugin@1@PAUtagAMX@@@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
?findPluginFast@CPluginMngr@@QAEPAVCPlugin@1@PAUtagAMX@@@Z PROC ; CPluginMngr::findPluginFast, COMDAT
; _this$ = ecx

; 135  : 	inline CPlugin* findPluginFast(AMX *amx) { return (CPlugin*)(amx->userdata[UD_FINDPLUGIN]); }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _amx$[esp-4]
  00004	8b 40 48	 mov	 eax, DWORD PTR [eax+72]
  00007	c2 04 00	 ret	 4
?findPluginFast@CPluginMngr@@QAEPAVCPlugin@1@PAUtagAMX@@@Z ENDP ; CPluginMngr::findPluginFast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\cplugin.h
;	COMDAT ?getNullVectorOfs@CPlugin@CPluginMngr@@QBEPAHXZ
_TEXT	SEGMENT
?getNullVectorOfs@CPlugin@CPluginMngr@@QBEPAHXZ PROC	; CPluginMngr::CPlugin::getNullVectorOfs, COMDAT
; _this$ = ecx

; 112  : 		inline cell* getNullVectorOfs() const { return m_pNullVectorOfs; }

  00000	8b 81 d0 00 00
	00		 mov	 eax, DWORD PTR [ecx+208]
  00006	c3		 ret	 0
?getNullVectorOfs@CPlugin@CPluginMngr@@QBEPAHXZ ENDP	; CPluginMngr::CPlugin::getNullVectorOfs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\cplugin.h
;	COMDAT ?getNullStringOfs@CPlugin@CPluginMngr@@QBEPAHXZ
_TEXT	SEGMENT
?getNullStringOfs@CPlugin@CPluginMngr@@QBEPAHXZ PROC	; CPluginMngr::CPlugin::getNullStringOfs, COMDAT
; _this$ = ecx

; 111  : 		inline cell* getNullStringOfs() const { return m_pNullStringOfs; }

  00000	8b 81 cc 00 00
	00		 mov	 eax, DWORD PTR [ecx+204]
  00006	c3		 ret	 0
?getNullStringOfs@CPlugin@CPluginMngr@@QBEPAHXZ ENDP	; CPluginMngr::CPlugin::getNullStringOfs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00000	8d 44 24 0c	 lea	 eax, DWORD PTR __Format$[esp]
  00004	50		 push	 eax
  00005	6a 00		 push	 0
  00007	ff 74 24 10	 push	 DWORD PTR __Format$[esp+4]
  0000b	6a ff		 push	 -1
  0000d	ff 74 24 14	 push	 DWORD PTR __Buffer$[esp+12]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

  0002f	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00000	ff 74 24 10	 push	 DWORD PTR __ArgList$[esp-4]
  00004	ff 74 24 10	 push	 DWORD PTR __Locale$[esp]
  00008	ff 74 24 10	 push	 DWORD PTR __Format$[esp+4]
  0000c	6a ff		 push	 -1
  0000e	ff 74 24 14	 push	 DWORD PTR __Buffer$[esp+12]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 1459 :     #pragma warning(pop)
; 1460 : }

  00030	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00000	ff 74 24 14	 push	 DWORD PTR __ArgList$[esp-4]
  00004	ff 74 24 14	 push	 DWORD PTR __Locale$[esp]
  00008	ff 74 24 14	 push	 DWORD PTR __Format$[esp+4]
  0000c	ff 74 24 14	 push	 DWORD PTR __BufferCount$[esp+8]
  00010	ff 74 24 14	 push	 DWORD PTR __Buffer$[esp+12]
  00014	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	ff 70 04	 push	 DWORD PTR [eax+4]
  0001e	83 c9 01	 or	 ecx, 1
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00027	83 c9 ff	 or	 ecx, -1
  0002a	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002d	85 c0		 test	 eax, eax
  0002f	0f 48 c1	 cmovs	 eax, ecx

; 1391 : }

  00032	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h
;	COMDAT ?strstr@@YAPADQADQBD@Z
_TEXT	SEGMENT
__String$ = 8						; size = 4
__SubString$ = 12					; size = 4
?strstr@@YAPADQADQBD@Z PROC				; strstr, COMDAT

; 537  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  00000	e9 00 00 00 00	 jmp	 _strstr
?strstr@@YAPADQADQBD@Z ENDP				; strstr
_TEXT	ENDS
END
