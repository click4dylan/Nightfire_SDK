; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	E:\nightfire_sdk\amx\amxmodx\format.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	??0AString@ke@@QAE@PBD@Z			; ke::AString::AString
PUBLIC	??1?$AutoArray@D@ke@@QAE@XZ			; ke::AutoArray<char>::~AutoArray<char>
PUBLIC	??1AString@ke@@QAE@XZ				; ke::AString::~AString
PUBLIC	??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const *>
PUBLIC	?playerlang@@YAPBDH@Z				; playerlang
PUBLIC	?translate@@YAPBDPAUtagAMX@@PBD1@Z		; translate
PUBLIC	??$atcprintf@HH@@YAIPAHIPBHPAUtagAMX@@00@Z	; atcprintf<int,int>
PUBLIC	??$atcprintf@DH@@YAIPADIPBHPAUtagAMX@@PAH3@Z	; atcprintf<char,int>
PUBLIC	??$atcprintf@HD@@YAIPAHIPBDPAUtagAMX@@00@Z	; atcprintf<int,char>
PUBLIC	??$atcprintf@DD@@YAIPADIPBDPAUtagAMX@@PAH3@Z	; atcprintf<char,char>
PUBLIC	?_Clear@?$THash@VAString@ke@@Ulang_err@@@@AAEXXZ ; THash<ke::AString,lang_err>::_Clear
PUBLIC	?_Refactor@?$THash@VAString@ke@@Ulang_err@@@@AAEXXZ ; THash<ke::AString,lang_err>::_Refactor
PUBLIC	??$AltFindOrInsert@VAString@ke@@@?$THash@VAString@ke@@Ulang_err@@@@QAEAAUlang_err@@ABVAString@ke@@@Z ; THash<ke::AString,lang_err>::AltFindOrInsert<ke::AString>
PUBLIC	?__WHOA_DONT_CALL_ME_PLZ_K_lol_o_O@@YAXXZ	; __WHOA_DONT_CALL_ME_PLZ_K_lol_o_O
PUBLIC	??0THashNode@?$THash@VAString@ke@@Ulang_err@@@@QAE@ABVAString@ke@@ABUlang_err@@@Z ; THash<ke::AString,lang_err>::THashNode::THashNode
PUBLIC	??$AddBinary@H@@YAXPAPAHAAIIHH@Z		; AddBinary<int>
PUBLIC	??$AddInt@H@@YAXPAPAHAAIHHH@Z			; AddInt<int>
PUBLIC	??$AddUInt@H@@YAXPAPAHAAIIHH@Z			; AddUInt<int>
PUBLIC	??$AddFloat@H@@YAXPAPAHAAINHHH@Z		; AddFloat<int>
PUBLIC	??$AddHex@H@@YAXPAPAHAAIIHH@Z			; AddHex<int>
PUBLIC	??$AddString@HH@@YAXPAPAHAAIPBHHH@Z		; AddString<int,int>
PUBLIC	??$AddString@HD@@YAXPAPAHAAIPBDHH@Z		; AddString<int,char>
PUBLIC	??$AddBinary@D@@YAXPAPADAAIIHH@Z		; AddBinary<char>
PUBLIC	??$AddInt@D@@YAXPAPADAAIHHH@Z			; AddInt<char>
PUBLIC	??$AddUInt@D@@YAXPAPADAAIIHH@Z			; AddUInt<char>
PUBLIC	??$AddFloat@D@@YAXPAPADAAINHHH@Z		; AddFloat<char>
PUBLIC	??$AddHex@D@@YAXPAPADAAIIHH@Z			; AddHex<char>
PUBLIC	??$AddString@DH@@YAXPAPADAAIPBHHH@Z		; AddString<char,int>
PUBLIC	??$AddString@DD@@YAXPAPADAAIPBDHH@Z		; AddString<char,char>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	?BadLang_Table@@3V?$THash@VAString@ke@@Ulang_err@@@@A ; BadLang_Table
PUBLIC	??_C@_0BF@GKKDCIGK@amx_client_languages?$AA@	; `string'
PUBLIC	??_C@_04IOHABJIC@lang?$AA@			; `string'
PUBLIC	??_C@_0M@MIAOMHNK@amx_mldebug?$AA@		; `string'
PUBLIC	??_C@_0CJ@HNOIGG@?$FLAMXX?$FN?5?$CC?$CFs?$CC?5is?5an?5invalid?5debug?5@ ; `string'
PUBLIC	??_C@_0EB@MOLGOKDE@?$FLAMXX?$FN?5Language?5key?5?$CC?$CFs?$CC?5not?5fou@ ; `string'
PUBLIC	??_C@_0BP@PJOGJHMO@?$FLAMXX?$FN?5Language?5?$CC?$CFs?$CC?5not?5found?$AA@ ; `string'
PUBLIC	??_C@_02LFNMGJAP@en?$AA@			; `string'
PUBLIC	?buf@?DN@???$atcprintf@HH@@YAIPAHIPBHPAUtagAMX@@00@Z@4PADA ; `atcprintf<int,int>'::`61'::buf
PUBLIC	??_C@_0DH@NEIDFOJI@String?5formatted?5incorrectly?5?9?5p@ ; `string'
PUBLIC	??_C@_0CL@GCKMCDNK@Invalid?5vector?5string?5handle?5pro@ ; `string'
PUBLIC	??_C@_0BA@HJJJBHCN@ML_NOTFOUND?3?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_0BL@KOKBGDMJ@Client?5index?5?$CFd?5is?5invalid?$AA@ ; `string'
PUBLIC	??_C@_0P@JDPKEEME@?$CFs?$DM?$CFd?$DO?$DM?$CFu?$DO?$DM?$CFs?$DO?$AA@ ; `string'
PUBLIC	??_C@_0BN@PONBEONJ@Console?$DM0?$DO?$DMConsole?$DO?$DMConsole?$DO?$AA@ ; `string'
PUBLIC	??_C@_07PGLPGHFC@Console?$AA@			; `string'
PUBLIC	?buf@?DN@???$atcprintf@DH@@YAIPADIPBHPAUtagAMX@@PAH3@Z@4PADA ; `atcprintf<char,int>'::`61'::buf
PUBLIC	?buf@?DN@???$atcprintf@HD@@YAIPAHIPBDPAUtagAMX@@00@Z@4PADA ; `atcprintf<int,char>'::`61'::buf
PUBLIC	?buf@?DN@???$atcprintf@DD@@YAIPADIPBDPAUtagAMX@@PAH3@Z@4PADA ; `atcprintf<char,char>'::`61'::buf
PUBLIC	?nlstr@?1???$AddString@HH@@YAXPAPAHAAIPBHHH@Z@4PAHA ; `AddString<int,int>'::`2'::nlstr
PUBLIC	?nlstr@?1???$AddString@HD@@YAXPAPAHAAIPBDHH@Z@4PADA ; `AddString<int,char>'::`2'::nlstr
PUBLIC	?nlstr@?1???$AddString@DH@@YAXPAPADAAIPBHHH@Z@4PAHA ; `AddString<char,int>'::`2'::nlstr
PUBLIC	?nlstr@?1???$AddString@DD@@YAXPAPADAAIPBDHH@Z@4PADA ; `AddString<char,char>'::`2'::nlstr
PUBLIC	__real@3f400000
PUBLIC	__real@3f800000
PUBLIC	__real@3fb999999999999a
PUBLIC	__real@4024000000000000
PUBLIC	__real@42f00000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000000000008000000000000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	_isalpha:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	?GetFileName@@YAPBDPAUtagAMX@@@Z:PROC		; GetFileName
EXTRN	?GetDef@CLangMngr@@QAEPBDPBD0AAH@Z:PROC		; CLangMngr::GetDef
EXTRN	?LangExists@CLangMngr@@QAE_NPBD@Z:PROC		; CLangMngr::LangExists
EXTRN	?LogError@CLog@@QAAXPBDZZ:PROC			; CLog::LogError
EXTRN	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z:PROC		; get_amxaddr
EXTRN	?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z:PROC	; get_amxstring
EXTRN	_LogError:PROC
EXTRN	??$HashFunction@VAString@ke@@@@YAHABVAString@ke@@@Z:PROC ; HashFunction<ke::AString>
EXTRN	??$UTIL_CheckValidChar@H@@YAHPAH@Z:PROC		; UTIL_CheckValidChar<int>
EXTRN	??$UTIL_CheckValidChar@D@@YAHPAD@Z:PROC		; UTIL_CheckValidChar<char>
EXTRN	??$HashAlt@VAString@ke@@@@YAHABVAString@ke@@@Z:PROC ; HashAlt<ke::AString>
EXTRN	??$CompareAlt@VAString@ke@@V12@@@YAHABVAString@ke@@0@Z:PROC ; CompareAlt<ke::AString,ke::AString>
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__libm_sse2_log10_precise:PROC
EXTRN	__libm_sse2_pow_precise:PROC
EXTRN	_memcpy:PROC
EXTRN	?g_engfuncs@@3Uenginefuncs_s@@A:BYTE		; g_engfuncs
EXTRN	?gpGlobals@@3PAUglobalvars_t@@A:DWORD		; gpGlobals
EXTRN	?g_log@@3VCLog@@A:BYTE				; g_log
EXTRN	?g_players@@3PAVCPlayer@@A:BYTE			; g_players
EXTRN	?g_langMngr@@3VCLangMngr@@A:BYTE		; g_langMngr
EXTRN	?amxmodx_language@@3PAVConsoleVariable@@A:DWORD	; amxmodx_language
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?BadLang_Table@@3V?$THash@VAString@ke@@Ulang_err@@@@A DB 010H DUP (?) ; BadLang_Table
?amx_mldebug@@3PAVConsoleVariable@@A DD 01H DUP (?)	; amx_mldebug
?amx_cl_langs@@3PAVConsoleVariable@@A DD 01H DUP (?)	; amx_cl_langs
_BSS	ENDS
;	COMDAT ?buf@?DN@???$atcprintf@HH@@YAIPAHIPBHPAUtagAMX@@00@Z@4PADA
_BSS	SEGMENT
?buf@?DN@???$atcprintf@HH@@YAIPAHIPBHPAUtagAMX@@00@Z@4PADA DB 0ffH DUP (?) ; `atcprintf<int,int>'::`61'::buf
_BSS	ENDS
;	COMDAT ?buf@?DN@???$atcprintf@DH@@YAIPADIPBHPAUtagAMX@@PAH3@Z@4PADA
_BSS	SEGMENT
?buf@?DN@???$atcprintf@DH@@YAIPADIPBHPAUtagAMX@@PAH3@Z@4PADA DB 0ffH DUP (?) ; `atcprintf<char,int>'::`61'::buf
_BSS	ENDS
;	COMDAT ?buf@?DN@???$atcprintf@HD@@YAIPAHIPBDPAUtagAMX@@00@Z@4PADA
_BSS	SEGMENT
?buf@?DN@???$atcprintf@HD@@YAIPAHIPBDPAUtagAMX@@00@Z@4PADA DB 0ffH DUP (?) ; `atcprintf<int,char>'::`61'::buf
_BSS	ENDS
;	COMDAT ?buf@?DN@???$atcprintf@DD@@YAIPADIPBDPAUtagAMX@@PAH3@Z@4PADA
_BSS	SEGMENT
?buf@?DN@???$atcprintf@DD@@YAIPADIPBDPAUtagAMX@@PAH3@Z@4PADA DB 0ffH DUP (?) ; `atcprintf<char,char>'::`61'::buf
_BSS	ENDS
CRT$XCU	SEGMENT
?BadLang_Table$initializer$@@3P6AXXZA DD FLAT:??__EBadLang_Table@@YAXXZ ; BadLang_Table$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@42f00000
CONST	SEGMENT
__real@42f00000 DD 042f00000r			; 120
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@3fb999999999999a
CONST	SEGMENT
__real@3fb999999999999a DQ 03fb999999999999ar	; 0.1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f400000
CONST	SEGMENT
__real@3f400000 DD 03f400000r			; 0.75
CONST	ENDS
;	COMDAT ?nlstr@?1???$AddString@DD@@YAXPAPADAAIPBDHH@Z@4PADA
_DATA	SEGMENT
?nlstr@?1???$AddString@DD@@YAXPAPADAAIPBDHH@Z@4PADA DB 028H ; `AddString<char,char>'::`2'::nlstr
	DB	06eH
	DB	075H
	DB	06cH
	DB	06cH
	DB	029H
	DB	00H
_DATA	ENDS
;	COMDAT ?nlstr@?1???$AddString@DH@@YAXPAPADAAIPBHHH@Z@4PAHA
_DATA	SEGMENT
?nlstr@?1???$AddString@DH@@YAXPAPADAAIPBHHH@Z@4PAHA DD 028H ; `AddString<char,int>'::`2'::nlstr
	DD	06eH
	DD	075H
	DD	06cH
	DD	06cH
	DD	029H
	DD	00H
_DATA	ENDS
;	COMDAT ?nlstr@?1???$AddString@HD@@YAXPAPAHAAIPBDHH@Z@4PADA
_DATA	SEGMENT
?nlstr@?1???$AddString@HD@@YAXPAPAHAAIPBDHH@Z@4PADA DB 028H ; `AddString<int,char>'::`2'::nlstr
	DB	06eH
	DB	075H
	DB	06cH
	DB	06cH
	DB	029H
	DB	00H
_DATA	ENDS
;	COMDAT ?nlstr@?1???$AddString@HH@@YAXPAPAHAAIPBHHH@Z@4PAHA
_DATA	SEGMENT
?nlstr@?1???$AddString@HH@@YAXPAPAHAAIPBHHH@Z@4PAHA DD 028H ; `AddString<int,int>'::`2'::nlstr
	DD	06eH
	DD	075H
	DD	06cH
	DD	06cH
	DD	029H
	DD	00H
_DATA	ENDS
;	COMDAT ??_C@_07PGLPGHFC@Console?$AA@
CONST	SEGMENT
??_C@_07PGLPGHFC@Console?$AA@ DB 'Console', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@PONBEONJ@Console?$DM0?$DO?$DMConsole?$DO?$DMConsole?$DO?$AA@
CONST	SEGMENT
??_C@_0BN@PONBEONJ@Console?$DM0?$DO?$DMConsole?$DO?$DMConsole?$DO?$AA@ DB 'C'
	DB	'onsole<0><Console><Console>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JDPKEEME@?$CFs?$DM?$CFd?$DO?$DM?$CFu?$DO?$DM?$CFs?$DO?$AA@
CONST	SEGMENT
??_C@_0P@JDPKEEME@?$CFs?$DM?$CFd?$DO?$DM?$CFu?$DO?$DM?$CFs?$DO?$AA@ DB '%'
	DB	's<%d><%u><%s>', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KOKBGDMJ@Client?5index?5?$CFd?5is?5invalid?$AA@
CONST	SEGMENT
??_C@_0BL@KOKBGDMJ@Client?5index?5?$CFd?5is?5invalid?$AA@ DB 'Client inde'
	DB	'x %d is invalid', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HJJJBHCN@ML_NOTFOUND?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BA@HJJJBHCN@ML_NOTFOUND?3?5?$CFs?$AA@ DB 'ML_NOTFOUND: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@GCKMCDNK@Invalid?5vector?5string?5handle?5pro@
CONST	SEGMENT
??_C@_0CL@GCKMCDNK@Invalid?5vector?5string?5handle?5pro@ DB 'Invalid vect'
	DB	'or string handle provided (%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@NEIDFOJI@String?5formatted?5incorrectly?5?9?5p@
CONST	SEGMENT
??_C@_0DH@NEIDFOJI@String?5formatted?5incorrectly?5?9?5p@ DB 'String form'
	DB	'atted incorrectly - parameter %d (total %d)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02LFNMGJAP@en?$AA@
CONST	SEGMENT
??_C@_02LFNMGJAP@en?$AA@ DB 'en', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PJOGJHMO@?$FLAMXX?$FN?5Language?5?$CC?$CFs?$CC?5not?5found?$AA@
CONST	SEGMENT
??_C@_0BP@PJOGJHMO@?$FLAMXX?$FN?5Language?5?$CC?$CFs?$CC?5not?5found?$AA@ DB '['
	DB	'AMXX] Language "%s" not found', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@MOLGOKDE@?$FLAMXX?$FN?5Language?5key?5?$CC?$CFs?$CC?5not?5fou@
CONST	SEGMENT
??_C@_0EB@MOLGOKDE@?$FLAMXX?$FN?5Language?5key?5?$CC?$CFs?$CC?5not?5fou@ DB '['
	DB	'AMXX] Language key "%s" not found for language "%s", check "%'
	DB	's"', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@HNOIGG@?$FLAMXX?$FN?5?$CC?$CFs?$CC?5is?5an?5invalid?5debug?5@
CONST	SEGMENT
??_C@_0CJ@HNOIGG@?$FLAMXX?$FN?5?$CC?$CFs?$CC?5is?5an?5invalid?5debug?5@ DB '['
	DB	'AMXX] "%s" is an invalid debug language', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MIAOMHNK@amx_mldebug?$AA@
CONST	SEGMENT
??_C@_0M@MIAOMHNK@amx_mldebug?$AA@ DB 'amx_mldebug', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04IOHABJIC@lang?$AA@
CONST	SEGMENT
??_C@_04IOHABJIC@lang?$AA@ DB 'lang', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GKKDCIGK@amx_client_languages?$AA@
CONST	SEGMENT
??_C@_0BF@GKKDCIGK@amx_client_languages?$AA@ DB 'amx_client_languages', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0THashNode@?$THash@VAString@ke@@Ulang_err@@@@QAE@ABVAString@ke@@ABUlang_err@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0THashNode@?$THash@VAString@ke@@Ulang_err@@@@QAE@ABVAString@ke@@ABUlang_err@@@Z$1
__ehfuncinfo$??0THashNode@?$THash@VAString@ke@@Ulang_err@@@@QAE@ABVAString@ke@@ABUlang_err@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0THashNode@?$THash@VAString@ke@@Ulang_err@@@@QAE@ABVAString@ke@@ABUlang_err@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$AltFindOrInsert@VAString@ke@@@?$THash@VAString@ke@@Ulang_err@@@@QAEAAUlang_err@@ABVAString@ke@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$AltFindOrInsert@VAString@ke@@@?$THash@VAString@ke@@Ulang_err@@@@QAEAAUlang_err@@ABVAString@ke@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$AltFindOrInsert@VAString@ke@@@?$THash@VAString@ke@@Ulang_err@@@@QAEAAUlang_err@@ABVAString@ke@@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??$AltFindOrInsert@VAString@ke@@@?$THash@VAString@ke@@Ulang_err@@@@QAEAAUlang_err@@ABVAString@ke@@@Z$5
__ehfuncinfo$??$AltFindOrInsert@VAString@ke@@@?$THash@VAString@ke@@Ulang_err@@@@QAEAAUlang_err@@ABVAString@ke@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$AltFindOrInsert@VAString@ke@@@?$THash@VAString@ke@@Ulang_err@@@@QAEAAUlang_err@@ABVAString@ke@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?translate@@YAPBDPAUtagAMX@@PBD1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?translate@@YAPBDPAUtagAMX@@PBD1@Z$0
__ehfuncinfo$?translate@@YAPBDPAUtagAMX@@PBD1@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?translate@@YAPBDPAUtagAMX@@PBD1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0AString@ke@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0AString@ke@@QAE@ABV01@@Z$0
__ehfuncinfo$??0AString@ke@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0AString@ke@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0AString@ke@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0AString@ke@@QAE@PBD@Z$0
__ehfuncinfo$??0AString@ke@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0AString@ke@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
;	COMDAT ??$AddString@DD@@YAXPAPADAAIPBDHH@Z
_TEXT	SEGMENT
_buf_p$ = 8						; size = 4
_maxlen$ = 12						; size = 4
_string$ = 16						; size = 4
_width$ = 20						; size = 4
_prec$ = 24						; size = 4
??$AddString@DD@@YAXPAPADAAIPBDHH@Z PROC		; AddString<char,char>, COMDAT

; 164  : {

	mov	eax, DWORD PTR _string$[esp-4]

; 165  : 	int		size = 0;

	xor	ecx, ecx
	push	ebx
	test	eax, eax
	mov	ebx, OFFSET ?nlstr@?1???$AddString@DD@@YAXPAPADAAIPBDHH@Z@4PADA ; `AddString<char,char>'::`2'::nlstr
	push	ebp
	cmovne	ebx, eax
	or	edx, -1
	push	esi
	push	edi

; 166  : 	U		*buf;
; 167  : 	static S nlstr[] = {'(','n','u','l','l',')','\0'};
; 168  : 
; 169  : 	buf = *buf_p;

	mov	edi, DWORD PTR _buf_p$[esp+12]
	test	eax, eax
	cmovne	edx, DWORD PTR _prec$[esp+12]
	mov	edi, DWORD PTR [edi]

; 170  : 
; 171  : 	if (string == NULL)
; 172  : 	{
; 173  : 		string = nlstr;
; 174  : 		prec = -1;
; 175  : 	}
; 176  : 
; 177  : 	if (prec >= 0)

	test	edx, edx
	js	SHORT $LL5@AddString

; 178  : 	{
; 179  : 		for (size = 0; size < prec; size++) 

	xor	esi, esi
	test	edx, edx
	jle	SHORT $LN13@AddString
	npad	2
$LL4@AddString:

; 180  : 		{
; 181  : 			if (string[size] == '\0')

	cmp	BYTE PTR [ebx+esi], cl
	je	SHORT $LN13@AddString

; 178  : 	{
; 179  : 		for (size = 0; size < prec; size++) 

	inc	esi
	cmp	esi, edx
	jl	SHORT $LL4@AddString

; 182  : 				break;
; 183  : 		}
; 184  : 	} else {

	jmp	SHORT $LN13@AddString
	npad	4
$LL5@AddString:

; 185  : 		while (string[size++]) ;

	mov	al, BYTE PTR [ebx+ecx]
	mov	esi, ecx
	inc	ecx
	test	al, al
	jne	SHORT $LL5@AddString
$LN13@AddString:

; 186  : 		size--;
; 187  : 	}
; 188  : 
; 189  : 	if (size > (int)maxlen)

	mov	ebp, DWORD PTR _maxlen$[esp+12]
	cmp	esi, DWORD PTR [ebp]
	cmovg	esi, DWORD PTR [ebp]

; 190  : 		size = maxlen;
; 191  : 
; 192  : 	/* If precision is provided, make sure we don't truncate a multi-byte character */
; 193  : 	if (prec >= size && (string[size - 1] & 1 << 7))

	cmp	edx, esi
	jl	SHORT $LN16@AddString
	cmp	BYTE PTR [ebx+esi-1], 0
	jge	SHORT $LN16@AddString

; 194  : 	{
; 195  : 		size -= UTIL_CheckValidChar((cell *)string + size - 1);

	lea	eax, DWORD PTR [ebx-4]
	lea	eax, DWORD PTR [eax+esi*4]
	push	eax
	call	??$UTIL_CheckValidChar@H@@YAHPAH@Z	; UTIL_CheckValidChar<int>
	add	esp, 4
	sub	esi, eax
$LN16@AddString:

; 196  : 	}
; 197  : 
; 198  : 	maxlen -= size;
; 199  : 	width -= size;

	mov	ecx, DWORD PTR _width$[esp+12]
	sub	DWORD PTR [ebp], esi
	sub	ecx, esi

; 200  : 
; 201  : 	while (size--)

	test	esi, esi
	je	SHORT $LN24@AddString
	npad	2
$LL7@AddString:

; 202  : 		*buf++ = static_cast<U>(*string++);

	mov	al, BYTE PTR [ebx]
	lea	ebx, DWORD PTR [ebx+1]
	mov	BYTE PTR [edi], al
	inc	edi
	sub	esi, 1
	jne	SHORT $LL7@AddString
$LN24@AddString:

; 203  : 
; 204  : 	while (width-- > 0 && maxlen)

	test	ecx, ecx
	jle	SHORT $LN60@AddString
$LL9@AddString:
	dec	ecx
	cmp	DWORD PTR [ebp], 0
	je	SHORT $LN60@AddString

; 205  : 	{
; 206  : 		*buf++ = ' ';

	mov	BYTE PTR [edi], 32			; 00000020H
	inc	edi

; 207  : 		maxlen--;

	dec	DWORD PTR [ebp]
	test	ecx, ecx
	jg	SHORT $LL9@AddString
$LN60@AddString:

; 208  : 	}
; 209  : 
; 210  : 	*buf_p = buf;

	mov	eax, DWORD PTR _buf_p$[esp+12]
	mov	DWORD PTR [eax], edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 211  : }

	ret	0
??$AddString@DD@@YAXPAPADAAIPBDHH@Z ENDP		; AddString<char,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
;	COMDAT ??$AddString@DH@@YAXPAPADAAIPBHHH@Z
_TEXT	SEGMENT
_buf_p$ = 8						; size = 4
_maxlen$ = 12						; size = 4
_string$ = 16						; size = 4
_width$ = 20						; size = 4
_prec$ = 24						; size = 4
??$AddString@DH@@YAXPAPADAAIPBHHH@Z PROC		; AddString<char,int>, COMDAT

; 164  : {

	mov	eax, DWORD PTR _string$[esp-4]

; 165  : 	int		size = 0;

	xor	ecx, ecx
	push	ebx
	test	eax, eax
	mov	ebx, OFFSET ?nlstr@?1???$AddString@DH@@YAXPAPADAAIPBHHH@Z@4PAHA ; `AddString<char,int>'::`2'::nlstr
	push	ebp
	cmovne	ebx, eax
	or	edx, -1
	push	esi
	push	edi

; 166  : 	U		*buf;
; 167  : 	static S nlstr[] = {'(','n','u','l','l',')','\0'};
; 168  : 
; 169  : 	buf = *buf_p;

	mov	edi, DWORD PTR _buf_p$[esp+12]
	test	eax, eax
	cmovne	edx, DWORD PTR _prec$[esp+12]
	mov	edi, DWORD PTR [edi]

; 170  : 
; 171  : 	if (string == NULL)
; 172  : 	{
; 173  : 		string = nlstr;
; 174  : 		prec = -1;
; 175  : 	}
; 176  : 
; 177  : 	if (prec >= 0)

	test	edx, edx
	js	SHORT $LL5@AddString

; 178  : 	{
; 179  : 		for (size = 0; size < prec; size++) 

	xor	esi, esi
	test	edx, edx
	jle	SHORT $LN13@AddString
	npad	2
$LL4@AddString:

; 180  : 		{
; 181  : 			if (string[size] == '\0')

	cmp	DWORD PTR [ebx+esi*4], ecx
	je	SHORT $LN13@AddString

; 178  : 	{
; 179  : 		for (size = 0; size < prec; size++) 

	inc	esi
	cmp	esi, edx
	jl	SHORT $LL4@AddString

; 182  : 				break;
; 183  : 		}
; 184  : 	} else {

	jmp	SHORT $LN13@AddString
	npad	4
$LL5@AddString:

; 185  : 		while (string[size++]) ;

	mov	eax, DWORD PTR [ebx+ecx*4]
	mov	esi, ecx
	inc	ecx
	test	eax, eax
	jne	SHORT $LL5@AddString
$LN13@AddString:

; 186  : 		size--;
; 187  : 	}
; 188  : 
; 189  : 	if (size > (int)maxlen)

	mov	ebp, DWORD PTR _maxlen$[esp+12]
	cmp	esi, DWORD PTR [ebp]
	cmovg	esi, DWORD PTR [ebp]

; 190  : 		size = maxlen;
; 191  : 
; 192  : 	/* If precision is provided, make sure we don't truncate a multi-byte character */
; 193  : 	if (prec >= size && (string[size - 1] & 1 << 7))

	cmp	edx, esi
	jl	SHORT $LN16@AddString
	lea	eax, DWORD PTR [ebx-4]
	test	BYTE PTR [eax+esi*4], 128		; 00000080H
	lea	eax, DWORD PTR [eax+esi*4]
	je	SHORT $LN16@AddString

; 194  : 	{
; 195  : 		size -= UTIL_CheckValidChar((cell *)string + size - 1);

	push	eax
	call	??$UTIL_CheckValidChar@H@@YAHPAH@Z	; UTIL_CheckValidChar<int>
	add	esp, 4
	sub	esi, eax
$LN16@AddString:

; 196  : 	}
; 197  : 
; 198  : 	maxlen -= size;
; 199  : 	width -= size;

	mov	ecx, DWORD PTR _width$[esp+12]
	sub	DWORD PTR [ebp], esi
	sub	ecx, esi

; 200  : 
; 201  : 	while (size--)

	test	esi, esi
	je	SHORT $LN24@AddString
	npad	3
$LL7@AddString:

; 202  : 		*buf++ = static_cast<U>(*string++);

	mov	al, BYTE PTR [ebx]
	lea	ebx, DWORD PTR [ebx+4]
	mov	BYTE PTR [edi], al
	inc	edi
	sub	esi, 1
	jne	SHORT $LL7@AddString
$LN24@AddString:

; 203  : 
; 204  : 	while (width-- > 0 && maxlen)

	test	ecx, ecx
	jle	SHORT $LN60@AddString
$LL9@AddString:
	dec	ecx
	cmp	DWORD PTR [ebp], 0
	je	SHORT $LN60@AddString

; 205  : 	{
; 206  : 		*buf++ = ' ';

	mov	BYTE PTR [edi], 32			; 00000020H
	inc	edi

; 207  : 		maxlen--;

	dec	DWORD PTR [ebp]
	test	ecx, ecx
	jg	SHORT $LL9@AddString
$LN60@AddString:

; 208  : 	}
; 209  : 
; 210  : 	*buf_p = buf;

	mov	eax, DWORD PTR _buf_p$[esp+12]
	mov	DWORD PTR [eax], edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 211  : }

	ret	0
??$AddString@DH@@YAXPAPADAAIPBHHH@Z ENDP		; AddString<char,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
;	COMDAT ??$AddHex@D@@YAXPAPADAAIIHH@Z
_TEXT	SEGMENT
tv237 = -40						; size = 4
_text$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_buf_p$ = 8						; size = 4
_maxlen$ = 12						; size = 4
_val$ = 16						; size = 4
_width$ = 20						; size = 4
_flags$ = 24						; size = 4
??$AddHex@D@@YAXPAPADAAIIHH@Z PROC			; AddHex<char>, COMDAT

; 490  : {

	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+40], eax

; 491  : 	U		text[32];
; 492  : 	int		digits;
; 493  : 	U		*buf;
; 494  : 	U		digit;
; 495  : 	int		hexadjust;
; 496  : 
; 497  : 	if (flags & UPPERDIGITS)
; 498  : 	{
; 499  : 		hexadjust = 'A' - '9' - 1;
; 500  : 	} else {
; 501  : 		hexadjust = 'a' - '9' - 1;
; 502  : 	}
; 503  : 
; 504  : 	digits = 0;

	mov	ecx, DWORD PTR _val$[esp+36]
	push	ebx
	mov	ebx, DWORD PTR _flags$[esp+40]
	mov	edx, ebx
	shr	edx, 4
	push	ebp
	mov	ebp, DWORD PTR _buf_p$[esp+44]
	not	edx
	push	esi
	mov	esi, DWORD PTR _maxlen$[esp+48]
	and	edx, 32					; 00000020H
	push	edi
	or	edx, 7
	xor	edi, edi
$LL4@AddHex:

; 505  : 	do
; 506  : 	{
; 507  : 		digit = ('0' + val % 16);

	mov	al, cl
	and	al, 15					; 0000000fH
	add	al, 48					; 00000030H
	cmp	al, 57					; 00000039H

; 508  : 		if (digit > '9')

	jbe	SHORT $LN13@AddHex

; 509  : 		{
; 510  : 			digit += hexadjust;

	add	al, dl
$LN13@AddHex:

; 511  : 		}
; 512  : 
; 513  : 		text[digits++] = digit;

	mov	BYTE PTR _text$[esp+edi+56], al
	inc	edi

; 514  : 		val /= 16;

	shr	ecx, 4

; 515  : 	} while (val);

	test	ecx, ecx
	jne	SHORT $LL4@AddHex

; 516  : 
; 517  : 	buf = *buf_p;

	mov	ecx, DWORD PTR [ebp]

; 518  : 
; 519  : 	if( !(flags & LADJUST) )

	mov	eax, ebx

; 520  : 	{
; 521  : 		while (digits < width && maxlen)

	mov	edx, DWORD PTR _width$[esp+52]
	and	eax, 4
	mov	DWORD PTR tv237[esp+56], eax
	jne	SHORT $LN19@AddHex
	cmp	edi, edx
	jge	SHORT $LN19@AddHex
	npad	1
$LL5@AddHex:
	cmp	DWORD PTR [esi], 0
	je	SHORT $LN19@AddHex

; 522  : 		{
; 523  : 			*buf++ = (flags & ZEROPAD) ? '0' : ' ';

	mov	eax, ebx

; 524  : 			width--;

	dec	edx
	shr	eax, 3
	and	al, 16					; 00000010H
	or	al, 32					; 00000020H
	mov	BYTE PTR [ecx], al
	inc	ecx

; 525  : 			maxlen--;

	dec	DWORD PTR [esi]
	cmp	edi, edx
	jl	SHORT $LL5@AddHex
$LN19@AddHex:

; 526  : 		}
; 527  : 	}
; 528  : 
; 529  : 	while (digits-- && maxlen)

	test	edi, edi
	je	SHORT $LN38@AddHex
	npad	4
$LL7@AddHex:
	dec	edi
	cmp	DWORD PTR [esi], 0
	je	SHORT $LN38@AddHex

; 530  : 	{
; 531  : 		*buf++ = text[digits];

	mov	al, BYTE PTR _text$[esp+edi+56]

; 532  : 		width--;

	dec	edx
	mov	BYTE PTR [ecx], al
	inc	ecx

; 533  : 		maxlen--;

	dec	DWORD PTR [esi]
	test	edi, edi
	jne	SHORT $LL7@AddHex
$LN38@AddHex:
	cmp	DWORD PTR tv237[esp+56], 0

; 534  : 	}
; 535  : 
; 536  : 	if (flags & LADJUST)

	je	SHORT $LN36@AddHex

; 537  : 	{
; 538  : 		while (width-- && maxlen)

	test	edx, edx
	je	SHORT $LN36@AddHex
	npad	1
$LL9@AddHex:
	dec	edx
	cmp	DWORD PTR [esi], 0
	je	SHORT $LN36@AddHex

; 539  : 		{
; 540  : 			*buf++ = (flags & ZEROPAD) ? '0' : ' ';

	mov	eax, ebx
	shr	eax, 3
	and	al, 16					; 00000010H
	or	al, 32					; 00000020H
	mov	BYTE PTR [ecx], al
	inc	ecx

; 541  : 			maxlen--;

	dec	DWORD PTR [esi]
	test	edx, edx
	jne	SHORT $LL9@AddHex
$LN36@AddHex:
	pop	edi

; 542  : 		}
; 543  : 	}
; 544  : 
; 545  : 	*buf_p = buf;

	mov	DWORD PTR [ebp], ecx

; 546  : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+52]
	pop	esi
	pop	ebp
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 40					; 00000028H
	ret	0
??$AddHex@D@@YAXPAPADAAIIHH@Z ENDP			; AddHex<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
;	COMDAT ??$AddFloat@D@@YAXPAPADAAINHHH@Z
_TEXT	SEGMENT
_digits$1$ = -20					; size = 4
_fieldlength$1$ = -16					; size = 4
_width$1$ = -12						; size = 4
_sign$1$ = -8						; size = 4
_significant_digits$1$ = -4				; size = 4
_buf_p$ = 8						; size = 4
tv482 = 12						; size = 4
_maxlen$ = 12						; size = 4
_fval$ = 16						; size = 8
_width$ = 24						; size = 4
_prec$2$ = 28						; size = 4
_prec$ = 28						; size = 4
_flags$ = 32						; size = 4
??$AddFloat@D@@YAXPAPADAAINHHH@Z PROC			; AddFloat<char>, COMDAT

; 215  : {

	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR _prec$[esp+16]
	xorps	xmm0, xmm0

; 216  : 	int digits;				// non-fraction part digits
; 217  : 	double tmp;				// temporary
; 218  : 	U *buf = *buf_p;			// output buffer pointer
; 219  : 	int val;				// temporary
; 220  : 	int sign = 0;				// 0: positive, 1: negative
; 221  : 	int fieldlength;			// for padding
; 222  : 	int significant_digits = 0;		// number of significant digits written
; 223  : 	const int MAX_SIGNIFICANT_DIGITS = 16;
; 224  : 
; 225  : 	// default precision
; 226  : 	if (prec < 0)
; 227  : 	{
; 228  : 		prec = 6;
; 229  : 	}
; 230  : 
; 231  : 	// get the sign
; 232  : 	if (fval < 0)

	movsd	xmm1, QWORD PTR _fval$[esp+16]
	test	eax, eax
	push	esi
	mov	esi, DWORD PTR _buf_p$[esp+20]
	push	edi
	mov	edi, 6
	mov	DWORD PTR _sign$1$[esp+28], 0
	cmovns	edi, eax
	mov	DWORD PTR _significant_digits$1$[esp+28], 0
	comisd	xmm0, xmm1
	mov	esi, DWORD PTR [esi]
	mov	DWORD PTR _prec$2$[esp+24], edi
	jbe	SHORT $LN11@AddFloat

; 233  : 	{
; 234  : 		fval = -fval;

	xorps	xmm1, QWORD PTR __xmm@80000000000000008000000000000000
	movsd	QWORD PTR _fval$[esp+24], xmm1

; 235  : 		sign = 1;

	mov	DWORD PTR _sign$1$[esp+28], 1
$LN11@AddFloat:

; 236  : 	}
; 237  : 
; 238  : 	// compute whole-part digits count
; 239  : 	digits = (int)log10(fval) + 1;

	movaps	xmm0, xmm1
	call	__libm_sse2_log10_precise

; 240  : 
; 241  : 	// Only print 0.something if 0 < fval < 1
; 242  : 	if (digits < 1)
; 243  : 	{
; 244  : 		digits = 1;
; 245  : 	}
; 246  : 
; 247  : 	// compute the field length
; 248  : 	fieldlength = digits + prec + ((prec > 0) ? 1 : 0) + sign;

	mov	ecx, DWORD PTR _sign$1$[esp+28]
	mov	edx, 1
	cvttsd2si eax, xmm0
	inc	eax
	cmp	eax, edx
	cmovge	edx, eax
	xor	eax, eax
	test	edi, edi
	mov	DWORD PTR _digits$1$[esp+28], edx
	setg	al
	add	eax, edx
	add	eax, edi

; 249  : 
; 250  : 	// minus sign BEFORE left padding if padding with zeros
; 251  : 	if (sign && maxlen && (flags & ZEROPAD))

	mov	edi, DWORD PTR _maxlen$[esp+24]
	add	eax, ecx
	test	ecx, ecx
	mov	ecx, DWORD PTR _flags$[esp+24]
	mov	DWORD PTR _fieldlength$1$[esp+28], eax
	je	SHORT $LN13@AddFloat
	cmp	DWORD PTR [edi], 0
	je	SHORT $LN13@AddFloat
	test	cl, cl
	jns	SHORT $LN13@AddFloat

; 252  : 	{
; 253  : 		*buf++ = '-';

	mov	BYTE PTR [esi], 45			; 0000002dH
	inc	esi

; 254  : 		maxlen--;

	dec	DWORD PTR [edi]
$LN13@AddFloat:

; 255  : 	}
; 256  : 
; 257  : 	// right justify if required
; 258  : 	if ((flags & LADJUST) == 0)

	mov	DWORD PTR tv482[esp+24], ecx
	and	DWORD PTR tv482[esp+24], 4
	jne	$LN44@AddFloat

; 259  : 	{
; 260  : 		while ((fieldlength < width) && maxlen)

	mov	ecx, DWORD PTR _width$[esp+24]
	mov	DWORD PTR _width$1$[esp+28], ecx
	cmp	eax, ecx
	jge	SHORT $LN49@AddFloat
$LL2@AddFloat:
	cmp	DWORD PTR [edi], 0
	je	SHORT $LN49@AddFloat

; 261  : 		{
; 262  : 			*buf++ = (flags & ZEROPAD) ? '0' : ' ';

	mov	eax, DWORD PTR _flags$[esp+24]

; 263  : 			width--;

	dec	ecx
	shr	eax, 3
	and	al, 16					; 00000010H
	mov	DWORD PTR _width$1$[esp+28], ecx
	or	al, 32					; 00000020H
	mov	BYTE PTR [esi], al
	inc	esi

; 264  : 			maxlen--;

	dec	DWORD PTR [edi]
	cmp	DWORD PTR _fieldlength$1$[esp+28], ecx
	jl	SHORT $LL2@AddFloat
$LN49@AddFloat:
	mov	ecx, DWORD PTR _flags$[esp+24]
$LN3@AddFloat:
	cmp	DWORD PTR _sign$1$[esp+28], 0

; 265  : 		}
; 266  : 	}
; 267  : 
; 268  : 	// minus sign AFTER left padding if padding with spaces
; 269  : 	if (sign && maxlen && !(flags & ZEROPAD))

	je	SHORT $LN15@AddFloat
	cmp	DWORD PTR [edi], 0
	je	SHORT $LN15@AddFloat
	test	cl, cl
	js	SHORT $LN15@AddFloat

; 270  : 	{
; 271  : 		*buf++ = '-';

	mov	BYTE PTR [esi], 45			; 0000002dH
	inc	esi

; 272  : 		maxlen--;

	dec	DWORD PTR [edi]
$LN15@AddFloat:

; 273  : 	}
; 274  : 
; 275  : 	// write the whole part
; 276  : 	tmp = pow(10.0, digits-1);

	movsd	xmm0, QWORD PTR __real@4024000000000000
	lea	eax, DWORD PTR [edx-1]
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	call	__libm_sse2_pow_precise

; 277  : 	while ((digits--) && maxlen)

	mov	edx, DWORD PTR _digits$1$[esp+28]
	movaps	xmm2, xmm0
	movsd	xmm3, QWORD PTR __real@3fb999999999999a
	test	edx, edx
	je	SHORT $LN28@AddFloat
	npad	4
$LL4@AddFloat:
	dec	edx
	cmp	DWORD PTR [edi], 0
	je	SHORT $LN46@AddFloat

; 278  : 	{
; 279  : 		if (++significant_digits > MAX_SIGNIFICANT_DIGITS)

	mov	eax, DWORD PTR _significant_digits$1$[esp+28]
	inc	eax
	mov	DWORD PTR _significant_digits$1$[esp+28], eax
	cmp	eax, 16					; 00000010H
	jle	SHORT $LN16@AddFloat

; 280  : 		{
; 281  : 			*buf++ = '0';

	mov	BYTE PTR [esi], 48			; 00000030H

; 282  : 		}
; 283  : 		else

	jmp	SHORT $LN17@AddFloat
$LN44@AddFloat:

; 259  : 	{
; 260  : 		while ((fieldlength < width) && maxlen)

	mov	eax, DWORD PTR _width$[esp+24]
	mov	DWORD PTR _width$1$[esp+28], eax
	jmp	SHORT $LN3@AddFloat
$LN16@AddFloat:

; 284  : 		{
; 285  : 			val = (int)(fval / tmp);

	movsd	xmm1, QWORD PTR _fval$[esp+24]
	movaps	xmm0, xmm1
	divsd	xmm0, xmm2
	cvttsd2si ecx, xmm0
	movd	xmm0, ecx

; 286  : 			*buf++ = '0' + val;

	lea	eax, DWORD PTR [ecx+48]

; 287  : 			fval -= val * tmp;

	cvtdq2pd xmm0, xmm0
	mov	BYTE PTR [esi], al
	mulsd	xmm0, xmm2

; 288  : 			tmp *= 0.1;

	mulsd	xmm2, xmm3
	subsd	xmm1, xmm0
	movsd	QWORD PTR _fval$[esp+24], xmm1
$LN17@AddFloat:

; 289  : 		}
; 290  : 		maxlen--;

	dec	DWORD PTR [edi]
	inc	esi
	test	edx, edx
	jne	SHORT $LL4@AddFloat
$LN28@AddFloat:

; 291  : 	}
; 292  : 
; 293  : 	// write the fraction part
; 294  : 	if (maxlen && prec)

	cmp	DWORD PTR [edi], 0
	mov	eax, DWORD PTR _prec$2$[esp+24]
	je	SHORT $LN18@AddFloat
	test	eax, eax
	je	SHORT $LN18@AddFloat

; 295  : 	{
; 296  : 		*buf++ = '.';

	mov	BYTE PTR [esi], 46			; 0000002eH
	inc	esi

; 297  : 		maxlen--;

	dec	DWORD PTR [edi]
	jmp	SHORT $LN18@AddFloat
$LN46@AddFloat:
	mov	eax, DWORD PTR _prec$2$[esp+24]
$LN18@AddFloat:

; 298  : 	}
; 299  : 
; 300  : 	tmp = pow(10.0, prec);

	movsd	xmm0, QWORD PTR __real@4024000000000000
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	call	__libm_sse2_pow_precise

; 301  : 
; 302  : 	fval *= tmp;
; 303  : 	while (prec-- && maxlen)

	mov	edx, DWORD PTR _prec$2$[esp+24]
	movaps	xmm1, xmm0
	movaps	xmm2, xmm1
	mulsd	xmm2, QWORD PTR _fval$[esp+24]
	test	edx, edx
	je	SHORT $LN45@AddFloat
	movsd	xmm3, QWORD PTR __real@3fb999999999999a
$LL6@AddFloat:
	dec	edx
	cmp	DWORD PTR [edi], 0
	je	SHORT $LN45@AddFloat

; 304  : 	{
; 305  : 		if (++significant_digits > MAX_SIGNIFICANT_DIGITS)

	mov	eax, DWORD PTR _significant_digits$1$[esp+28]
	inc	eax
	mov	DWORD PTR _significant_digits$1$[esp+28], eax
	cmp	eax, 16					; 00000010H
	jle	SHORT $LN19@AddFloat

; 306  : 		{
; 307  : 			*buf++ = '0';

	mov	BYTE PTR [esi], 48			; 00000030H

; 308  : 		}
; 309  : 		else

	jmp	SHORT $LN20@AddFloat
$LN19@AddFloat:

; 310  : 		{
; 311  : 			tmp *= 0.1;

	mulsd	xmm1, xmm3

; 312  : 			val = (int)(fval / tmp);

	movaps	xmm0, xmm2
	divsd	xmm0, xmm1
	cvttsd2si ecx, xmm0
	movd	xmm0, ecx

; 313  : 			*buf++ = '0' + val;

	lea	eax, DWORD PTR [ecx+48]

; 314  : 			fval -= val * tmp;

	cvtdq2pd xmm0, xmm0
	mov	BYTE PTR [esi], al
	mulsd	xmm0, xmm1
	subsd	xmm2, xmm0
$LN20@AddFloat:

; 315  : 		}
; 316  : 		maxlen--;

	dec	DWORD PTR [edi]
	inc	esi
	test	edx, edx
	jne	SHORT $LL6@AddFloat
$LN45@AddFloat:
	cmp	DWORD PTR tv482[esp+24], 0

; 317  : 	}
; 318  : 
; 319  : 	// left justify if required
; 320  : 	if (flags & LADJUST)

	je	SHORT $LN43@AddFloat

; 321  : 	{
; 322  : 		while ((fieldlength < width) && maxlen)

	mov	eax, DWORD PTR _width$1$[esp+28]
	mov	ecx, DWORD PTR _fieldlength$1$[esp+28]
	cmp	ecx, eax
	jge	SHORT $LN43@AddFloat
	npad	5
$LL8@AddFloat:
	cmp	DWORD PTR [edi], 0
	je	SHORT $LN43@AddFloat

; 323  : 		{
; 324  : 			// right-padding only with spaces, ZEROPAD is ignored
; 325  : 			*buf++ = ' ';

	mov	BYTE PTR [esi], 32			; 00000020H

; 326  : 			width--;

	dec	eax

; 327  : 			maxlen--;

	dec	DWORD PTR [edi]
	inc	esi
	cmp	ecx, eax
	jl	SHORT $LL8@AddFloat
$LN43@AddFloat:

; 328  : 		}
; 329  : 	}
; 330  : 
; 331  : 	// update parent's buffer pointer
; 332  : 	*buf_p = buf;

	mov	eax, DWORD PTR _buf_p$[esp+24]
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi

; 333  : }

	add	esp, 20					; 00000014H
	ret	0
??$AddFloat@D@@YAXPAPADAAINHHH@Z ENDP			; AddFloat<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
;	COMDAT ??$AddUInt@D@@YAXPAPADAAIIHH@Z
_TEXT	SEGMENT
tv256 = -40						; size = 4
_text$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_buf_p$ = 8						; size = 4
_maxlen$ = 12						; size = 4
_val$ = 16						; size = 4
_width$ = 20						; size = 4
_flags$ = 24						; size = 4
??$AddUInt@D@@YAXPAPADAAIIHH@Z PROC			; AddUInt<char>, COMDAT

; 389  : {

	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+40], eax
	push	ebx

; 390  : 	U		text[32];
; 391  : 	int		digits;
; 392  : 	U		*buf;
; 393  : 
; 394  : 	digits = 0;

	mov	ebx, DWORD PTR _val$[esp+40]
	push	ebp
	mov	ebp, DWORD PTR _buf_p$[esp+44]
	push	esi
	mov	esi, DWORD PTR _maxlen$[esp+48]
	push	edi
	xor	edi, edi
$LL4@AddUInt:

; 395  : 	do {
; 396  : 		text[digits++] = '0' + val % 10;

	mov	eax, -858993459				; cccccccdH
	mul	ebx
	shr	edx, 3
	mov	al, dl
	shl	al, 2
	lea	ecx, DWORD PTR [eax+edx]
	add	cl, cl
	sub	bl, cl
	add	bl, 48					; 00000030H
	mov	BYTE PTR _text$[esp+edi+56], bl

; 397  : 		val /= 10;

	mov	ebx, edx
	inc	edi

; 398  : 	} while (val);

	test	ebx, ebx
	jne	SHORT $LL4@AddUInt

; 399  : 
; 400  : 	buf = *buf_p;
; 401  : 
; 402  : 	if( !(flags & LADJUST) )

	mov	ebx, DWORD PTR _flags$[esp+52]
	mov	ecx, ebx
	mov	eax, DWORD PTR [ebp]
	and	ecx, 4

; 403  : 	{
; 404  : 		while (digits < width && maxlen)

	mov	edx, DWORD PTR _width$[esp+52]
	mov	DWORD PTR tv256[esp+56], ecx
	jne	SHORT $LN16@AddUInt
	cmp	edi, edx
	jge	SHORT $LN16@AddUInt
	npad	2
$LL5@AddUInt:
	cmp	DWORD PTR [esi], 0
	je	SHORT $LN16@AddUInt

; 405  : 		{
; 406  : 			*buf++ = (flags & ZEROPAD) ? '0' : ' ';

	mov	ecx, ebx

; 407  : 			width--;

	dec	edx
	shr	ecx, 3
	and	cl, 16					; 00000010H
	or	cl, 32					; 00000020H
	mov	BYTE PTR [eax], cl
	inc	eax

; 408  : 			maxlen--;

	dec	DWORD PTR [esi]
	cmp	edi, edx
	jl	SHORT $LL5@AddUInt
$LN16@AddUInt:

; 409  : 		}
; 410  : 	}
; 411  : 
; 412  : 	while (digits-- && maxlen)

	test	edi, edi
	je	SHORT $LN35@AddUInt
	npad	2
$LL7@AddUInt:
	dec	edi
	cmp	DWORD PTR [esi], 0
	je	SHORT $LN35@AddUInt

; 413  : 	{
; 414  : 		*buf++ = text[digits];

	mov	cl, BYTE PTR _text$[esp+edi+56]

; 415  : 		width--;

	dec	edx
	mov	BYTE PTR [eax], cl
	inc	eax

; 416  : 		maxlen--;

	dec	DWORD PTR [esi]
	test	edi, edi
	jne	SHORT $LL7@AddUInt
$LN35@AddUInt:
	cmp	DWORD PTR tv256[esp+56], 0

; 417  : 	}
; 418  : 
; 419  : 	if (flags & LADJUST)

	je	SHORT $LN33@AddUInt

; 420  : 	{
; 421  : 		while (width-- && maxlen)

	test	edx, edx
	je	SHORT $LN33@AddUInt
	npad	1
$LL9@AddUInt:
	dec	edx
	cmp	DWORD PTR [esi], 0
	je	SHORT $LN33@AddUInt

; 422  : 		{
; 423  : 			*buf++ = (flags & ZEROPAD) ? '0' : ' ';

	mov	ecx, ebx
	shr	ecx, 3
	and	cl, 16					; 00000010H
	or	cl, 32					; 00000020H
	mov	BYTE PTR [eax], cl
	inc	eax

; 424  : 			maxlen--;

	dec	DWORD PTR [esi]
	test	edx, edx
	jne	SHORT $LL9@AddUInt
$LN33@AddUInt:

; 425  : 		}
; 426  : 	}
; 427  : 
; 428  : 	*buf_p = buf;
; 429  : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+56]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebp], eax
	pop	ebp
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 40					; 00000028H
	ret	0
??$AddUInt@D@@YAXPAPADAAIIHH@Z ENDP			; AddUInt<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
;	COMDAT ??$AddInt@D@@YAXPAPADAAIHHH@Z
_TEXT	SEGMENT
tv263 = -40						; size = 4
_buf_p$GSCopy$1$ = -40					; size = 4
_text$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_buf_p$ = 8						; size = 4
_maxlen$ = 12						; size = 4
_val$ = 16						; size = 4
_width$ = 20						; size = 4
_flags$ = 24						; size = 4
??$AddInt@D@@YAXPAPADAAIHHH@Z PROC			; AddInt<char>, COMDAT

; 433  : {

	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+40], eax
	mov	eax, DWORD PTR _buf_p$[esp+36]
	push	ebx
	push	ebp

; 434  : 	U		text[32];
; 435  : 	int		digits;
; 436  : 	int		signedVal;
; 437  : 	U		*buf;
; 438  : 	unsigned int unsignedVal;
; 439  : 
; 440  : 	digits = 0;
; 441  : 	signedVal = val;
; 442  : 	if (val < 0)

	mov	ebp, DWORD PTR _val$[esp+44]
	push	esi
	mov	esi, DWORD PTR _maxlen$[esp+48]
	push	edi
	xor	edi, edi
	mov	DWORD PTR _buf_p$GSCopy$1$[esp+56], eax
	test	ebp, ebp
	jns	SHORT $LN11@AddInt

; 443  : 	{
; 444  : 		/* we want the unsigned version */
; 445  : 		unsignedVal = abs(val);

	mov	eax, ebp
	cdq
	mov	ebx, eax
	xor	ebx, edx
	sub	ebx, edx

; 446  : 	} else {

	jmp	SHORT $LL4@AddInt
$LN11@AddInt:

; 447  : 		unsignedVal = val;

	mov	ebx, ebp
$LL4@AddInt:

; 448  : 	}
; 449  : 	do {
; 450  : 		text[digits++] = '0' + unsignedVal % 10;

	mov	eax, -858993459				; cccccccdH
	mul	ebx
	shr	edx, 3
	mov	al, dl
	shl	al, 2
	lea	ecx, DWORD PTR [eax+edx]
	add	cl, cl
	sub	bl, cl
	add	bl, 48					; 00000030H
	mov	BYTE PTR _text$[esp+edi+56], bl

; 451  : 		unsignedVal /= 10;

	mov	ebx, edx
	inc	edi

; 452  : 	} while (unsignedVal);

	test	ebx, ebx
	jne	SHORT $LL4@AddInt

; 453  : 
; 454  : 	if (signedVal < 0)

	test	ebp, ebp
	jns	SHORT $LN13@AddInt

; 455  : 		text[digits++] = '-';

	mov	BYTE PTR _text$[esp+edi+56], 45		; 0000002dH
	inc	edi
$LN13@AddInt:

; 456  : 
; 457  : 	buf = *buf_p;

	mov	ebp, DWORD PTR _buf_p$GSCopy$1$[esp+56]

; 458  : 
; 459  : 	if( !(flags & LADJUST) )

	mov	ebx, DWORD PTR _flags$[esp+52]
	mov	ecx, ebx

; 460  : 	{
; 461  : 		while (digits < width && maxlen)

	mov	edx, DWORD PTR _width$[esp+52]
	and	ecx, 4
	mov	DWORD PTR tv263[esp+56], ecx
	mov	eax, DWORD PTR [ebp]
	jne	SHORT $LN19@AddInt
	cmp	edi, edx
	jge	SHORT $LN19@AddInt
$LL5@AddInt:
	cmp	DWORD PTR [esi], 0
	je	SHORT $LN19@AddInt

; 462  : 		{
; 463  : 			*buf++ = (flags & ZEROPAD) ? '0' : ' ';

	mov	ecx, ebx

; 464  : 			width--;

	dec	edx
	shr	ecx, 3
	and	cl, 16					; 00000010H
	or	cl, 32					; 00000020H
	mov	BYTE PTR [eax], cl
	inc	eax

; 465  : 			maxlen--;

	dec	DWORD PTR [esi]
	cmp	edi, edx
	jl	SHORT $LL5@AddInt
$LN19@AddInt:

; 466  : 		}
; 467  : 	}
; 468  : 
; 469  : 	while (digits-- && maxlen)

	test	edi, edi
	je	SHORT $LN66@AddInt
	npad	1
$LL7@AddInt:
	dec	edi
	cmp	DWORD PTR [esi], 0
	je	SHORT $LN66@AddInt

; 470  : 	{
; 471  : 		*buf++ = text[digits];

	mov	cl, BYTE PTR _text$[esp+edi+56]

; 472  : 		width--;

	dec	edx
	mov	BYTE PTR [eax], cl
	inc	eax

; 473  : 		maxlen--;

	dec	DWORD PTR [esi]
	test	edi, edi
	jne	SHORT $LL7@AddInt
$LN66@AddInt:
	cmp	DWORD PTR tv263[esp+56], 0

; 474  : 	}
; 475  : 
; 476  : 	if (flags & LADJUST)

	je	SHORT $LN64@AddInt

; 477  : 	{
; 478  : 		while (width-- && maxlen)

	test	edx, edx
	je	SHORT $LN64@AddInt
	npad	1
$LL9@AddInt:
	dec	edx
	cmp	DWORD PTR [esi], 0
	je	SHORT $LN64@AddInt

; 479  : 		{
; 480  : 			*buf++ = (flags & ZEROPAD) ? '0' : ' ';

	mov	ecx, ebx
	shr	ecx, 3
	and	cl, 16					; 00000010H
	or	cl, 32					; 00000020H
	mov	BYTE PTR [eax], cl
	inc	eax

; 481  : 			maxlen--;

	dec	DWORD PTR [esi]
	test	edx, edx
	jne	SHORT $LL9@AddInt
$LN64@AddInt:

; 482  : 		}
; 483  : 	}
; 484  : 
; 485  : 	*buf_p = buf;
; 486  : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+56]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebp], eax
	pop	ebp
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 40					; 00000028H
	ret	0
??$AddInt@D@@YAXPAPADAAIHHH@Z ENDP			; AddInt<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
;	COMDAT ??$AddBinary@D@@YAXPAPADAAIIHH@Z
_TEXT	SEGMENT
tv274 = -40						; size = 4
_text$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_buf_p$ = 8						; size = 4
_maxlen$ = 12						; size = 4
_val$ = 16						; size = 4
_width$ = 20						; size = 4
_flags$ = 24						; size = 4
??$AddBinary@D@@YAXPAPADAAIIHH@Z PROC			; AddBinary<char>, COMDAT

; 337  : {

	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+40], eax
	mov	edx, DWORD PTR _maxlen$[esp+36]

; 338  : 	char text[32];
; 339  : 	int digits;
; 340  : 	U *buf;
; 341  : 
; 342  : 	digits = 0;

	mov	ecx, DWORD PTR _val$[esp+36]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _buf_p$[esp+44]
	push	esi
	push	edi
	xor	edi, edi
$LL4@AddBinary:

; 343  : 	do
; 344  : 	{
; 345  : 		if (val & 1)

	mov	al, cl
	and	al, 1
	or	al, 48					; 00000030H
	mov	BYTE PTR _text$[esp+edi+56], al
	inc	edi

; 346  : 		{
; 347  : 			text[digits++] = '1';
; 348  : 		}
; 349  : 		else
; 350  : 		{
; 351  : 			text[digits++] = '0';
; 352  : 		}
; 353  : 		val >>= 1;

	shr	ecx, 1

; 354  : 	} while (val);

	jne	SHORT $LL4@AddBinary

; 355  : 
; 356  : 	buf = *buf_p;
; 357  : 
; 358  : 	if (!(flags & LADJUST))

	mov	ebx, DWORD PTR _flags$[esp+52]
	mov	eax, ebx
	mov	ecx, DWORD PTR [ebp]
	and	eax, 4

; 359  : 	{
; 360  : 		while (digits < width && maxlen)

	mov	esi, DWORD PTR _width$[esp+52]
	mov	DWORD PTR tv274[esp+56], eax
	jne	SHORT $LN18@AddBinary
	cmp	edi, esi
	jge	SHORT $LN18@AddBinary
	npad	7
$LL5@AddBinary:
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN18@AddBinary

; 361  : 		{
; 362  : 			*buf++ = (flags & ZEROPAD) ? '0' : ' ';

	mov	eax, ebx

; 363  : 			width--;

	dec	esi
	shr	eax, 3
	and	al, 16					; 00000010H
	or	al, 32					; 00000020H
	mov	BYTE PTR [ecx], al
	inc	ecx

; 364  : 			maxlen--;

	dec	DWORD PTR [edx]
	cmp	edi, esi
	jl	SHORT $LL5@AddBinary
$LN18@AddBinary:

; 365  : 		}
; 366  : 	}
; 367  : 
; 368  : 	while (digits-- && maxlen)

	test	edi, edi
	je	SHORT $LN37@AddBinary
	npad	4
$LL7@AddBinary:
	dec	edi
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN37@AddBinary

; 369  : 	{
; 370  : 		*buf++ = text[digits];

	mov	al, BYTE PTR _text$[esp+edi+56]

; 371  : 		width--;

	dec	esi
	mov	BYTE PTR [ecx], al
	inc	ecx

; 372  : 		maxlen--;

	dec	DWORD PTR [edx]
	test	edi, edi
	jne	SHORT $LL7@AddBinary
$LN37@AddBinary:
	cmp	DWORD PTR tv274[esp+56], 0

; 373  : 	}
; 374  : 
; 375  : 	if (flags & LADJUST)

	je	SHORT $LN35@AddBinary

; 376  : 	{
; 377  : 		while (width-- && maxlen)

	test	esi, esi
	je	SHORT $LN35@AddBinary
	npad	1
$LL9@AddBinary:
	dec	esi
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN35@AddBinary

; 378  : 		{
; 379  : 			*buf++ = (flags & ZEROPAD) ? '0' : ' ';

	mov	eax, ebx
	shr	eax, 3
	and	al, 16					; 00000010H
	or	al, 32					; 00000020H
	mov	BYTE PTR [ecx], al
	inc	ecx

; 380  : 			maxlen--;

	dec	DWORD PTR [edx]
	test	esi, esi
	jne	SHORT $LL9@AddBinary
$LN35@AddBinary:
	pop	edi

; 381  : 		}
; 382  : 	}
; 383  : 
; 384  : 	*buf_p = buf;

	mov	DWORD PTR [ebp], ecx

; 385  : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+52]
	pop	esi
	pop	ebp
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 40					; 00000028H
	ret	0
??$AddBinary@D@@YAXPAPADAAIIHH@Z ENDP			; AddBinary<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
;	COMDAT ??$AddString@HD@@YAXPAPAHAAIPBDHH@Z
_TEXT	SEGMENT
_buf_p$ = 8						; size = 4
_maxlen$ = 12						; size = 4
_string$ = 16						; size = 4
_width$ = 20						; size = 4
_prec$ = 24						; size = 4
??$AddString@HD@@YAXPAPAHAAIPBDHH@Z PROC		; AddString<int,char>, COMDAT

; 164  : {

	mov	eax, DWORD PTR _string$[esp-4]

; 165  : 	int		size = 0;

	xor	ecx, ecx
	push	ebx
	test	eax, eax
	mov	ebx, OFFSET ?nlstr@?1???$AddString@HD@@YAXPAPAHAAIPBDHH@Z@4PADA ; `AddString<int,char>'::`2'::nlstr
	push	ebp
	cmovne	ebx, eax
	or	edx, -1
	push	esi
	push	edi

; 166  : 	U		*buf;
; 167  : 	static S nlstr[] = {'(','n','u','l','l',')','\0'};
; 168  : 
; 169  : 	buf = *buf_p;

	mov	edi, DWORD PTR _buf_p$[esp+12]
	test	eax, eax
	cmovne	edx, DWORD PTR _prec$[esp+12]
	mov	edi, DWORD PTR [edi]

; 170  : 
; 171  : 	if (string == NULL)
; 172  : 	{
; 173  : 		string = nlstr;
; 174  : 		prec = -1;
; 175  : 	}
; 176  : 
; 177  : 	if (prec >= 0)

	test	edx, edx
	js	SHORT $LL5@AddString

; 178  : 	{
; 179  : 		for (size = 0; size < prec; size++) 

	xor	esi, esi
	test	edx, edx
	jle	SHORT $LN13@AddString
	npad	2
$LL4@AddString:

; 180  : 		{
; 181  : 			if (string[size] == '\0')

	cmp	BYTE PTR [ebx+esi], cl
	je	SHORT $LN13@AddString

; 178  : 	{
; 179  : 		for (size = 0; size < prec; size++) 

	inc	esi
	cmp	esi, edx
	jl	SHORT $LL4@AddString

; 182  : 				break;
; 183  : 		}
; 184  : 	} else {

	jmp	SHORT $LN13@AddString
	npad	4
$LL5@AddString:

; 185  : 		while (string[size++]) ;

	mov	al, BYTE PTR [ebx+ecx]
	mov	esi, ecx
	inc	ecx
	test	al, al
	jne	SHORT $LL5@AddString
$LN13@AddString:

; 186  : 		size--;
; 187  : 	}
; 188  : 
; 189  : 	if (size > (int)maxlen)

	mov	ebp, DWORD PTR _maxlen$[esp+12]
	cmp	esi, DWORD PTR [ebp]
	cmovg	esi, DWORD PTR [ebp]

; 190  : 		size = maxlen;
; 191  : 
; 192  : 	/* If precision is provided, make sure we don't truncate a multi-byte character */
; 193  : 	if (prec >= size && (string[size - 1] & 1 << 7))

	cmp	edx, esi
	jl	SHORT $LN16@AddString
	cmp	BYTE PTR [ebx+esi-1], 0
	jge	SHORT $LN16@AddString

; 194  : 	{
; 195  : 		size -= UTIL_CheckValidChar((cell *)string + size - 1);

	lea	eax, DWORD PTR [ebx-4]
	lea	eax, DWORD PTR [eax+esi*4]
	push	eax
	call	??$UTIL_CheckValidChar@H@@YAHPAH@Z	; UTIL_CheckValidChar<int>
	add	esp, 4
	sub	esi, eax
$LN16@AddString:

; 196  : 	}
; 197  : 
; 198  : 	maxlen -= size;
; 199  : 	width -= size;

	mov	ecx, DWORD PTR _width$[esp+12]
	sub	DWORD PTR [ebp], esi
	sub	ecx, esi

; 200  : 
; 201  : 	while (size--)

	test	esi, esi
	je	SHORT $LN24@AddString
	npad	2
$LL7@AddString:

; 202  : 		*buf++ = static_cast<U>(*string++);

	movsx	eax, BYTE PTR [ebx]
	lea	ebx, DWORD PTR [ebx+1]
	mov	DWORD PTR [edi], eax
	add	edi, 4
	sub	esi, 1
	jne	SHORT $LL7@AddString
$LN24@AddString:

; 203  : 
; 204  : 	while (width-- > 0 && maxlen)

	test	ecx, ecx
	jle	SHORT $LN60@AddString
$LL9@AddString:
	dec	ecx
	cmp	DWORD PTR [ebp], 0
	je	SHORT $LN60@AddString

; 205  : 	{
; 206  : 		*buf++ = ' ';

	mov	DWORD PTR [edi], 32			; 00000020H
	add	edi, 4

; 207  : 		maxlen--;

	dec	DWORD PTR [ebp]
	test	ecx, ecx
	jg	SHORT $LL9@AddString
$LN60@AddString:

; 208  : 	}
; 209  : 
; 210  : 	*buf_p = buf;

	mov	eax, DWORD PTR _buf_p$[esp+12]
	mov	DWORD PTR [eax], edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 211  : }

	ret	0
??$AddString@HD@@YAXPAPAHAAIPBDHH@Z ENDP		; AddString<int,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
;	COMDAT ??$AddString@HH@@YAXPAPAHAAIPBHHH@Z
_TEXT	SEGMENT
_buf_p$ = 8						; size = 4
_maxlen$ = 12						; size = 4
_string$ = 16						; size = 4
_width$ = 20						; size = 4
_prec$ = 24						; size = 4
??$AddString@HH@@YAXPAPAHAAIPBHHH@Z PROC		; AddString<int,int>, COMDAT

; 164  : {

	mov	eax, DWORD PTR _string$[esp-4]

; 165  : 	int		size = 0;

	xor	ecx, ecx
	push	ebx
	test	eax, eax
	mov	ebx, OFFSET ?nlstr@?1???$AddString@HH@@YAXPAPAHAAIPBHHH@Z@4PAHA ; `AddString<int,int>'::`2'::nlstr
	push	ebp
	cmovne	ebx, eax
	or	edx, -1
	push	esi
	push	edi

; 166  : 	U		*buf;
; 167  : 	static S nlstr[] = {'(','n','u','l','l',')','\0'};
; 168  : 
; 169  : 	buf = *buf_p;

	mov	edi, DWORD PTR _buf_p$[esp+12]
	test	eax, eax
	cmovne	edx, DWORD PTR _prec$[esp+12]
	mov	edi, DWORD PTR [edi]

; 170  : 
; 171  : 	if (string == NULL)
; 172  : 	{
; 173  : 		string = nlstr;
; 174  : 		prec = -1;
; 175  : 	}
; 176  : 
; 177  : 	if (prec >= 0)

	test	edx, edx
	js	SHORT $LL5@AddString

; 178  : 	{
; 179  : 		for (size = 0; size < prec; size++) 

	xor	esi, esi
	test	edx, edx
	jle	SHORT $LN13@AddString
	npad	2
$LL4@AddString:

; 180  : 		{
; 181  : 			if (string[size] == '\0')

	cmp	DWORD PTR [ebx+esi*4], ecx
	je	SHORT $LN13@AddString

; 178  : 	{
; 179  : 		for (size = 0; size < prec; size++) 

	inc	esi
	cmp	esi, edx
	jl	SHORT $LL4@AddString

; 182  : 				break;
; 183  : 		}
; 184  : 	} else {

	jmp	SHORT $LN13@AddString
	npad	4
$LL5@AddString:

; 185  : 		while (string[size++]) ;

	mov	eax, DWORD PTR [ebx+ecx*4]
	mov	esi, ecx
	inc	ecx
	test	eax, eax
	jne	SHORT $LL5@AddString
$LN13@AddString:

; 186  : 		size--;
; 187  : 	}
; 188  : 
; 189  : 	if (size > (int)maxlen)

	mov	ebp, DWORD PTR _maxlen$[esp+12]
	cmp	esi, DWORD PTR [ebp]
	cmovg	esi, DWORD PTR [ebp]

; 190  : 		size = maxlen;
; 191  : 
; 192  : 	/* If precision is provided, make sure we don't truncate a multi-byte character */
; 193  : 	if (prec >= size && (string[size - 1] & 1 << 7))

	cmp	edx, esi
	jl	SHORT $LN16@AddString
	lea	eax, DWORD PTR [ebx-4]
	test	BYTE PTR [eax+esi*4], 128		; 00000080H
	lea	eax, DWORD PTR [eax+esi*4]
	je	SHORT $LN16@AddString

; 194  : 	{
; 195  : 		size -= UTIL_CheckValidChar((cell *)string + size - 1);

	push	eax
	call	??$UTIL_CheckValidChar@H@@YAHPAH@Z	; UTIL_CheckValidChar<int>
	add	esp, 4
	sub	esi, eax
$LN16@AddString:

; 196  : 	}
; 197  : 
; 198  : 	maxlen -= size;
; 199  : 	width -= size;

	mov	ecx, DWORD PTR _width$[esp+12]
	sub	DWORD PTR [ebp], esi
	sub	ecx, esi

; 200  : 
; 201  : 	while (size--)

	test	esi, esi
	je	SHORT $LN24@AddString
	npad	3
$LL7@AddString:

; 202  : 		*buf++ = static_cast<U>(*string++);

	mov	eax, DWORD PTR [ebx]
	lea	ebx, DWORD PTR [ebx+4]
	mov	DWORD PTR [edi], eax
	add	edi, 4
	sub	esi, 1
	jne	SHORT $LL7@AddString
$LN24@AddString:

; 203  : 
; 204  : 	while (width-- > 0 && maxlen)

	test	ecx, ecx
	jle	SHORT $LN60@AddString
$LL9@AddString:
	dec	ecx
	cmp	DWORD PTR [ebp], 0
	je	SHORT $LN60@AddString

; 205  : 	{
; 206  : 		*buf++ = ' ';

	mov	DWORD PTR [edi], 32			; 00000020H
	add	edi, 4

; 207  : 		maxlen--;

	dec	DWORD PTR [ebp]
	test	ecx, ecx
	jg	SHORT $LL9@AddString
$LN60@AddString:

; 208  : 	}
; 209  : 
; 210  : 	*buf_p = buf;

	mov	eax, DWORD PTR _buf_p$[esp+12]
	mov	DWORD PTR [eax], edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 211  : }

	ret	0
??$AddString@HH@@YAXPAPAHAAIPBHHH@Z ENDP		; AddString<int,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
;	COMDAT ??$AddHex@H@@YAXPAPAHAAIIHH@Z
_TEXT	SEGMENT
tv314 = -136						; size = 4
_buf_p$GSCopy$1$ = -136					; size = 4
_text$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_buf_p$ = 8						; size = 4
_maxlen$ = 12						; size = 4
_val$ = 16						; size = 4
_width$ = 20						; size = 4
_flags$ = 24						; size = 4
??$AddHex@H@@YAXPAPAHAAIIHH@Z PROC			; AddHex<int>, COMDAT

; 490  : {

	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+136], eax
	mov	eax, DWORD PTR _buf_p$[esp+132]
	mov	edx, DWORD PTR _maxlen$[esp+132]
	push	ebx

; 491  : 	U		text[32];
; 492  : 	int		digits;
; 493  : 	U		*buf;
; 494  : 	U		digit;
; 495  : 	int		hexadjust;
; 496  : 
; 497  : 	if (flags & UPPERDIGITS)
; 498  : 	{
; 499  : 		hexadjust = 'A' - '9' - 1;
; 500  : 	} else {
; 501  : 		hexadjust = 'a' - '9' - 1;
; 502  : 	}
; 503  : 
; 504  : 	digits = 0;

	mov	ebx, DWORD PTR _val$[esp+136]
	push	ebp
	mov	ebp, DWORD PTR _flags$[esp+140]
	push	esi
	mov	esi, ebp
	mov	DWORD PTR _buf_p$GSCopy$1$[esp+148], eax
	shr	esi, 4
	not	esi
	and	esi, 32					; 00000020H
	push	edi
	or	esi, 7
	xor	edi, edi
$LL4@AddHex:

; 505  : 	do
; 506  : 	{
; 507  : 		digit = ('0' + val % 16);

	mov	eax, ebx
	and	eax, 15					; 0000000fH
	add	eax, 48					; 00000030H
	cmp	eax, 57					; 00000039H
	lea	ecx, DWORD PTR [esi+eax]
	cmovbe	ecx, eax

; 508  : 		if (digit > '9')
; 509  : 		{
; 510  : 			digit += hexadjust;
; 511  : 		}
; 512  : 
; 513  : 		text[digits++] = digit;
; 514  : 		val /= 16;

	shr	ebx, 4
	mov	DWORD PTR _text$[esp+edi*4+152], ecx
	inc	edi

; 515  : 	} while (val);

	test	ebx, ebx
	jne	SHORT $LL4@AddHex

; 516  : 
; 517  : 	buf = *buf_p;

	mov	ebx, DWORD PTR _buf_p$GSCopy$1$[esp+152]

; 518  : 
; 519  : 	if( !(flags & LADJUST) )

	mov	eax, ebp

; 520  : 	{
; 521  : 		while (digits < width && maxlen)

	mov	esi, DWORD PTR _width$[esp+148]
	and	eax, 4
	mov	DWORD PTR tv314[esp+152], eax
	mov	ecx, DWORD PTR [ebx]
	jne	SHORT $LN19@AddHex
	cmp	edi, esi
	jge	SHORT $LN19@AddHex
$LL5@AddHex:
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN19@AddHex

; 522  : 		{
; 523  : 			*buf++ = (flags & ZEROPAD) ? '0' : ' ';

	mov	eax, ebp

; 524  : 			width--;

	dec	esi
	shr	eax, 3
	and	eax, 16					; 00000010H
	or	eax, 32					; 00000020H
	mov	DWORD PTR [ecx], eax
	add	ecx, 4

; 525  : 			maxlen--;

	dec	DWORD PTR [edx]
	cmp	edi, esi
	jl	SHORT $LL5@AddHex
$LN19@AddHex:

; 526  : 		}
; 527  : 	}
; 528  : 
; 529  : 	while (digits-- && maxlen)

	test	edi, edi
	je	SHORT $LN38@AddHex
$LL7@AddHex:
	dec	edi
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN38@AddHex

; 530  : 	{
; 531  : 		*buf++ = text[digits];

	mov	eax, DWORD PTR _text$[esp+edi*4+152]

; 532  : 		width--;

	dec	esi
	mov	DWORD PTR [ecx], eax
	add	ecx, 4

; 533  : 		maxlen--;

	dec	DWORD PTR [edx]
	test	edi, edi
	jne	SHORT $LL7@AddHex
$LN38@AddHex:
	cmp	DWORD PTR tv314[esp+152], 0

; 534  : 	}
; 535  : 
; 536  : 	if (flags & LADJUST)

	je	SHORT $LN36@AddHex

; 537  : 	{
; 538  : 		while (width-- && maxlen)

	test	esi, esi
	je	SHORT $LN36@AddHex
$LL9@AddHex:
	dec	esi
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN36@AddHex

; 539  : 		{
; 540  : 			*buf++ = (flags & ZEROPAD) ? '0' : ' ';

	mov	eax, ebp
	shr	eax, 3
	and	eax, 16					; 00000010H
	or	eax, 32					; 00000020H
	mov	DWORD PTR [ecx], eax
	add	ecx, 4

; 541  : 			maxlen--;

	dec	DWORD PTR [edx]
	test	esi, esi
	jne	SHORT $LL9@AddHex
$LN36@AddHex:
	pop	edi
	pop	esi

; 542  : 		}
; 543  : 	}
; 544  : 
; 545  : 	*buf_p = buf;

	mov	DWORD PTR [ebx], ecx

; 546  : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+144]
	pop	ebp
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 136				; 00000088H
	ret	0
??$AddHex@H@@YAXPAPAHAAIIHH@Z ENDP			; AddHex<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
;	COMDAT ??$AddFloat@H@@YAXPAPAHAAINHHH@Z
_TEXT	SEGMENT
_digits$1$ = -20					; size = 4
_fieldlength$1$ = -16					; size = 4
_width$1$ = -12						; size = 4
_sign$1$ = -8						; size = 4
_significant_digits$1$ = -4				; size = 4
_buf_p$ = 8						; size = 4
tv478 = 12						; size = 4
_maxlen$ = 12						; size = 4
_fval$ = 16						; size = 8
_width$ = 24						; size = 4
_prec$2$ = 28						; size = 4
_prec$ = 28						; size = 4
_flags$ = 32						; size = 4
??$AddFloat@H@@YAXPAPAHAAINHHH@Z PROC			; AddFloat<int>, COMDAT

; 215  : {

	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR _prec$[esp+16]
	xorps	xmm0, xmm0

; 216  : 	int digits;				// non-fraction part digits
; 217  : 	double tmp;				// temporary
; 218  : 	U *buf = *buf_p;			// output buffer pointer
; 219  : 	int val;				// temporary
; 220  : 	int sign = 0;				// 0: positive, 1: negative
; 221  : 	int fieldlength;			// for padding
; 222  : 	int significant_digits = 0;		// number of significant digits written
; 223  : 	const int MAX_SIGNIFICANT_DIGITS = 16;
; 224  : 
; 225  : 	// default precision
; 226  : 	if (prec < 0)
; 227  : 	{
; 228  : 		prec = 6;
; 229  : 	}
; 230  : 
; 231  : 	// get the sign
; 232  : 	if (fval < 0)

	movsd	xmm1, QWORD PTR _fval$[esp+16]
	test	eax, eax
	push	esi
	mov	esi, DWORD PTR _buf_p$[esp+20]
	push	edi
	mov	edi, 6
	mov	DWORD PTR _sign$1$[esp+28], 0
	cmovns	edi, eax
	mov	DWORD PTR _significant_digits$1$[esp+28], 0
	comisd	xmm0, xmm1
	mov	esi, DWORD PTR [esi]
	mov	DWORD PTR _prec$2$[esp+24], edi
	jbe	SHORT $LN11@AddFloat

; 233  : 	{
; 234  : 		fval = -fval;

	xorps	xmm1, QWORD PTR __xmm@80000000000000008000000000000000
	movsd	QWORD PTR _fval$[esp+24], xmm1

; 235  : 		sign = 1;

	mov	DWORD PTR _sign$1$[esp+28], 1
$LN11@AddFloat:

; 236  : 	}
; 237  : 
; 238  : 	// compute whole-part digits count
; 239  : 	digits = (int)log10(fval) + 1;

	movaps	xmm0, xmm1
	call	__libm_sse2_log10_precise

; 240  : 
; 241  : 	// Only print 0.something if 0 < fval < 1
; 242  : 	if (digits < 1)
; 243  : 	{
; 244  : 		digits = 1;
; 245  : 	}
; 246  : 
; 247  : 	// compute the field length
; 248  : 	fieldlength = digits + prec + ((prec > 0) ? 1 : 0) + sign;

	mov	ecx, DWORD PTR _sign$1$[esp+28]
	mov	edx, 1
	cvttsd2si eax, xmm0
	inc	eax
	cmp	eax, edx
	cmovge	edx, eax
	xor	eax, eax
	test	edi, edi
	mov	DWORD PTR _digits$1$[esp+28], edx
	setg	al
	add	eax, edx
	add	eax, edi

; 249  : 
; 250  : 	// minus sign BEFORE left padding if padding with zeros
; 251  : 	if (sign && maxlen && (flags & ZEROPAD))

	mov	edi, DWORD PTR _maxlen$[esp+24]
	add	eax, ecx
	test	ecx, ecx
	mov	ecx, DWORD PTR _flags$[esp+24]
	mov	DWORD PTR _fieldlength$1$[esp+28], eax
	je	SHORT $LN13@AddFloat
	cmp	DWORD PTR [edi], 0
	je	SHORT $LN13@AddFloat
	test	cl, cl
	jns	SHORT $LN13@AddFloat

; 252  : 	{
; 253  : 		*buf++ = '-';

	mov	DWORD PTR [esi], 45			; 0000002dH
	add	esi, 4

; 254  : 		maxlen--;

	dec	DWORD PTR [edi]
$LN13@AddFloat:

; 255  : 	}
; 256  : 
; 257  : 	// right justify if required
; 258  : 	if ((flags & LADJUST) == 0)

	mov	DWORD PTR tv478[esp+24], ecx
	and	DWORD PTR tv478[esp+24], 4
	jne	$LN44@AddFloat

; 259  : 	{
; 260  : 		while ((fieldlength < width) && maxlen)

	mov	ecx, DWORD PTR _width$[esp+24]
	mov	DWORD PTR _width$1$[esp+28], ecx
	cmp	eax, ecx
	jge	SHORT $LN49@AddFloat
	npad	4
$LL2@AddFloat:
	cmp	DWORD PTR [edi], 0
	je	SHORT $LN49@AddFloat

; 261  : 		{
; 262  : 			*buf++ = (flags & ZEROPAD) ? '0' : ' ';

	mov	eax, DWORD PTR _flags$[esp+24]

; 263  : 			width--;

	dec	ecx
	shr	eax, 3
	and	eax, 16					; 00000010H
	mov	DWORD PTR _width$1$[esp+28], ecx
	or	eax, 32					; 00000020H
	mov	DWORD PTR [esi], eax
	add	esi, 4

; 264  : 			maxlen--;

	dec	DWORD PTR [edi]
	cmp	DWORD PTR _fieldlength$1$[esp+28], ecx
	jl	SHORT $LL2@AddFloat
$LN49@AddFloat:
	mov	ecx, DWORD PTR _flags$[esp+24]
$LN3@AddFloat:
	cmp	DWORD PTR _sign$1$[esp+28], 0

; 265  : 		}
; 266  : 	}
; 267  : 
; 268  : 	// minus sign AFTER left padding if padding with spaces
; 269  : 	if (sign && maxlen && !(flags & ZEROPAD))

	je	SHORT $LN15@AddFloat
	cmp	DWORD PTR [edi], 0
	je	SHORT $LN15@AddFloat
	test	cl, cl
	js	SHORT $LN15@AddFloat

; 270  : 	{
; 271  : 		*buf++ = '-';

	mov	DWORD PTR [esi], 45			; 0000002dH
	add	esi, 4

; 272  : 		maxlen--;

	dec	DWORD PTR [edi]
$LN15@AddFloat:

; 273  : 	}
; 274  : 
; 275  : 	// write the whole part
; 276  : 	tmp = pow(10.0, digits-1);

	movsd	xmm0, QWORD PTR __real@4024000000000000
	lea	eax, DWORD PTR [edx-1]
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	call	__libm_sse2_pow_precise

; 277  : 	while ((digits--) && maxlen)

	mov	edx, DWORD PTR _digits$1$[esp+28]
	movaps	xmm2, xmm0
	movsd	xmm3, QWORD PTR __real@3fb999999999999a
	test	edx, edx
	je	SHORT $LN28@AddFloat
	npad	2
$LL4@AddFloat:
	dec	edx
	cmp	DWORD PTR [edi], 0
	je	SHORT $LN46@AddFloat

; 278  : 	{
; 279  : 		if (++significant_digits > MAX_SIGNIFICANT_DIGITS)

	mov	eax, DWORD PTR _significant_digits$1$[esp+28]
	inc	eax
	mov	DWORD PTR _significant_digits$1$[esp+28], eax
	cmp	eax, 16					; 00000010H
	jle	SHORT $LN16@AddFloat

; 280  : 		{
; 281  : 			*buf++ = '0';

	mov	DWORD PTR [esi], 48			; 00000030H

; 282  : 		}
; 283  : 		else

	jmp	SHORT $LN17@AddFloat
$LN44@AddFloat:

; 259  : 	{
; 260  : 		while ((fieldlength < width) && maxlen)

	mov	eax, DWORD PTR _width$[esp+24]
	mov	DWORD PTR _width$1$[esp+28], eax
	jmp	SHORT $LN3@AddFloat
$LN16@AddFloat:

; 284  : 		{
; 285  : 			val = (int)(fval / tmp);

	movsd	xmm1, QWORD PTR _fval$[esp+24]
	movaps	xmm0, xmm1
	divsd	xmm0, xmm2
	cvttsd2si ecx, xmm0
	movd	xmm0, ecx

; 286  : 			*buf++ = '0' + val;

	lea	eax, DWORD PTR [ecx+48]

; 287  : 			fval -= val * tmp;

	cvtdq2pd xmm0, xmm0
	mov	DWORD PTR [esi], eax
	mulsd	xmm0, xmm2

; 288  : 			tmp *= 0.1;

	mulsd	xmm2, xmm3
	subsd	xmm1, xmm0
	movsd	QWORD PTR _fval$[esp+24], xmm1
$LN17@AddFloat:

; 289  : 		}
; 290  : 		maxlen--;

	dec	DWORD PTR [edi]
	add	esi, 4
	test	edx, edx
	jne	SHORT $LL4@AddFloat
$LN28@AddFloat:

; 291  : 	}
; 292  : 
; 293  : 	// write the fraction part
; 294  : 	if (maxlen && prec)

	cmp	DWORD PTR [edi], 0
	mov	eax, DWORD PTR _prec$2$[esp+24]
	je	SHORT $LN18@AddFloat
	test	eax, eax
	je	SHORT $LN18@AddFloat

; 295  : 	{
; 296  : 		*buf++ = '.';

	mov	DWORD PTR [esi], 46			; 0000002eH
	add	esi, 4

; 297  : 		maxlen--;

	dec	DWORD PTR [edi]
	jmp	SHORT $LN18@AddFloat
$LN46@AddFloat:
	mov	eax, DWORD PTR _prec$2$[esp+24]
$LN18@AddFloat:

; 298  : 	}
; 299  : 
; 300  : 	tmp = pow(10.0, prec);

	movsd	xmm0, QWORD PTR __real@4024000000000000
	movd	xmm1, eax
	cvtdq2pd xmm1, xmm1
	call	__libm_sse2_pow_precise

; 301  : 
; 302  : 	fval *= tmp;
; 303  : 	while (prec-- && maxlen)

	mov	edx, DWORD PTR _prec$2$[esp+24]
	movaps	xmm1, xmm0
	movaps	xmm2, xmm1
	mulsd	xmm2, QWORD PTR _fval$[esp+24]
	test	edx, edx
	je	SHORT $LN45@AddFloat
	movsd	xmm3, QWORD PTR __real@3fb999999999999a
	npad	2
$LL6@AddFloat:
	dec	edx
	cmp	DWORD PTR [edi], 0
	je	SHORT $LN45@AddFloat

; 304  : 	{
; 305  : 		if (++significant_digits > MAX_SIGNIFICANT_DIGITS)

	mov	eax, DWORD PTR _significant_digits$1$[esp+28]
	inc	eax
	mov	DWORD PTR _significant_digits$1$[esp+28], eax
	cmp	eax, 16					; 00000010H
	jle	SHORT $LN19@AddFloat

; 306  : 		{
; 307  : 			*buf++ = '0';

	mov	DWORD PTR [esi], 48			; 00000030H

; 308  : 		}
; 309  : 		else

	jmp	SHORT $LN20@AddFloat
$LN19@AddFloat:

; 310  : 		{
; 311  : 			tmp *= 0.1;

	mulsd	xmm1, xmm3

; 312  : 			val = (int)(fval / tmp);

	movaps	xmm0, xmm2
	divsd	xmm0, xmm1
	cvttsd2si ecx, xmm0
	movd	xmm0, ecx

; 313  : 			*buf++ = '0' + val;

	lea	eax, DWORD PTR [ecx+48]

; 314  : 			fval -= val * tmp;

	cvtdq2pd xmm0, xmm0
	mov	DWORD PTR [esi], eax
	mulsd	xmm0, xmm1
	subsd	xmm2, xmm0
$LN20@AddFloat:

; 315  : 		}
; 316  : 		maxlen--;

	dec	DWORD PTR [edi]
	add	esi, 4
	test	edx, edx
	jne	SHORT $LL6@AddFloat
$LN45@AddFloat:
	cmp	DWORD PTR tv478[esp+24], 0

; 317  : 	}
; 318  : 
; 319  : 	// left justify if required
; 320  : 	if (flags & LADJUST)

	je	SHORT $LN43@AddFloat

; 321  : 	{
; 322  : 		while ((fieldlength < width) && maxlen)

	mov	eax, DWORD PTR _width$1$[esp+28]
	mov	ecx, DWORD PTR _fieldlength$1$[esp+28]
	cmp	ecx, eax
	jge	SHORT $LN43@AddFloat
	npad	4
$LL8@AddFloat:
	cmp	DWORD PTR [edi], 0
	je	SHORT $LN43@AddFloat

; 323  : 		{
; 324  : 			// right-padding only with spaces, ZEROPAD is ignored
; 325  : 			*buf++ = ' ';

	mov	DWORD PTR [esi], 32			; 00000020H

; 326  : 			width--;

	dec	eax

; 327  : 			maxlen--;

	dec	DWORD PTR [edi]
	add	esi, 4
	cmp	ecx, eax
	jl	SHORT $LL8@AddFloat
$LN43@AddFloat:

; 328  : 		}
; 329  : 	}
; 330  : 
; 331  : 	// update parent's buffer pointer
; 332  : 	*buf_p = buf;

	mov	eax, DWORD PTR _buf_p$[esp+24]
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi

; 333  : }

	add	esp, 20					; 00000014H
	ret	0
??$AddFloat@H@@YAXPAPAHAAINHHH@Z ENDP			; AddFloat<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
;	COMDAT ??$AddUInt@H@@YAXPAPAHAAIIHH@Z
_TEXT	SEGMENT
tv299 = -136						; size = 4
_text$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_buf_p$ = 8						; size = 4
_maxlen$ = 12						; size = 4
_val$ = 16						; size = 4
_width$ = 20						; size = 4
_flags$ = 24						; size = 4
??$AddUInt@H@@YAXPAPAHAAIIHH@Z PROC			; AddUInt<int>, COMDAT

; 389  : {

	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+136], eax

; 390  : 	U		text[32];
; 391  : 	int		digits;
; 392  : 	U		*buf;
; 393  : 
; 394  : 	digits = 0;

	mov	ecx, DWORD PTR _val$[esp+132]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _buf_p$[esp+140]
	push	esi
	mov	esi, DWORD PTR _maxlen$[esp+144]
	push	edi
	xor	edi, edi
	npad	1
$LL4@AddUInt:

; 395  : 	do {
; 396  : 		text[digits++] = '0' + val % 10;

	mov	eax, -858993459				; cccccccdH
	mul	ecx
	shr	edx, 3
	lea	eax, DWORD PTR [edx+edx*4]
	add	eax, eax
	sub	ecx, eax
	add	ecx, 48					; 00000030H
	mov	DWORD PTR _text$[esp+edi*4+152], ecx

; 397  : 		val /= 10;

	mov	ecx, edx
	inc	edi

; 398  : 	} while (val);

	test	ecx, ecx
	jne	SHORT $LL4@AddUInt

; 399  : 
; 400  : 	buf = *buf_p;
; 401  : 
; 402  : 	if( !(flags & LADJUST) )

	mov	ebx, DWORD PTR _flags$[esp+148]
	mov	ecx, ebx
	mov	eax, DWORD PTR [ebp]
	and	ecx, 4

; 403  : 	{
; 404  : 		while (digits < width && maxlen)

	mov	edx, DWORD PTR _width$[esp+148]
	mov	DWORD PTR tv299[esp+152], ecx
	jne	SHORT $LN16@AddUInt
	cmp	edi, edx
	jge	SHORT $LN16@AddUInt
	npad	1
$LL5@AddUInt:
	cmp	DWORD PTR [esi], 0
	je	SHORT $LN16@AddUInt

; 405  : 		{
; 406  : 			*buf++ = (flags & ZEROPAD) ? '0' : ' ';

	mov	ecx, ebx

; 407  : 			width--;

	dec	edx
	shr	ecx, 3
	and	ecx, 16					; 00000010H
	or	ecx, 32					; 00000020H
	mov	DWORD PTR [eax], ecx
	add	eax, 4

; 408  : 			maxlen--;

	dec	DWORD PTR [esi]
	cmp	edi, edx
	jl	SHORT $LL5@AddUInt
$LN16@AddUInt:

; 409  : 		}
; 410  : 	}
; 411  : 
; 412  : 	while (digits-- && maxlen)

	test	edi, edi
	je	SHORT $LN35@AddUInt
$LL7@AddUInt:
	dec	edi
	cmp	DWORD PTR [esi], 0
	je	SHORT $LN35@AddUInt

; 413  : 	{
; 414  : 		*buf++ = text[digits];

	mov	ecx, DWORD PTR _text$[esp+edi*4+152]

; 415  : 		width--;

	dec	edx
	mov	DWORD PTR [eax], ecx
	add	eax, 4

; 416  : 		maxlen--;

	dec	DWORD PTR [esi]
	test	edi, edi
	jne	SHORT $LL7@AddUInt
$LN35@AddUInt:
	cmp	DWORD PTR tv299[esp+152], 0

; 417  : 	}
; 418  : 
; 419  : 	if (flags & LADJUST)

	je	SHORT $LN33@AddUInt

; 420  : 	{
; 421  : 		while (width-- && maxlen)

	test	edx, edx
	je	SHORT $LN33@AddUInt
$LL9@AddUInt:
	dec	edx
	cmp	DWORD PTR [esi], 0
	je	SHORT $LN33@AddUInt

; 422  : 		{
; 423  : 			*buf++ = (flags & ZEROPAD) ? '0' : ' ';

	mov	ecx, ebx
	shr	ecx, 3
	and	ecx, 16					; 00000010H
	or	ecx, 32					; 00000020H
	mov	DWORD PTR [eax], ecx
	add	eax, 4

; 424  : 			maxlen--;

	dec	DWORD PTR [esi]
	test	edx, edx
	jne	SHORT $LL9@AddUInt
$LN33@AddUInt:

; 425  : 		}
; 426  : 	}
; 427  : 
; 428  : 	*buf_p = buf;
; 429  : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+152]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebp], eax
	pop	ebp
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 136				; 00000088H
	ret	0
??$AddUInt@H@@YAXPAPAHAAIIHH@Z ENDP			; AddUInt<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
;	COMDAT ??$AddInt@H@@YAXPAPAHAAIHHH@Z
_TEXT	SEGMENT
tv304 = -136						; size = 4
_text$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_buf_p$ = 8						; size = 4
_maxlen$ = 12						; size = 4
_val$ = 16						; size = 4
_width$ = 20						; size = 4
_flags$ = 24						; size = 4
??$AddInt@H@@YAXPAPAHAAIHHH@Z PROC			; AddInt<int>, COMDAT

; 433  : {

	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+136], eax
	push	ebx

; 434  : 	U		text[32];
; 435  : 	int		digits;
; 436  : 	int		signedVal;
; 437  : 	U		*buf;
; 438  : 	unsigned int unsignedVal;
; 439  : 
; 440  : 	digits = 0;
; 441  : 	signedVal = val;
; 442  : 	if (val < 0)

	mov	ebx, DWORD PTR _val$[esp+136]
	push	ebp
	mov	ebp, DWORD PTR _buf_p$[esp+140]
	push	esi
	mov	esi, DWORD PTR _maxlen$[esp+144]
	push	edi
	xor	edi, edi
	test	ebx, ebx
	jns	SHORT $LN11@AddInt

; 443  : 	{
; 444  : 		/* we want the unsigned version */
; 445  : 		unsignedVal = abs(val);

	mov	eax, ebx
	cdq
	mov	ecx, eax
	xor	ecx, edx
	sub	ecx, edx

; 446  : 	} else {

	jmp	SHORT $LL4@AddInt
$LN11@AddInt:

; 447  : 		unsignedVal = val;

	mov	ecx, ebx
$LL4@AddInt:

; 448  : 	}
; 449  : 	do {
; 450  : 		text[digits++] = '0' + unsignedVal % 10;

	mov	eax, -858993459				; cccccccdH
	mul	ecx
	shr	edx, 3
	lea	eax, DWORD PTR [edx+edx*4]
	add	eax, eax
	sub	ecx, eax
	add	ecx, 48					; 00000030H
	mov	DWORD PTR _text$[esp+edi*4+152], ecx

; 451  : 		unsignedVal /= 10;

	mov	ecx, edx
	inc	edi

; 452  : 	} while (unsignedVal);

	test	ecx, ecx
	jne	SHORT $LL4@AddInt

; 453  : 
; 454  : 	if (signedVal < 0)

	test	ebx, ebx
	jns	SHORT $LN13@AddInt

; 455  : 		text[digits++] = '-';

	mov	DWORD PTR _text$[esp+edi*4+152], 45	; 0000002dH
	inc	edi
$LN13@AddInt:

; 456  : 
; 457  : 	buf = *buf_p;
; 458  : 
; 459  : 	if( !(flags & LADJUST) )

	mov	ebx, DWORD PTR _flags$[esp+148]
	mov	ecx, ebx
	mov	eax, DWORD PTR [ebp]
	and	ecx, 4

; 460  : 	{
; 461  : 		while (digits < width && maxlen)

	mov	edx, DWORD PTR _width$[esp+148]
	mov	DWORD PTR tv304[esp+152], ecx
	jne	SHORT $LN19@AddInt
	cmp	edi, edx
	jge	SHORT $LN19@AddInt
	npad	4
$LL5@AddInt:
	cmp	DWORD PTR [esi], 0
	je	SHORT $LN19@AddInt

; 462  : 		{
; 463  : 			*buf++ = (flags & ZEROPAD) ? '0' : ' ';

	mov	ecx, ebx

; 464  : 			width--;

	dec	edx
	shr	ecx, 3
	and	ecx, 16					; 00000010H
	or	ecx, 32					; 00000020H
	mov	DWORD PTR [eax], ecx
	add	eax, 4

; 465  : 			maxlen--;

	dec	DWORD PTR [esi]
	cmp	edi, edx
	jl	SHORT $LL5@AddInt
$LN19@AddInt:

; 466  : 		}
; 467  : 	}
; 468  : 
; 469  : 	while (digits-- && maxlen)

	test	edi, edi
	je	SHORT $LN70@AddInt
$LL7@AddInt:
	dec	edi
	cmp	DWORD PTR [esi], 0
	je	SHORT $LN70@AddInt

; 470  : 	{
; 471  : 		*buf++ = text[digits];

	mov	ecx, DWORD PTR _text$[esp+edi*4+152]

; 472  : 		width--;

	dec	edx
	mov	DWORD PTR [eax], ecx
	add	eax, 4

; 473  : 		maxlen--;

	dec	DWORD PTR [esi]
	test	edi, edi
	jne	SHORT $LL7@AddInt
$LN70@AddInt:
	cmp	DWORD PTR tv304[esp+152], 0

; 474  : 	}
; 475  : 
; 476  : 	if (flags & LADJUST)

	je	SHORT $LN68@AddInt

; 477  : 	{
; 478  : 		while (width-- && maxlen)

	test	edx, edx
	je	SHORT $LN68@AddInt
$LL9@AddInt:
	dec	edx
	cmp	DWORD PTR [esi], 0
	je	SHORT $LN68@AddInt

; 479  : 		{
; 480  : 			*buf++ = (flags & ZEROPAD) ? '0' : ' ';

	mov	ecx, ebx
	shr	ecx, 3
	and	ecx, 16					; 00000010H
	or	ecx, 32					; 00000020H
	mov	DWORD PTR [eax], ecx
	add	eax, 4

; 481  : 			maxlen--;

	dec	DWORD PTR [esi]
	test	edx, edx
	jne	SHORT $LL9@AddInt
$LN68@AddInt:

; 482  : 		}
; 483  : 	}
; 484  : 
; 485  : 	*buf_p = buf;
; 486  : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+152]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebp], eax
	pop	ebp
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 136				; 00000088H
	ret	0
??$AddInt@H@@YAXPAPAHAAIHHH@Z ENDP			; AddInt<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
;	COMDAT ??$AddBinary@H@@YAXPAPAHAAIIHH@Z
_TEXT	SEGMENT
tv308 = -40						; size = 4
_text$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_buf_p$ = 8						; size = 4
_maxlen$ = 12						; size = 4
_val$ = 16						; size = 4
_width$ = 20						; size = 4
_flags$ = 24						; size = 4
??$AddBinary@H@@YAXPAPAHAAIIHH@Z PROC			; AddBinary<int>, COMDAT

; 337  : {

	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+40], eax
	mov	edx, DWORD PTR _maxlen$[esp+36]

; 338  : 	char text[32];
; 339  : 	int digits;
; 340  : 	U *buf;
; 341  : 
; 342  : 	digits = 0;

	mov	ecx, DWORD PTR _val$[esp+36]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _buf_p$[esp+44]
	push	esi
	push	edi
	xor	edi, edi
$LL4@AddBinary:

; 343  : 	do
; 344  : 	{
; 345  : 		if (val & 1)

	mov	al, cl
	and	al, 1
	or	al, 48					; 00000030H
	mov	BYTE PTR _text$[esp+edi+56], al
	inc	edi

; 346  : 		{
; 347  : 			text[digits++] = '1';
; 348  : 		}
; 349  : 		else
; 350  : 		{
; 351  : 			text[digits++] = '0';
; 352  : 		}
; 353  : 		val >>= 1;

	shr	ecx, 1

; 354  : 	} while (val);

	jne	SHORT $LL4@AddBinary

; 355  : 
; 356  : 	buf = *buf_p;
; 357  : 
; 358  : 	if (!(flags & LADJUST))

	mov	ebx, DWORD PTR _flags$[esp+52]
	mov	eax, ebx
	mov	ecx, DWORD PTR [ebp]
	and	eax, 4

; 359  : 	{
; 360  : 		while (digits < width && maxlen)

	mov	esi, DWORD PTR _width$[esp+52]
	mov	DWORD PTR tv308[esp+56], eax
	jne	SHORT $LN18@AddBinary
	cmp	edi, esi
	jge	SHORT $LN18@AddBinary
	npad	7
$LL5@AddBinary:
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN18@AddBinary

; 361  : 		{
; 362  : 			*buf++ = (flags & ZEROPAD) ? '0' : ' ';

	mov	eax, ebx

; 363  : 			width--;

	dec	esi
	shr	eax, 3
	and	eax, 16					; 00000010H
	or	eax, 32					; 00000020H
	mov	DWORD PTR [ecx], eax
	add	ecx, 4

; 364  : 			maxlen--;

	dec	DWORD PTR [edx]
	cmp	edi, esi
	jl	SHORT $LL5@AddBinary
$LN18@AddBinary:

; 365  : 		}
; 366  : 	}
; 367  : 
; 368  : 	while (digits-- && maxlen)

	test	edi, edi
	je	SHORT $LN37@AddBinary
$LL7@AddBinary:
	dec	edi
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN37@AddBinary

; 369  : 	{
; 370  : 		*buf++ = text[digits];

	movsx	eax, BYTE PTR _text$[esp+edi+56]

; 371  : 		width--;

	dec	esi
	mov	DWORD PTR [ecx], eax
	add	ecx, 4

; 372  : 		maxlen--;

	dec	DWORD PTR [edx]
	test	edi, edi
	jne	SHORT $LL7@AddBinary
$LN37@AddBinary:
	cmp	DWORD PTR tv308[esp+56], 0

; 373  : 	}
; 374  : 
; 375  : 	if (flags & LADJUST)

	je	SHORT $LN35@AddBinary

; 376  : 	{
; 377  : 		while (width-- && maxlen)

	test	esi, esi
	je	SHORT $LN35@AddBinary
$LL9@AddBinary:
	dec	esi
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN35@AddBinary

; 378  : 		{
; 379  : 			*buf++ = (flags & ZEROPAD) ? '0' : ' ';

	mov	eax, ebx
	shr	eax, 3
	and	eax, 16					; 00000010H
	or	eax, 32					; 00000020H
	mov	DWORD PTR [ecx], eax
	add	ecx, 4

; 380  : 			maxlen--;

	dec	DWORD PTR [edx]
	test	esi, esi
	jne	SHORT $LL9@AddBinary
$LN35@AddBinary:
	pop	edi

; 381  : 		}
; 382  : 	}
; 383  : 
; 384  : 	*buf_p = buf;

	mov	DWORD PTR [ebp], ecx

; 385  : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+52]
	pop	esi
	pop	ebp
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	add	esp, 40					; 00000028H
	ret	0
??$AddBinary@H@@YAXPAPAHAAIIHH@Z ENDP			; AddBinary<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
;	COMDAT ??0ListNode@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAE@ABQAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@Z
_TEXT	SEGMENT
_o$ = 8							; size = 4
??0ListNode@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAE@ABQAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@Z PROC ; List<THash<ke::AString,lang_err>::THashNode *>::ListNode::ListNode, COMDAT
; _this$ = ecx

; 58   : 			ListNode(const T & o) : obj(o) { };

	mov	eax, DWORD PTR _o$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	ret	4
??0ListNode@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAE@ABQAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@Z ENDP ; List<THash<ke::AString,lang_err>::THashNode *>::ListNode::ListNode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
;	COMDAT ??_GTHashNode@?$THash@VAString@ke@@Ulang_err@@@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GTHashNode@?$THash@VAString@ke@@Ulang_err@@@@QAEPAXI@Z PROC ; THash<ke::AString,lang_err>::THashNode::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx

; 126  :       delete [] t_;

	push	DWORD PTR [esi]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN13@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN13@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GTHashNode@?$THash@VAString@ke@@Ulang_err@@@@QAEPAXI@Z ENDP ; THash<ke::AString,lang_err>::THashNode::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
;	COMDAT ??1THashNode@?$THash@VAString@ke@@Ulang_err@@@@QAE@XZ
_TEXT	SEGMENT
??1THashNode@?$THash@VAString@ke@@Ulang_err@@@@QAE@XZ PROC ; THash<ke::AString,lang_err>::THashNode::~THashNode, COMDAT
; _this$ = ecx

; 126  :       delete [] t_;

	push	DWORD PTR [ecx]
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
??1THashNode@?$THash@VAString@ke@@Ulang_err@@@@QAE@XZ ENDP ; THash<ke::AString,lang_err>::THashNode::~THashNode
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
;	COMDAT ??0THashNode@?$THash@VAString@ke@@Ulang_err@@@@QAE@ABVAString@ke@@ABUlang_err@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_length$1$ = 8						; size = 4
_k$ = 8							; size = 4
_v$ = 12						; size = 4
??0THashNode@?$THash@VAString@ke@@Ulang_err@@@@QAE@ABVAString@ke@@ABUlang_err@@@Z PROC ; THash<ke::AString,lang_err>::THashNode::THashNode, COMDAT
; _this$ = ecx

; 44   : 				{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0THashNode@?$THash@VAString@ke@@Ulang_err@@@@QAE@ABVAString@ke@@ABUlang_err@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	DWORD PTR _this$[ebp], ebx

; 43   : 				key(k), val(v)

	mov	DWORD PTR _this$[ebp], ebx
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 113  :    : t_(nullptr)

	mov	DWORD PTR [ebx], 0
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 70   :     if (other.length_)

	mov	edi, DWORD PTR _k$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR _length$1$[ebp], eax
	test	eax, eax
	je	SHORT $LN5@THashNode
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 141  :       return t_;

	mov	edi, DWORD PTR [edi]
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 137  :     chars_ = new char[length + 1];

	inc	eax
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 151  :       delete [] t_;

	push	DWORD PTR [ebx]
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 137  :     chars_ = new char[length + 1];

	mov	esi, eax
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 151  :       delete [] t_;

	call	??_V@YAXPAX@Z				; operator delete[]

; 152  :       t_ = t;

	mov	DWORD PTR [ebx], esi
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 138  :     length_ = length;

	mov	esi, DWORD PTR _length$1$[ebp]

; 139  :     memcpy(chars_, str, length);

	push	esi
	push	edi
	push	DWORD PTR [ebx]
	mov	DWORD PTR [ebx+4], esi
	call	_memcpy

; 140  :     chars_[length] = '\0';

	mov	eax, DWORD PTR [ebx]
	add	esp, 20					; 00000014H
	mov	BYTE PTR [esi+eax], 0

; 72   :     else

	jmp	SHORT $LN6@THashNode
$LN5@THashNode:

; 73   :       length_ = 0;

	mov	DWORD PTR [ebx+4], 0
$LN6@THashNode:
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h

; 43   : 				key(k), val(v)

	mov	eax, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ebx+8], eax

; 45   : 				};

	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0THashNode@?$THash@VAString@ke@@Ulang_err@@@@QAE@ABVAString@ke@@ABUlang_err@@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$AutoArray@D@ke@@QAE@XZ		; ke::AutoArray<char>::~AutoArray<char>
__ehhandler$??0THashNode@?$THash@VAString@ke@@Ulang_err@@@@QAE@ABVAString@ke@@ABUlang_err@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0THashNode@?$THash@VAString@ke@@Ulang_err@@@@QAE@ABVAString@ke@@ABUlang_err@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0THashNode@?$THash@VAString@ke@@Ulang_err@@@@QAE@ABVAString@ke@@ABUlang_err@@@Z ENDP ; THash<ke::AString,lang_err>::THashNode::THashNode
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
;	COMDAT ??9iterator@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QBE_NABV01@@Z
_TEXT	SEGMENT
_where$ = 8						; size = 4
??9iterator@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QBE_NABV01@@Z PROC ; List<THash<ke::AString,lang_err>::THashNode *>::iterator::operator!=, COMDAT
; _this$ = ecx

; 209  : 			{

	mov	eax, DWORD PTR _where$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 210  : 				return (m_This != where.m_This);
; 211  : 			}

	ret	4
??9iterator@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QBE_NABV01@@Z ENDP ; List<THash<ke::AString,lang_err>::THashNode *>::iterator::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
;	COMDAT ??Diterator@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAEAAPAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@XZ
_TEXT	SEGMENT
??Diterator@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAEAAPAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@XZ PROC ; List<THash<ke::AString,lang_err>::THashNode *>::iterator::operator*, COMDAT
; _this$ = ecx

; 196  : 				return m_This->obj;

	mov	eax, DWORD PTR [ecx]

; 197  : 			}

	ret	0
??Diterator@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAEAAPAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@XZ ENDP ; List<THash<ke::AString,lang_err>::THashNode *>::iterator::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
;	COMDAT ??Eiterator@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Eiterator@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAE?AV01@H@Z PROC ; List<THash<ke::AString,lang_err>::THashNode *>::iterator::operator++, COMDAT
; _this$ = ecx

; 156  : 				m_This = where.m_This;

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 184  : 				iterator old(*this);
; 185  : 				if (m_This)

	test	edx, edx
	je	SHORT $LN2@operator

; 186  : 					m_This = m_This->next;

	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], edx
$LN2@operator:

; 187  : 				return old;
; 188  : 			}

	ret	8
??Eiterator@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAE?AV01@H@Z ENDP ; List<THash<ke::AString,lang_err>::THashNode *>::iterator::operator++
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
;	COMDAT ??0iterator@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAE@ABV01@@Z
_TEXT	SEGMENT
_where$ = 8						; size = 4
??0iterator@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAE@ABV01@@Z PROC ; List<THash<ke::AString,lang_err>::THashNode *>::iterator::iterator, COMDAT
; _this$ = ecx

; 155  : 			{
; 156  : 				m_This = where.m_This;

	mov	eax, DWORD PTR _where$[esp-4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 157  : 			}

	mov	eax, ecx
	ret	4
??0iterator@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAE@ABV01@@Z ENDP ; List<THash<ke::AString,lang_err>::THashNode *>::iterator::iterator
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
;	COMDAT ??0iterator@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAE@PAVListNode@1@@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
??0iterator@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAE@PAVListNode@1@@Z PROC ; List<THash<ke::AString,lang_err>::THashNode *>::iterator::iterator, COMDAT
; _this$ = ecx

; 151  : 			iterator(ListNode *n) : m_This(n)

	mov	eax, DWORD PTR _n$[esp-4]
	mov	DWORD PTR [ecx], eax

; 153  : 			}

	mov	eax, ecx
	ret	4
??0iterator@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAE@PAVListNode@1@@Z ENDP ; List<THash<ke::AString,lang_err>::THashNode *>::iterator::iterator
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
;	COMDAT ??0iterator@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAE@XZ
_TEXT	SEGMENT
??0iterator@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAE@XZ PROC ; List<THash<ke::AString,lang_err>::THashNode *>::iterator::iterator, COMDAT
; _this$ = ecx

; 144  : 			{
; 145  : 				m_This = NULL;

	mov	DWORD PTR [ecx], 0

; 146  : 			}

	mov	eax, ecx
	ret	0
??0iterator@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAE@XZ ENDP ; List<THash<ke::AString,lang_err>::THashNode *>::iterator::iterator
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAEPAXI@Z PROC ; List<THash<ke::AString,lang_err>::THashNode *>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAE@XZ ; List<THash<ke::AString,lang_err>::THashNode *>::~List<THash<ke::AString,lang_err>::THashNode *>
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAEPAXI@Z ENDP ; List<THash<ke::AString,lang_err>::THashNode *>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
;	COMDAT ?end@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QBE?AViterator@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QBE?AViterator@1@XZ PROC ; List<THash<ke::AString,lang_err>::THashNode *>::end, COMDAT
; _this$ = ecx

; 151  : 			iterator(ListNode *n) : m_This(n)

	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 226  : 			return iterator(m_Head);
; 227  : 		}

	ret	4
?end@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QBE?AViterator@1@XZ ENDP ; List<THash<ke::AString,lang_err>::THashNode *>::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
;	COMDAT ?begin@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QBE?AViterator@1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QBE?AViterator@1@XZ PROC ; List<THash<ke::AString,lang_err>::THashNode *>::begin, COMDAT
; _this$ = ecx

; 151  : 			iterator(ListNode *n) : m_This(n)

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp-4]
	mov	DWORD PTR [eax], ecx

; 222  : 			return iterator(m_Head->next);
; 223  : 		}

	ret	4
?begin@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QBE?AViterator@1@XZ ENDP ; List<THash<ke::AString,lang_err>::THashNode *>::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
;	COMDAT ?clear@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAEXXZ
_TEXT	SEGMENT
?clear@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAEXXZ PROC ; List<THash<ke::AString,lang_err>::THashNode *>::clear, COMDAT
; _this$ = ecx

; 112  : 		{

	push	edi
	mov	edi, ecx

; 113  : 			ListNode *node = m_Head->next;

	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx+4]

; 114  : 			ListNode *temp;
; 115  : 			m_Head->next = m_Head;

	mov	DWORD PTR [edx+4], edx

; 116  : 			m_Head->prev = m_Head;

	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR [edx+8], edx

; 117  : 
; 118  : 			// Iterate through the nodes until we find g_Head (the sentinel) again
; 119  : 			while (node != m_Head)

	cmp	eax, DWORD PTR [edi]
	je	SHORT $LN9@clear
	push	esi
$LL2@clear:

; 120  : 			{
; 121  : 				temp = node->next;

	mov	esi, DWORD PTR [eax+4]

; 122  : 				delete node;

	push	12					; 0000000cH
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 123  : 				node = temp;

	mov	eax, esi
	cmp	esi, DWORD PTR [edi]
	jne	SHORT $LL2@clear
	pop	esi
$LN9@clear:

; 124  : 			}
; 125  : 			m_Size = 0;

	mov	DWORD PTR [edi+4], 0
	pop	edi

; 126  : 		}

	ret	0
?clear@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAEXXZ ENDP ; List<THash<ke::AString,lang_err>::THashNode *>::clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
;	COMDAT ?push_back@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAEXABQAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
_obj$ = 8						; size = 4
?push_back@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAEXABQAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@Z PROC ; List<THash<ke::AString,lang_err>::THashNode *>::push_back, COMDAT
; _this$ = ecx

; 96   : 		{

	push	ecx
	push	esi

; 97   : 			ListNode *node = new ListNode(obj);

	push	12					; 0000000cH
	mov	esi, ecx
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR $T1[esp+8], edx
	test	edx, edx
	je	SHORT $LN3@push_back

; 58   : 			ListNode(const T & o) : obj(o) { };

	mov	ecx, DWORD PTR _obj$[esp+4]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ecx

; 97   : 			ListNode *node = new ListNode(obj);

	jmp	SHORT $LN4@push_back
$LN3@push_back:
	xor	edx, edx
$LN4@push_back:

; 98   : 
; 99   : 			node->prev = m_Head->prev;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], eax

; 100  : 			node->next = m_Head;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edx+4], eax

; 101  : 			m_Head->prev->next = node;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [eax+4], edx

; 102  : 			m_Head->prev = node;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax+8], edx

; 103  : 
; 104  : 			m_Size++;

	inc	DWORD PTR [esi+4]
	pop	esi

; 105  : 		}

	pop	ecx
	ret	4
?push_back@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAEXABQAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@Z ENDP ; List<THash<ke::AString,lang_err>::THashNode *>::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
;	COMDAT ??1?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAE@XZ
_TEXT	SEGMENT
??1?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAE@XZ PROC ; List<THash<ke::AString,lang_err>::THashNode *>::~List<THash<ke::AString,lang_err>::THashNode *>, COMDAT
; _this$ = ecx

; 85   : 		{

	push	edi
	mov	edi, ecx

; 113  : 			ListNode *node = m_Head->next;

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+4]

; 114  : 			ListNode *temp;
; 115  : 			m_Head->next = m_Head;

	mov	DWORD PTR [eax+4], eax

; 116  : 			m_Head->prev = m_Head;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+8], eax

; 117  : 
; 118  : 			// Iterate through the nodes until we find g_Head (the sentinel) again
; 119  : 			while (node != m_Head)

	cmp	edx, DWORD PTR [edi]
	je	SHORT $LN6@List
	push	esi
$LL5@List:

; 120  : 			{
; 121  : 				temp = node->next;

	mov	esi, DWORD PTR [edx+4]

; 122  : 				delete node;

	push	12					; 0000000cH
	push	edx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 123  : 				node = temp;

	mov	edx, esi
	cmp	esi, DWORD PTR [edi]
	jne	SHORT $LL5@List
	pop	esi
$LN6@List:

; 86   : 			clear();
; 87   : 
; 88   : 			// Don't forget to free the sentinel
; 89   : 			if (m_Head)

	mov	eax, DWORD PTR [edi]

; 125  : 			m_Size = 0;

	mov	DWORD PTR [edi+4], 0

; 86   : 			clear();
; 87   : 
; 88   : 			// Don't forget to free the sentinel
; 89   : 			if (m_Head)

	test	eax, eax
	je	SHORT $LN2@List

; 90   : 			{
; 91   : 				free(m_Head);

	push	eax
	call	_free
	add	esp, 4

; 92   : 				m_Head = NULL;

	mov	DWORD PTR [edi], 0
$LN2@List:
	pop	edi

; 93   : 			}
; 94   : 		}

	ret	0
??1?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAE@XZ ENDP ; List<THash<ke::AString,lang_err>::THashNode *>::~List<THash<ke::AString,lang_err>::THashNode *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
;	COMDAT ??0?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAE@XZ
_TEXT	SEGMENT
??0?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAE@XZ PROC ; List<THash<ke::AString,lang_err>::THashNode *>::List<THash<ke::AString,lang_err>::THashNode *>, COMDAT
; _this$ = ecx

; 76   : 		{

	push	esi

; 69   : 			ListNode *n = (ListNode *)malloc(sizeof(ListNode));

	push	12					; 0000000cH

; 76   : 		{

	mov	esi, ecx

; 69   : 			ListNode *n = (ListNode *)malloc(sizeof(ListNode));

	call	_malloc
	add	esp, 4

; 70   : 			n->next = n;

	mov	DWORD PTR [eax+4], eax

; 71   : 			n->prev = n;

	mov	DWORD PTR [eax+8], eax

; 72   : 			return n;
; 73   : 		}
; 74   : 	public:
; 75   : 		List() : m_Head(_Initialize()), m_Size(0)

	mov	DWORD PTR [esi], eax

; 77   : 		}

	mov	eax, esi
	mov	DWORD PTR [esi+4], 0
	pop	esi
	ret	0
??0?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@QAE@XZ ENDP ; List<THash<ke::AString,lang_err>::THashNode *>::List<THash<ke::AString,lang_err>::THashNode *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
;	COMDAT ?_Initialize@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@AAEPAVListNode@1@XZ
_TEXT	SEGMENT
?_Initialize@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@AAEPAVListNode@1@XZ PROC ; List<THash<ke::AString,lang_err>::THashNode *>::_Initialize, COMDAT
; _this$ = ecx

; 69   : 			ListNode *n = (ListNode *)malloc(sizeof(ListNode));

	push	12					; 0000000cH
	call	_malloc
	add	esp, 4

; 70   : 			n->next = n;

	mov	DWORD PTR [eax+4], eax

; 71   : 			n->prev = n;

	mov	DWORD PTR [eax+8], eax

; 72   : 			return n;
; 73   : 		}

	ret	0
?_Initialize@?$List@PAUTHashNode@?$THash@VAString@ke@@Ulang_err@@@@@@AAEPAVListNode@1@XZ ENDP ; List<THash<ke::AString,lang_err>::THashNode *>::_Initialize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
;	COMDAT ?__WHOA_DONT_CALL_ME_PLZ_K_lol_o_O@@YAXXZ
_TEXT	SEGMENT
?__WHOA_DONT_CALL_ME_PLZ_K_lol_o_O@@YAXXZ PROC		; __WHOA_DONT_CALL_ME_PLZ_K_lol_o_O, COMDAT

; 823  : 	//acsprintf
; 824  : 	atcprintf((cell *)NULL, 0, (const char *)NULL, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	call	??$atcprintf@HD@@YAIPAHIPBDPAUtagAMX@@00@Z ; atcprintf<int,char>

; 825  : 	//accprintf
; 826  : 	atcprintf((cell *)NULL, 0, (cell *)NULL, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	call	??$atcprintf@HH@@YAIPAHIPBHPAUtagAMX@@00@Z ; atcprintf<int,int>

; 827  : 	//ascprintf
; 828  : 	atcprintf((char *)NULL, 0, (cell *)NULL, NULL, NULL, NULL);

	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	call	??$atcprintf@DH@@YAIPADIPBHPAUtagAMX@@PAH3@Z ; atcprintf<char,int>
	add	esp, 72					; 00000048H

; 829  : }

	ret	0
?__WHOA_DONT_CALL_ME_PLZ_K_lol_o_O@@YAXXZ ENDP		; __WHOA_DONT_CALL_ME_PLZ_K_lol_o_O
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
; File e:\nightfire_sdk\amx\amxmodx\clang.h
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
; File e:\nightfire_sdk\amx\amxmodx\clang.h
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
;	COMDAT ??$AltFindOrInsert@VAString@ke@@@?$THash@VAString@ke@@Ulang_err@@@@QAEAAUlang_err@@ABVAString@ke@@@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -24						; size = 4
_this$1$ = -20						; size = 4
_place$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_length$1$ = 8						; size = 4
$T5 = 8							; size = 4
$T6 = 8							; size = 4
$T7 = 8							; size = 4
$T8 = 8							; size = 4
_ukey$ = 8						; size = 4
??$AltFindOrInsert@VAString@ke@@@?$THash@VAString@ke@@Ulang_err@@@@QAEAAUlang_err@@ABVAString@ke@@@Z PROC ; THash<ke::AString,lang_err>::AltFindOrInsert<ke::AString>, COMDAT
; _this$ = ecx

; 125  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$AltFindOrInsert@VAString@ke@@@?$THash@VAString@ke@@Ulang_err@@@@QAEAAUlang_err@@ABVAString@ke@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$1$[ebp], edi

; 126  : 			size_t place = HashAlt(ukey) % m_numBuckets;

	mov	ebx, DWORD PTR _ukey$[ebp]
	push	ebx
	call	??$HashAlt@VAString@ke@@@@YAHABVAString@ke@@@Z ; HashAlt<ke::AString>
	xor	edx, edx
	add	esp, 4
	div	DWORD PTR [edi+4]

; 127  : 			THashNode *pNode = NULL;
; 128  : 			if (!m_Buckets[place])

	mov	eax, DWORD PTR [edi]
	mov	esi, edx
	mov	DWORD PTR _place$1$[ebp], esi
	mov	eax, DWORD PTR [eax+esi*4]
	test	eax, eax
	jne	$LN5@AltFindOrI

; 130  : 				m_Buckets[place] = new List<THashNode *>;

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T8[ebp], eax
	test	eax, eax
	je	SHORT $LN10@AltFindOrI
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h

; 69   : 			ListNode *n = (ListNode *)malloc(sizeof(ListNode));

	push	12					; 0000000cH
	call	_malloc

; 75   : 		List() : m_Head(_Initialize()), m_Size(0)

	mov	ecx, DWORD PTR $T8[ebp]

; 69   : 			ListNode *n = (ListNode *)malloc(sizeof(ListNode));

	add	esp, 4

; 70   : 			n->next = n;

	mov	DWORD PTR [eax+4], eax

; 71   : 			n->prev = n;

	mov	DWORD PTR [eax+8], eax

; 75   : 		List() : m_Head(_Initialize()), m_Size(0)

	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], 0
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h

; 130  : 				m_Buckets[place] = new List<THashNode *>;

	jmp	SHORT $LN11@AltFindOrI
$LN10@AltFindOrI:
	xor	ecx, ecx
$LN11@AltFindOrI:
	mov	eax, DWORD PTR [edi]

; 131  : 				pNode = new THashNode(ukey, V());

	push	12					; 0000000cH
	mov	DWORD PTR [eax+esi*4], ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN12@AltFindOrI
	lea	ecx, DWORD PTR $T7[ebp]
; File e:\nightfire_sdk\amx\amxmodx\clang.h

; 31   : 	lang_err() : last(0.0f)

	mov	DWORD PTR $T7[ebp], 0
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h

; 131  : 				pNode = new THashNode(ukey, V());

	push	ecx
	push	ebx
	mov	ecx, eax
	call	??0THashNode@?$THash@VAString@ke@@Ulang_err@@@@QAE@ABVAString@ke@@ABUlang_err@@@Z ; THash<ke::AString,lang_err>::THashNode::THashNode
	mov	ebx, eax
	jmp	SHORT $LN13@AltFindOrI
$LN12@AltFindOrI:
	xor	ebx, ebx
$LN13@AltFindOrI:

; 132  : 				m_Buckets[place]->push_back(pNode);

	mov	eax, DWORD PTR [edi]
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h

; 97   : 			ListNode *node = new ListNode(obj);

	push	12					; 0000000cH
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h

; 131  : 				pNode = new THashNode(ukey, V());

	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 132  : 				m_Buckets[place]->push_back(pNode);

	mov	esi, DWORD PTR [eax+esi*4]
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h

; 97   : 			ListNode *node = new ListNode(obj);

	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR $T6[ebp], ecx
	test	ecx, ecx
	je	SHORT $LN27@AltFindOrI

; 58   : 			ListNode(const T & o) : obj(o) { };

	mov	DWORD PTR [ecx], ebx

; 97   : 			ListNode *node = new ListNode(obj);

	jmp	SHORT $LN28@AltFindOrI
$LN27@AltFindOrI:
	xor	ecx, ecx
$LN28@AltFindOrI:

; 99   : 			node->prev = m_Head->prev;

	mov	eax, DWORD PTR [esi]
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h

; 133  : 				m_percentUsed += (1.0f / (float)m_numBuckets);

	movss	xmm1, DWORD PTR __real@3f800000
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h

; 99   : 			node->prev = m_Head->prev;

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 100  : 			node->next = m_Head;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx+4], eax

; 101  : 			m_Head->prev->next = node;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [eax+4], ecx

; 102  : 			m_Head->prev = node;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax+8], ecx

; 103  : 
; 104  : 			m_Size++;

	inc	DWORD PTR [esi+4]
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h

; 133  : 				m_percentUsed += (1.0f / (float)m_numBuckets);

	mov	eax, DWORD PTR [edi+4]
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0
	addss	xmm1, DWORD PTR [edi+8]
	movss	DWORD PTR [edi+8], xmm1

; 134  : 				m_items++;
; 135  : 			} else {

	jmp	$LN90@AltFindOrI
$LN5@AltFindOrI:

; 137  : 				for (iter=m_Buckets[place]->begin(); iter!=m_Buckets[place]->end(); iter++)

	mov	esi, DWORD PTR [eax]
	mov	esi, DWORD PTR [esi+4]
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h

; 210  : 				return (m_This != where.m_This);

	cmp	esi, DWORD PTR [eax]
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h

; 137  : 				for (iter=m_Buckets[place]->begin(); iter!=m_Buckets[place]->end(); iter++)

	je	SHORT $LN3@AltFindOrI
$LL39@AltFindOrI:

; 138  : 				{
; 139  : 					if (CompareAlt(ukey, (*iter)->key) == 0)

	push	DWORD PTR [esi]
	push	ebx
	call	??$CompareAlt@VAString@ke@@V12@@@YAHABVAString@ke@@0@Z ; CompareAlt<ke::AString,ke::AString>
	add	esp, 8
	test	eax, eax
	je	$LN85@AltFindOrI

; 137  : 				for (iter=m_Buckets[place]->begin(); iter!=m_Buckets[place]->end(); iter++)

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR _place$1$[ebp]
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h

; 186  : 					m_This = m_This->next;

	mov	esi, DWORD PTR [esi+4]
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h

; 137  : 				for (iter=m_Buckets[place]->begin(); iter!=m_Buckets[place]->end(); iter++)

	mov	eax, DWORD PTR [eax+ecx*4]
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h

; 210  : 				return (m_This != where.m_This);

	cmp	esi, DWORD PTR [eax]
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h

; 137  : 				for (iter=m_Buckets[place]->begin(); iter!=m_Buckets[place]->end(); iter++)

	jne	SHORT $LL39@AltFindOrI
$LN3@AltFindOrI:

; 142  : 				pNode = new THashNode(ukey, V());

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR $T2[ebp], ebx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	ebx, ebx
	je	$LN14@AltFindOrI
; File e:\nightfire_sdk\amx\amxmodx\clang.h

; 31   : 	lang_err() : last(0.0f)

	mov	DWORD PTR $T3[ebp], 0
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h

; 43   : 				key(k), val(v)

	mov	DWORD PTR _this$[ebp], ebx
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 113  :    : t_(nullptr)

	mov	DWORD PTR [ebx], 0
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 70   :     if (other.length_)

	mov	eax, DWORD PTR _ukey$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _length$1$[ebp], ecx
	test	ecx, ecx
	je	SHORT $LN59@AltFindOrI
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 141  :       return t_;

	mov	edi, DWORD PTR [eax]
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 137  :     chars_ = new char[length + 1];

	lea	eax, DWORD PTR [ecx+1]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 151  :       delete [] t_;

	push	DWORD PTR [ebx]
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 137  :     chars_ = new char[length + 1];

	mov	esi, eax
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 151  :       delete [] t_;

	call	??_V@YAXPAX@Z				; operator delete[]

; 152  :       t_ = t;

	mov	DWORD PTR [ebx], esi
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 138  :     length_ = length;

	mov	esi, DWORD PTR _length$1$[ebp]

; 139  :     memcpy(chars_, str, length);

	push	esi
	push	edi
	push	DWORD PTR [ebx]
	mov	DWORD PTR [ebx+4], esi
	call	_memcpy
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 141  :       return t_;

	mov	eax, DWORD PTR [ebx]
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 139  :     memcpy(chars_, str, length);

	add	esp, 20					; 00000014H

; 72   :     else

	mov	edi, DWORD PTR _this$1$[ebp]

; 140  :     chars_[length] = '\0';

	mov	BYTE PTR [eax+esi], 0
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h

; 43   : 				key(k), val(v)

	mov	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR [ebx+8], eax

; 142  : 				pNode = new THashNode(ukey, V());

	jmp	SHORT $LN15@AltFindOrI
$LN85@AltFindOrI:

; 140  : 						return (*iter)->val;

	mov	eax, DWORD PTR [esi]
	add	eax, 8

; 149  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN59@AltFindOrI:

; 43   : 				key(k), val(v)

	mov	eax, DWORD PTR $T3[ebp]
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 73   :       length_ = 0;

	mov	DWORD PTR [ebx+4], 0
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h

; 43   : 				key(k), val(v)

	mov	DWORD PTR [ebx+8], eax

; 142  : 				pNode = new THashNode(ukey, V());

	jmp	SHORT $LN15@AltFindOrI
$LN14@AltFindOrI:
	xor	ebx, ebx
$LN15@AltFindOrI:

; 143  : 				m_Buckets[place]->push_back(pNode);

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR _place$1$[ebp]
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h

; 97   : 			ListNode *node = new ListNode(obj);

	push	12					; 0000000cH
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h

; 142  : 				pNode = new THashNode(ukey, V());

	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 143  : 				m_Buckets[place]->push_back(pNode);

	mov	esi, DWORD PTR [eax+ecx*4]
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h

; 97   : 			ListNode *node = new ListNode(obj);

	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR $T5[ebp], ecx
	test	ecx, ecx
	je	SHORT $LN77@AltFindOrI

; 58   : 			ListNode(const T & o) : obj(o) { };

	mov	DWORD PTR [ecx], ebx

; 97   : 			ListNode *node = new ListNode(obj);

	jmp	SHORT $LN78@AltFindOrI
$LN77@AltFindOrI:
	xor	ecx, ecx
$LN78@AltFindOrI:

; 99   : 			node->prev = m_Head->prev;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 100  : 			node->next = m_Head;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx+4], eax

; 101  : 			m_Head->prev->next = node;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [eax+4], ecx

; 102  : 			m_Head->prev = node;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax+8], ecx

; 103  : 
; 104  : 			m_Size++;

	inc	DWORD PTR [esi+4]
$LN90@AltFindOrI:
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h

; 146  : 			if (PercentUsed() > 0.75f)

	movss	xmm0, DWORD PTR [edi+8]
	inc	DWORD PTR [edi+12]
	comiss	xmm0, DWORD PTR __real@3f400000
	jbe	SHORT $LN8@AltFindOrI

; 147  : 				_Refactor();

	mov	ecx, edi
	call	?_Refactor@?$THash@VAString@ke@@Ulang_err@@@@AAEXXZ ; THash<ke::AString,lang_err>::_Refactor
$LN8@AltFindOrI:

; 148  : 			return pNode->val;

	lea	eax, DWORD PTR [ebx+8]

; 149  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$AltFindOrInsert@VAString@ke@@@?$THash@VAString@ke@@Ulang_err@@@@QAEAAUlang_err@@ABVAString@ke@@@Z$1:
	push	12					; 0000000cH
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??$AltFindOrInsert@VAString@ke@@@?$THash@VAString@ke@@Ulang_err@@@@QAEAAUlang_err@@ABVAString@ke@@@Z$2:
	push	12					; 0000000cH
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$??$AltFindOrInsert@VAString@ke@@@?$THash@VAString@ke@@Ulang_err@@@@QAEAAUlang_err@@ABVAString@ke@@@Z$5:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$AutoArray@D@ke@@QAE@XZ		; ke::AutoArray<char>::~AutoArray<char>
__ehhandler$??$AltFindOrInsert@VAString@ke@@@?$THash@VAString@ke@@Ulang_err@@@@QAEAAUlang_err@@ABVAString@ke@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$AltFindOrInsert@VAString@ke@@@?$THash@VAString@ke@@Ulang_err@@@@QAEAAUlang_err@@ABVAString@ke@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$AltFindOrInsert@VAString@ke@@@?$THash@VAString@ke@@Ulang_err@@@@QAEAAUlang_err@@ABVAString@ke@@@Z ENDP ; THash<ke::AString,lang_err>::AltFindOrInsert<ke::AString>
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\public\amtl\am-moveable.h
;	COMDAT ??$Move@AAVAString@ke@@@ke@@YA$$QAVAString@0@AAV10@@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
??$Move@AAVAString@ke@@@ke@@YA$$QAVAString@0@AAV10@@Z PROC ; ke::Move<ke::AString &>, COMDAT

; 43   :   return static_cast<typename remove_reference<T>::type &&>(t);

	mov	eax, DWORD PTR _t$[esp-4]

; 44   : }

	ret	0
??$Move@AAVAString@ke@@@ke@@YA$$QAVAString@0@AAV10@@Z ENDP ; ke::Move<ke::AString &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
;	COMDAT ??__FBadLang_Table@@YAXXZ
text$yd	SEGMENT
??__FBadLang_Table@@YAXXZ PROC				; `dynamic atexit destructor for 'BadLang_Table'', COMDAT

; 78   : 			_Clear();

	mov	ecx, OFFSET ?BadLang_Table@@3V?$THash@VAString@ke@@Ulang_err@@@@A ; BadLang_Table
	jmp	?_Clear@?$THash@VAString@ke@@Ulang_err@@@@AAEXXZ ; THash<ke::AString,lang_err>::_Clear
??__FBadLang_Table@@YAXXZ ENDP				; `dynamic atexit destructor for 'BadLang_Table''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
;	COMDAT ??__EBadLang_Table@@YAXXZ
text$di	SEGMENT
??__EBadLang_Table@@YAXXZ PROC				; `dynamic initializer for 'BadLang_Table'', COMDAT
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h

; 59   : 			_Refactor();

	mov	ecx, OFFSET ?BadLang_Table@@3V?$THash@VAString@ke@@Ulang_err@@@@A ; BadLang_Table
	call	?_Refactor@?$THash@VAString@ke@@Ulang_err@@@@AAEXXZ ; THash<ke::AString,lang_err>::_Refactor
; File e:\nightfire_sdk\amx\amxmodx\format.cpp

; 45   : THash<ke::AString, lang_err> BadLang_Table;

	push	OFFSET ??__FBadLang_Table@@YAXXZ	; `dynamic atexit destructor for 'BadLang_Table''
	call	_atexit
	pop	ecx
	ret	0
??__EBadLang_Table@@YAXXZ ENDP				; `dynamic initializer for 'BadLang_Table''
text$di	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
;	COMDAT ?_Refactor@?$THash@VAString@ke@@Ulang_err@@@@AAEXXZ
_TEXT	SEGMENT
_temp$1$ = -20						; size = 4
_i$1$ = -16						; size = 4
_pHashNode$1$ = -12					; size = 4
_oldSize$1$ = -8					; size = 4
$T1 = -4						; size = 4
$T2 = -4						; size = 4
?_Refactor@?$THash@VAString@ke@@Ulang_err@@@@AAEXXZ PROC ; THash<ke::AString,lang_err>::_Refactor, COMDAT
; _this$ = ecx

; 179  : 		{

	sub	esp, 20					; 00000014H
	push	ebx
	mov	ebx, ecx

; 180  : 			m_percentUsed = 0.0f;
; 181  : 			if (!m_numBuckets)
; 182  : 			{
; 183  : 				m_numBuckets = _T_INIT_HASH_SIZE;
; 184  : 				m_Buckets = new NodePtr[m_numBuckets];

	xor	ecx, ecx
	push	esi
	mov	esi, DWORD PTR [ebx+4]
	lea	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [ebx+8], 0
	mov	DWORD PTR _oldSize$1$[esp+28], esi
	test	esi, esi
	jne	SHORT $LN14@Refactor
	mov	eax, 512				; 00000200H
	mov	DWORD PTR [ebx+4], 512			; 00000200H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 185  : 				for (size_t i=0; i<m_numBuckets; i++)

	xor	ecx, ecx
	mov	DWORD PTR [ebx], eax
	add	esp, 4
	cmp	DWORD PTR [ebx+4], ecx
	jbe	$LN15@Refactor
	npad	7
$LL4@Refactor:

; 186  : 					m_Buckets[i] = NULL;

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [eax+ecx*4], 0
	inc	ecx
	cmp	ecx, DWORD PTR [ebx+4]
	jb	SHORT $LL4@Refactor
	pop	esi
	pop	ebx

; 224  : 			}
; 225  : 		}

	add	esp, 20					; 00000014H
	ret	0
$LN14@Refactor:

; 187  : 			} else {
; 188  : 				size_t oldSize = m_numBuckets;
; 189  : 				m_numBuckets *= 2;

	lea	eax, DWORD PTR [esi+esi]
	mov	DWORD PTR [ebx+4], eax

; 190  : 				typename List<THashNode *>::iterator iter;
; 191  : 				size_t place;
; 192  : 				THashNode *pHashNode;
; 193  : 				NodePtr *temp = new NodePtr[m_numBuckets];

	mul	edx
	push	ebp
	push	edi
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 194  : 				for (size_t i=0; i<m_numBuckets; i++)

	xor	ecx, ecx
	add	esp, 4
	mov	edi, eax
	mov	DWORD PTR _temp$1$[esp+36], edi
	cmp	DWORD PTR [ebx+4], ecx
	jbe	SHORT $LN6@Refactor
	npad	4
$LL7@Refactor:

; 195  : 					temp[i] = NULL;

	mov	DWORD PTR [edi+ecx*4], 0
	inc	ecx
	cmp	ecx, DWORD PTR [ebx+4]
	jb	SHORT $LL7@Refactor
$LN6@Refactor:

; 196  : 				//look in old hash table
; 197  : 				for (size_t i=0; i<oldSize; i++)

	xor	ebp, ebp
	mov	DWORD PTR _i$1$[esp+36], ebp
	test	esi, esi
	je	$LN9@Refactor
	npad	5
$LL10@Refactor:

; 198  : 				{
; 199  : 					//does a bucket have anything?
; 200  : 					if (m_Buckets[i])

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+ebp*4]
	test	eax, eax
	je	$LN8@Refactor
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h

; 222  : 			return iterator(m_Head->next);

	mov	eax, DWORD PTR [eax]
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h

; 203  : 						for (iter = m_Buckets[i]->begin(); iter != m_Buckets[i]->end(); iter++)

	mov	esi, DWORD PTR [eax+4]
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h

; 210  : 				return (m_This != where.m_This);

	cmp	esi, eax
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h

; 203  : 						for (iter = m_Buckets[i]->begin(); iter != m_Buckets[i]->end(); iter++)

	je	$LN12@Refactor
	npad	6
$LL31@Refactor:

; 204  : 						{
; 205  : 							pHashNode = (*iter);

	mov	eax, DWORD PTR [esi]

; 206  : 							//rehash it with the new bucket filter
; 207  : 							place = HashFunction(pHashNode->key) % m_numBuckets;

	push	eax
	mov	DWORD PTR _pHashNode$1$[esp+40], eax
	call	??$HashFunction@VAString@ke@@@@YAHABVAString@ke@@@Z ; HashFunction<ke::AString>
	xor	edx, edx
	add	esp, 4
	div	DWORD PTR [ebx+4]
	mov	ebp, edx

; 208  : 							//add it to the new hash table
; 209  : 							if (!temp[place])

	cmp	DWORD PTR [edi+ebp*4], 0
	jne	SHORT $LN17@Refactor

; 211  : 								temp[place] = new List<THashNode *>;

	push	8
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR $T2[esp+36], edi
	test	edi, edi
	je	SHORT $LN19@Refactor
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h

; 69   : 			ListNode *n = (ListNode *)malloc(sizeof(ListNode));

	push	12					; 0000000cH
	call	_malloc
	add	esp, 4

; 70   : 			n->next = n;

	mov	DWORD PTR [eax+4], eax

; 71   : 			n->prev = n;

	mov	DWORD PTR [eax+8], eax

; 75   : 		List() : m_Head(_Initialize()), m_Size(0)

	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], 0
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h

; 211  : 								temp[place] = new List<THashNode *>;

	jmp	SHORT $LN20@Refactor
$LN19@Refactor:
	xor	edi, edi
$LN20@Refactor:
	mov	eax, DWORD PTR _temp$1$[esp+36]

; 212  : 								m_percentUsed += (1.0f / (float)m_numBuckets);

	movss	xmm1, DWORD PTR __real@3f800000
	mov	DWORD PTR [eax+ebp*4], edi
	mov	eax, DWORD PTR [ebx+4]
	mov	edi, DWORD PTR _temp$1$[esp+36]
	movd	xmm0, eax
	cvtdq2pd xmm0, xmm0
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	cvtpd2ps xmm0, xmm0
	divss	xmm1, xmm0
	addss	xmm1, DWORD PTR [ebx+8]
	movss	DWORD PTR [ebx+8], xmm1
$LN17@Refactor:

; 213  : 							}
; 214  : 							temp[place]->push_back(pHashNode);

	mov	edi, DWORD PTR [edi+ebp*4]
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h

; 97   : 			ListNode *node = new ListNode(obj);

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR $T1[esp+36], ecx
	test	ecx, ecx
	je	SHORT $LN49@Refactor

; 58   : 			ListNode(const T & o) : obj(o) { };

	mov	eax, DWORD PTR _pHashNode$1$[esp+36]
	mov	DWORD PTR [ecx], eax

; 97   : 			ListNode *node = new ListNode(obj);

	jmp	SHORT $LN50@Refactor
$LN49@Refactor:
	xor	ecx, ecx
$LN50@Refactor:

; 98   : 
; 99   : 			node->prev = m_Head->prev;

	mov	eax, DWORD PTR [edi]

; 226  : 			return iterator(m_Head);

	mov	ebp, DWORD PTR _i$1$[esp+36]

; 99   : 			node->prev = m_Head->prev;

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 100  : 			node->next = m_Head;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx+4], eax

; 101  : 			m_Head->prev->next = node;

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [eax+4], ecx

; 102  : 			m_Head->prev = node;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+8], ecx

; 103  : 
; 104  : 			m_Size++;

	inc	DWORD PTR [edi+4]

; 226  : 			return iterator(m_Head);

	mov	eax, DWORD PTR [ebx]

; 186  : 					m_This = m_This->next;

	mov	esi, DWORD PTR [esi+4]
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h

; 203  : 						for (iter = m_Buckets[i]->begin(); iter != m_Buckets[i]->end(); iter++)

	mov	edi, DWORD PTR _temp$1$[esp+36]
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h

; 226  : 			return iterator(m_Head);

	mov	eax, DWORD PTR [eax+ebp*4]

; 210  : 				return (m_This != where.m_This);

	cmp	esi, DWORD PTR [eax]
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h

; 203  : 						for (iter = m_Buckets[i]->begin(); iter != m_Buckets[i]->end(); iter++)

	jne	$LL31@Refactor
$LN12@Refactor:

; 215  : 						}
; 216  : 						//delete that bucket!
; 217  : 						delete m_Buckets[i];

	mov	eax, DWORD PTR [ebx]
	mov	edi, DWORD PTR [eax+ebp*4]
	test	edi, edi
	je	SHORT $LN55@Refactor
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h

; 113  : 			ListNode *node = m_Head->next;

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]

; 114  : 			ListNode *temp;
; 115  : 			m_Head->next = m_Head;

	mov	DWORD PTR [eax+4], eax

; 116  : 			m_Head->prev = m_Head;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+8], eax

; 117  : 
; 118  : 			// Iterate through the nodes until we find g_Head (the sentinel) again
; 119  : 			while (node != m_Head)

	cmp	ecx, DWORD PTR [edi]
	je	SHORT $LN64@Refactor
	npad	7
$LL63@Refactor:

; 120  : 			{
; 121  : 				temp = node->next;

	mov	esi, DWORD PTR [ecx+4]

; 122  : 				delete node;

	push	12					; 0000000cH
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 123  : 				node = temp;

	mov	ecx, esi
	cmp	esi, DWORD PTR [edi]
	jne	SHORT $LL63@Refactor
$LN64@Refactor:

; 89   : 			if (m_Head)

	mov	eax, DWORD PTR [edi]

; 125  : 			m_Size = 0;

	mov	DWORD PTR [edi+4], 0

; 89   : 			if (m_Head)

	test	eax, eax
	je	SHORT $LN59@Refactor

; 90   : 			{
; 91   : 				free(m_Head);

	push	eax
	call	_free
	add	esp, 4

; 92   : 				m_Head = NULL;

	mov	DWORD PTR [edi], 0
$LN59@Refactor:
	push	8
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN55@Refactor:
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h

; 218  : 						m_Buckets[i] = NULL;

	mov	eax, DWORD PTR [ebx]
	mov	edi, DWORD PTR _temp$1$[esp+36]
	mov	esi, DWORD PTR _oldSize$1$[esp+36]
	mov	DWORD PTR [eax+ebp*4], 0
$LN8@Refactor:

; 196  : 				//look in old hash table
; 197  : 				for (size_t i=0; i<oldSize; i++)

	inc	ebp
	mov	DWORD PTR _i$1$[esp+36], ebp
	cmp	ebp, esi
	jb	$LL10@Refactor
$LN9@Refactor:

; 219  : 					}
; 220  : 				}
; 221  : 				//reassign bucket table
; 222  : 				delete [] m_Buckets;

	push	DWORD PTR [ebx]
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 223  : 				m_Buckets = temp;

	mov	DWORD PTR [ebx], edi
	pop	edi
	pop	ebp
$LN15@Refactor:
	pop	esi
	pop	ebx

; 224  : 			}
; 225  : 		}

	add	esp, 20					; 00000014H
	ret	0
?_Refactor@?$THash@VAString@ke@@Ulang_err@@@@AAEXXZ ENDP ; THash<ke::AString,lang_err>::_Refactor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
;	COMDAT ?_Clear@?$THash@VAString@ke@@Ulang_err@@@@AAEXXZ
_TEXT	SEGMENT
_i$1$ = -4						; size = 4
?_Clear@?$THash@VAString@ke@@Ulang_err@@@@AAEXXZ PROC	; THash<ke::AString,lang_err>::_Clear, COMDAT
; _this$ = ecx

; 100  : 		{

	push	ecx
	push	ebx
	push	ebp
	mov	ebp, ecx

; 101  : 			typename List<THashNode *>::iterator iter, end;
; 102  : 			for (size_t i=0; i<m_numBuckets; i++)

	xor	ebx, ebx
	mov	DWORD PTR _i$1$[esp+12], ebx
	cmp	DWORD PTR [ebp+4], ebx
	jbe	$LN3@Clear
	push	esi
	push	edi
$LL4@Clear:

; 103  : 			{
; 104  : 				if (m_Buckets[i])

	mov	eax, DWORD PTR [ebp]
	mov	edi, DWORD PTR [eax+ebx*4]
	test	edi, edi
	je	$LN2@Clear

; 105  : 				{
; 106  : 					end = m_Buckets[i]->end();

	mov	edi, DWORD PTR [edi]

; 107  : 					iter = m_Buckets[i]->begin();

	mov	esi, DWORD PTR [edi+4]
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h

; 210  : 				return (m_This != where.m_This);

	cmp	esi, edi
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h

; 108  : 					while (iter != end)

	je	SHORT $LN6@Clear
	npad	3
$LL5@Clear:

; 109  : 					{
; 110  : 						delete (*iter);

	mov	ebx, DWORD PTR [esi]
	test	ebx, ebx
	je	SHORT $LN31@Clear
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 126  :       delete [] t_;

	push	DWORD PTR [ebx]
	call	??_V@YAXPAX@Z				; operator delete[]
	push	12					; 0000000cH
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 12					; 0000000cH
$LN31@Clear:
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h

; 186  : 					m_This = m_This->next;

	mov	esi, DWORD PTR [esi+4]

; 210  : 				return (m_This != where.m_This);

	cmp	esi, edi
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h

; 108  : 					while (iter != end)

	jne	SHORT $LL5@Clear
	mov	ebx, DWORD PTR _i$1$[esp+20]
$LN6@Clear:

; 111  : 						iter++;
; 112  : 					}
; 113  : 					delete m_Buckets[i];

	mov	eax, DWORD PTR [ebp]
	mov	edi, DWORD PTR [eax+ebx*4]
	test	edi, edi
	je	SHORT $LN49@Clear
; File e:\nightfire_sdk\amx\amxmodx\sh_list.h

; 113  : 			ListNode *node = m_Head->next;

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]

; 114  : 			ListNode *temp;
; 115  : 			m_Head->next = m_Head;

	mov	DWORD PTR [eax+4], eax

; 116  : 			m_Head->prev = m_Head;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+8], eax

; 117  : 
; 118  : 			// Iterate through the nodes until we find g_Head (the sentinel) again
; 119  : 			while (node != m_Head)

	cmp	ecx, DWORD PTR [edi]
	je	SHORT $LN58@Clear
	npad	2
$LL57@Clear:

; 120  : 			{
; 121  : 				temp = node->next;

	mov	esi, DWORD PTR [ecx+4]

; 122  : 				delete node;

	push	12					; 0000000cH
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 123  : 				node = temp;

	mov	ecx, esi
	cmp	esi, DWORD PTR [edi]
	jne	SHORT $LL57@Clear
$LN58@Clear:

; 89   : 			if (m_Head)

	mov	eax, DWORD PTR [edi]

; 125  : 			m_Size = 0;

	mov	DWORD PTR [edi+4], 0

; 89   : 			if (m_Head)

	test	eax, eax
	je	SHORT $LN53@Clear

; 90   : 			{
; 91   : 				free(m_Head);

	push	eax
	call	_free
	add	esp, 4

; 92   : 				m_Head = NULL;

	mov	DWORD PTR [edi], 0
$LN53@Clear:
	push	8
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN49@Clear:
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h

; 114  : 					m_Buckets[i] = NULL;

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [eax+ebx*4], 0
$LN2@Clear:

; 101  : 			typename List<THashNode *>::iterator iter, end;
; 102  : 			for (size_t i=0; i<m_numBuckets; i++)

	inc	ebx
	mov	DWORD PTR _i$1$[esp+20], ebx
	cmp	ebx, DWORD PTR [ebp+4]
	jb	$LL4@Clear
	pop	edi
	pop	esi
$LN3@Clear:

; 115  : 				}
; 116  : 			}
; 117  : 			if (m_Buckets)

	mov	eax, DWORD PTR [ebp]
	test	eax, eax
	je	SHORT $LN71@Clear

; 118  : 				delete [] m_Buckets;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN71@Clear:

; 119  : 			m_Buckets = NULL;
; 120  : 			m_numBuckets = 0;

	mov	DWORD PTR [ebp+4], 0
	mov	DWORD PTR [ebp], 0
	pop	ebp
	pop	ebx

; 121  : 		}

	pop	ecx
	ret	0
?_Clear@?$THash@VAString@ke@@Ulang_err@@@@AAEXXZ ENDP	; THash<ke::AString,lang_err>::_Clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
;	COMDAT ?PercentUsed@?$THash@VAString@ke@@Ulang_err@@@@QAEMXZ
_TEXT	SEGMENT
?PercentUsed@?$THash@VAString@ke@@Ulang_err@@@@QAEMXZ PROC ; THash<ke::AString,lang_err>::PercentUsed, COMDAT
; _this$ = ecx

; 91   : 			return m_percentUsed;

	fld	DWORD PTR [ecx+8]

; 92   : 		}

	ret	0
?PercentUsed@?$THash@VAString@ke@@Ulang_err@@@@QAEMXZ ENDP ; THash<ke::AString,lang_err>::PercentUsed
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
;	COMDAT ??1?$THash@VAString@ke@@Ulang_err@@@@QAE@XZ
_TEXT	SEGMENT
??1?$THash@VAString@ke@@Ulang_err@@@@QAE@XZ PROC	; THash<ke::AString,lang_err>::~THash<ke::AString,lang_err>, COMDAT
; _this$ = ecx

; 78   : 			_Clear();

	jmp	?_Clear@?$THash@VAString@ke@@Ulang_err@@@@AAEXXZ ; THash<ke::AString,lang_err>::_Clear
??1?$THash@VAString@ke@@Ulang_err@@@@QAE@XZ ENDP	; THash<ke::AString,lang_err>::~THash<ke::AString,lang_err>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\sh_tinyhash.h
;	COMDAT ??0?$THash@VAString@ke@@Ulang_err@@@@QAE@XZ
_TEXT	SEGMENT
??0?$THash@VAString@ke@@Ulang_err@@@@QAE@XZ PROC	; THash<ke::AString,lang_err>::THash<ke::AString,lang_err>, COMDAT
; _this$ = ecx

; 58   : 		{

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0

; 59   : 			_Refactor();

	call	?_Refactor@?$THash@VAString@ke@@Ulang_err@@@@AAEXXZ ; THash<ke::AString,lang_err>::_Refactor

; 60   : 		}

	mov	eax, esi
	pop	esi
	ret	0
??0?$THash@VAString@ke@@Ulang_err@@@@QAE@XZ ENDP	; THash<ke::AString,lang_err>::THash<ke::AString,lang_err>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
;	COMDAT ??$atcprintf@DD@@YAIPADIPBDPAUtagAMX@@PAH3@Z
_TEXT	SEGMENT
_arg$ = -320						; size = 4
_amx$GSCopy$1$ = -316					; size = 4
_arg$2$ = -312						; size = 4
_buf_p$ = -308						; size = 4
_llen$ = -304						; size = 4
_buf_p$1$ = -300					; size = 4
_llen$1$ = -296						; size = 4
_params$GSCopy$1$ = -292				; size = 4
_args$1$ = -288						; size = 4
_player$1$ = -284					; size = 4
_flags$1$ = -284					; size = 4
_addr$1$ = -280						; size = 4
_width$1$ = -280					; size = 4
_prec$1$ = -276						; size = 4
_len$1 = -272						; size = 4
_param$GSCopy$1$ = -268					; size = 4
_buffer$2 = -264					; size = 255
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_maxlen$ = 12						; size = 4
_format$ = 16						; size = 4
_amx$ = 20						; size = 4
_params$ = 24						; size = 4
_param$ = 28						; size = 4
??$atcprintf@DD@@YAIPADIPBDPAUtagAMX@@PAH3@Z PROC	; atcprintf<char,char>, COMDAT

; 550  : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 372				; 00000174H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+372], eax
	mov	eax, DWORD PTR _amx$[ebp]
	mov	ecx, DWORD PTR _param$[ebp]
	mov	DWORD PTR _amx$GSCopy$1$[esp+372], eax
	mov	eax, DWORD PTR _params$[ebp]
	push	ebx

; 565  : 	fmt = format;

	mov	ebx, DWORD PTR _format$[ebp]
	mov	DWORD PTR _params$GSCopy$1$[esp+376], eax
	mov	eax, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _maxlen$[ebp]
	shr	eax, 2
	push	edi
	mov	edi, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _param$GSCopy$1$[esp+384], ecx
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR _args$1$[esp+384], eax
$LN142@atcprintf:

; 551  : 	int		arg;
; 552  : 	int		args = params[0] / sizeof(cell);
; 553  : 	D		*buf_p;
; 554  : 	D		ch;
; 555  : 	int		flags;
; 556  : 	int		width;
; 557  : 	int		prec;
; 558  : 	int		n;
; 559  : 	//char	sign;
; 560  : 	const S	*fmt;
; 561  : 	size_t	llen = maxlen;

	mov	DWORD PTR _buf_p$[esp+384], edi
	mov	DWORD PTR _llen$[esp+384], esi
$LN146@atcprintf:

; 562  : 
; 563  : 	buf_p = buffer;
; 564  : 	arg = *param;

	mov	DWORD PTR _arg$[esp+384], ecx
$LN148@atcprintf:
	mov	DWORD PTR _arg$2$[esp+384], ecx
$LN149@atcprintf:

; 566  : 
; 567  : 	while (true)
; 568  : 	{
; 569  : 		// run through the format string until we hit a '%' or '\0'
; 570  : 		for (ch = static_cast<D>(*fmt); 

	mov	al, BYTE PTR [ebx]
	mov	DWORD PTR _llen$1$[esp+384], esi
	mov	DWORD PTR _buf_p$1$[esp+384], edi

; 571  : 			llen && ((ch = static_cast<D>(*fmt)) != '\0' && ch != '%');

	test	esi, esi
	je	SHORT $LN5@atcprintf
$LL6@atcprintf:
	mov	al, BYTE PTR [ebx]
	test	al, al
	je	$done$152
	cmp	al, 37					; 00000025H
	je	SHORT $LN139@atcprintf

; 573  : 		{
; 574  : 			*buf_p++ = static_cast<D>(ch);
; 575  : 			llen--;

	dec	esi
	mov	BYTE PTR [edi], al
	inc	edi
	mov	DWORD PTR _llen$1$[esp+384], esi
	inc	ebx
	mov	DWORD PTR _buf_p$1$[esp+384], edi
	mov	DWORD PTR _buf_p$[esp+384], edi
	mov	DWORD PTR _llen$[esp+384], esi
	test	esi, esi
	jne	SHORT $LL6@atcprintf
$LN139@atcprintf:

; 571  : 			llen && ((ch = static_cast<D>(*fmt)) != '\0' && ch != '%');

	mov	ecx, DWORD PTR _arg$[esp+384]
	mov	DWORD PTR _arg$2$[esp+384], ecx
$LN5@atcprintf:

; 576  : 		}
; 577  : 		if (ch == '\0' || llen <= 0)

	test	al, al
	je	$done$152
	test	esi, esi
	je	$done$152

; 578  : 			goto done;
; 579  : 
; 580  : 		// skip over the '%'
; 581  : 		fmt++;
; 582  : 
; 583  : 		// reset formatting state
; 584  : 		flags = 0;

	xor	ecx, ecx

; 585  : 		width = 0;

	xor	edi, edi
	inc	ebx
	mov	DWORD PTR _flags$1$[esp+384], ecx

; 586  : 		prec = -1;

	or	esi, -1
	mov	DWORD PTR _width$1$[esp+384], edi
	mov	DWORD PTR _prec$1$[esp+384], esi
$rflag$153:

; 587  : 		//sign = '\0';
; 588  : 
; 589  : rflag:
; 590  : 		ch = static_cast<D>(*fmt++);

	mov	dl, BYTE PTR [ebx]
	inc	ebx
	movsx	ecx, dl
	npad	3
$reswitch$154:

; 591  : reswitch:
; 592  : 		switch(ch)

	cmp	ecx, 120				; 00000078H
	ja	$LN67@atcprintf
	movzx	eax, BYTE PTR $LN138@atcprintf[ecx]
	jmp	DWORD PTR $LN151@atcprintf[eax*4]
$LN18@atcprintf:

; 597  : 		case '.':
; 598  : 			n = 0;
; 599  : 			while( is_digit( ( ch = static_cast<D>(*fmt++)) ) )

	mov	dl, BYTE PTR [ebx]
	xor	esi, esi
	movsx	ecx, dl
	lea	eax, DWORD PTR [ecx-48]
	cmp	eax, 9
	ja	SHORT $LN124@atcprintf
$LL9@atcprintf:
	mov	dl, BYTE PTR [ebx+1]

; 600  : 				n = 10 * n + ( ch - '0' );

	lea	eax, DWORD PTR [esi-6]
	inc	ebx
	lea	eax, DWORD PTR [esi+eax*4]
	lea	esi, DWORD PTR [ecx+eax*2]
	movsx	ecx, dl
	lea	eax, DWORD PTR [ecx-48]
	cmp	eax, 9
	jbe	SHORT $LL9@atcprintf
$LN124@atcprintf:

; 597  : 		case '.':
; 598  : 			n = 0;
; 599  : 			while( is_digit( ( ch = static_cast<D>(*fmt++)) ) )

	inc	ebx

; 601  : 			prec = n < 0 ? -1 : n;

	mov	eax, -1
	test	esi, esi
	cmovs	esi, eax
	mov	DWORD PTR _prec$1$[esp+384], esi

; 602  : 			goto reswitch;

	jmp	SHORT $reswitch$154
$LN20@atcprintf:

; 605  : 			goto rflag;
; 606  : 		case '1':
; 607  : 		case '2':
; 608  : 		case '3':
; 609  : 		case '4':
; 610  : 		case '5':
; 611  : 		case '6':
; 612  : 		case '7':
; 613  : 		case '8':
; 614  : 		case '9':
; 615  : 			n = 0;

	xor	edi, edi
$LL13@atcprintf:

; 616  : 			do {
; 617  : 				n = 10 * n + ( ch - '0' );
; 618  : 				ch = static_cast<D>(*fmt++);

	mov	dl, BYTE PTR [ebx]
	lea	eax, DWORD PTR [edi-6]
	lea	eax, DWORD PTR [edi+eax*4]
	inc	ebx
	lea	edi, DWORD PTR [ecx+eax*2]

; 619  : 			} while( is_digit( ch ) );

	movsx	ecx, dl
	lea	eax, DWORD PTR [ecx-48]
	cmp	eax, 9
	jbe	SHORT $LL13@atcprintf
	mov	DWORD PTR _width$1$[esp+384], edi

; 620  : 			width = n;
; 621  : 			goto reswitch;

	jmp	SHORT $reswitch$154
$LN17@atcprintf:

; 593  : 		{
; 594  : 		case '-':
; 595  : 			flags |= LADJUST;

	or	DWORD PTR _flags$1$[esp+384], 4

; 596  : 			goto rflag;

	jmp	SHORT $rflag$153
$LN19@atcprintf:

; 603  : 		case '0':
; 604  : 			flags |= ZEROPAD;

	or	DWORD PTR _flags$1$[esp+384], 128	; 00000080H

; 572  : 			fmt++)

	jmp	$rflag$153
$LN21@atcprintf:

; 622  : 		case 'c':
; 623  : 			CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$2$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN105@atcprintf

; 624  : 			*buf_p++ = static_cast<D>(*get_amxaddr(amx, params[arg]));

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	edi, DWORD PTR _buf_p$1$[esp+392]
	add	esp, 8

; 625  : 			llen--;

	mov	esi, DWORD PTR _llen$1$[esp+384]
	dec	esi
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [edi], al
	inc	edi

; 626  : 			arg++;

	mov	ecx, DWORD PTR _arg$[esp+384]
	inc	ecx

; 627  : 			break;

	jmp	$LN142@atcprintf
$LN23@atcprintf:

; 628  : 		case 'b':
; 629  : 			CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$2$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN105@atcprintf

; 630  : 			AddBinary(&buf_p, llen, *get_amxaddr(amx, params[arg]), width, flags);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	ecx, DWORD PTR _flags$1$[esp+392]
	push	ecx
	push	edi
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR _llen$[esp+404]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+408]
	push	eax
	call	??$AddBinary@D@@YAXPAPADAAIIHH@Z	; AddBinary<char>

; 631  : 			arg++;

	mov	ecx, DWORD PTR _arg$[esp+412]
	add	esp, 28					; 0000001cH

; 632  : 			break;

	mov	esi, DWORD PTR _llen$[esp+384]
	inc	ecx
	mov	edi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN146@atcprintf
$LN25@atcprintf:

; 633  : 		case 'd':
; 634  : 		case 'i':
; 635  : 			CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$2$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN105@atcprintf

; 636  : 			AddInt(&buf_p, llen, *get_amxaddr(amx, params[arg]), width, flags);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	ecx, DWORD PTR _flags$1$[esp+392]
	push	ecx
	push	edi
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR _llen$[esp+404]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+408]
	push	eax
	call	??$AddInt@D@@YAXPAPADAAIHHH@Z		; AddInt<char>
	mov	ecx, DWORD PTR _arg$[esp+412]
	add	esp, 28					; 0000001cH
	mov	esi, DWORD PTR _llen$[esp+384]
	inc	ecx
	mov	edi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN146@atcprintf
$LN27@atcprintf:

; 637  : 			arg++;
; 638  : 			break;
; 639  : 		case 'u':
; 640  : 			CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$2$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN105@atcprintf

; 641  : 			AddUInt(&buf_p, llen, static_cast<unsigned int>(*get_amxaddr(amx, params[arg])), width, flags);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	ecx, DWORD PTR _flags$1$[esp+392]
	push	ecx
	push	edi
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR _llen$[esp+404]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+408]
	push	eax
	call	??$AddUInt@D@@YAXPAPADAAIIHH@Z		; AddUInt<char>
	mov	ecx, DWORD PTR _arg$[esp+412]
	add	esp, 28					; 0000001cH
	mov	esi, DWORD PTR _llen$[esp+384]
	inc	ecx
	mov	edi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN146@atcprintf
$LN29@atcprintf:

; 642  : 			arg++;
; 643  : 			break;
; 644  : 		case 'f':
; 645  : 			CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$2$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN105@atcprintf

; 646  : 			AddFloat(&buf_p, llen, amx_ctof(*get_amxaddr(amx, params[arg])), width, prec, flags);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	ecx, DWORD PTR _flags$1$[esp+392]
	add	esp, 8
	movss	xmm0, DWORD PTR [eax]
	lea	eax, DWORD PTR _llen$[esp+384]
	push	ecx
	push	esi
	push	edi
	cvtps2pd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+408]
	push	eax
	call	??$AddFloat@D@@YAXPAPADAAINHHH@Z	; AddFloat<char>
	mov	ecx, DWORD PTR _arg$[esp+412]
	add	esp, 28					; 0000001cH
	mov	esi, DWORD PTR _llen$[esp+384]
	inc	ecx
	mov	edi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN146@atcprintf
$LN31@atcprintf:

; 647  : 			arg++;
; 648  : 			break;
; 649  : 		case 'X':
; 650  : 			CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$2$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN105@atcprintf

; 651  : 			flags |= UPPERDIGITS;
; 652  : 			AddHex(&buf_p, llen, static_cast<unsigned int>(*get_amxaddr(amx, params[arg])), width, flags);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	ecx, DWORD PTR _flags$1$[esp+392]
	or	ecx, 512				; 00000200H
$LN143@atcprintf:
	push	ecx
	push	edi
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR _llen$[esp+404]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+408]
	push	eax
	call	??$AddHex@D@@YAXPAPADAAIIHH@Z		; AddHex<char>
	mov	ecx, DWORD PTR _arg$[esp+412]
	add	esp, 28					; 0000001cH
	mov	esi, DWORD PTR _llen$[esp+384]
	inc	ecx
	mov	edi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN146@atcprintf
$LN33@atcprintf:

; 653  : 			arg++;
; 654  : 			break;
; 655  : 		case 'x':
; 656  : 			CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$2$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN105@atcprintf

; 657  : 			AddHex(&buf_p, llen, static_cast<unsigned int>(*get_amxaddr(amx, params[arg])), width, flags);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	ecx, DWORD PTR _flags$1$[esp+392]

; 658  : 			arg++;
; 659  : 			break;

	jmp	SHORT $LN143@atcprintf
$LN35@atcprintf:

; 660  : 		case 'a':
; 661  : 			{
; 662  : 				CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$2$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN105@atcprintf

; 663  : 				// %a is passed a pointer directly to a cell string.
; 664  : 				cell* ptr=reinterpret_cast<cell*>(*get_amxaddr(amx, params[arg]));

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 665  : 				if (!ptr)

	test	eax, eax
	je	$LN113@atcprintf

; 669  : 				}
; 670  : 
; 671  : 				AddString(&buf_p, llen, ptr, width, prec);

	push	esi
	push	edi
$LN144@atcprintf:
	push	eax
	lea	eax, DWORD PTR _llen$[esp+396]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+400]
	push	eax
	call	??$AddString@DH@@YAXPAPADAAIPBHHH@Z	; AddString<char,int>
	mov	ecx, DWORD PTR _arg$[esp+404]
	add	esp, 20					; 00000014H
	mov	esi, DWORD PTR _llen$[esp+384]
	inc	ecx
	mov	edi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN146@atcprintf
$LN38@atcprintf:

; 672  : 				arg++;
; 673  : 				break;
; 674  : 			}
; 675  : 		case 's':
; 676  : 			CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$2$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN105@atcprintf

; 677  : 			AddString(&buf_p, llen, get_amxaddr(amx, params[arg]), width, prec);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	esi
	push	edi
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+396]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	add	esp, 8

; 678  : 			arg++;
; 679  : 			break;

	jmp	SHORT $LN144@atcprintf
$LN40@atcprintf:

; 680  : 		case 'L':
; 681  : 		case 'l':
; 682  : 			{
; 683  : 				const char *lang;
; 684  : 				int len;
; 685  : 				if (ch == 'L')

	cmp	dl, 76					; 0000004cH
	jne	SHORT $LN41@atcprintf

; 686  : 				{
; 687  : 					CHECK_ARGS(1);

	mov	ecx, DWORD PTR _arg$2$[esp+384]
	mov	edx, DWORD PTR _args$1$[esp+384]
	lea	eax, DWORD PTR [ecx+1]
	cmp	eax, edx
	jg	$LN115@atcprintf

; 688  : 					auto currParam = params[arg++];

	mov	edi, DWORD PTR _params$GSCopy$1$[esp+384]
	mov	edi, DWORD PTR [edi+ecx*4]

; 689  : 					lang = playerlang(*get_amxaddr(amx, currParam));

	push	edi
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	mov	DWORD PTR _arg$[esp+392], eax
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	push	DWORD PTR [eax]
	call	?playerlang@@YAPBDH@Z			; playerlang
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 690  : 					if (!lang)

	test	esi, esi
	jne	SHORT $LN42@atcprintf

; 691  : 						lang = get_amxstring(amx, currParam, 2, len);

	lea	eax, DWORD PTR _len$1[esp+384]
	push	eax
	push	2
	push	edi
	push	DWORD PTR _amx$GSCopy$1$[esp+396]
	call	?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z	; get_amxstring
	add	esp, 16					; 00000010H

; 692  : 				}
; 693  : 				else

	jmp	SHORT $LN147@atcprintf
$LN41@atcprintf:

; 694  : 				{
; 695  : 					CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$2$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN105@atcprintf

; 696  : 					lang = playerlang(g_langMngr.GetDefLang());

	push	DWORD PTR ?g_langMngr@@3VCLangMngr@@A+68
	call	?playerlang@@YAPBDH@Z			; playerlang
	add	esp, 4
$LN147@atcprintf:
	mov	esi, eax
$LN42@atcprintf:

; 697  : 				}
; 698  : 				const char *key = get_amxstring(amx, params[arg++], 3, len);

	mov	eax, DWORD PTR _arg$[esp+384]
	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	mov	ecx, DWORD PTR [ecx+eax*4]
	inc	eax
	mov	DWORD PTR _arg$[esp+384], eax
	lea	eax, DWORD PTR _len$1[esp+384]
	push	eax
	push	3
	push	ecx
	push	DWORD PTR _amx$GSCopy$1$[esp+396]
	call	?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z	; get_amxstring
	mov	edi, eax

; 699  : 				const char *def = translate(amx, lang, key);

	push	edi
	push	esi
	mov	esi, DWORD PTR _amx$GSCopy$1$[esp+408]
	push	esi
	call	?translate@@YAPBDPAUtagAMX@@PBD1@Z	; translate
	add	esp, 28					; 0000001cH

; 700  : 				if (!def)

	test	eax, eax
	jne	SHORT $LN46@atcprintf

; 701  : 				{
; 702  : 					static char buf[255];
; 703  : 					ke::SafeSprintf(buf, sizeof(buf), "ML_NOTFOUND: %s", key);

	push	edi
	push	OFFSET ??_C@_0BA@HJJJBHCN@ML_NOTFOUND?3?5?$CFs?$AA@
	push	255					; 000000ffH
	push	OFFSET ?buf@?DN@???$atcprintf@DD@@YAIPADIPBDPAUtagAMX@@PAH3@Z@4PADA ; `atcprintf<char,char>'::`61'::buf
	call	?SafeSprintf@ke@@YAIPADIPBDZZ		; ke::SafeSprintf
	add	esp, 16					; 00000010H

; 704  : 					def = buf;

	mov	eax, OFFSET ?buf@?DN@???$atcprintf@DD@@YAIPADIPBDPAUtagAMX@@PAH3@Z@4PADA ; `atcprintf<char,char>'::`61'::buf
$LN46@atcprintf:

; 705  : 				}
; 706  : 				size_t written = atcprintf(buf_p, llen, def, amx, params, &arg);

	mov	edi, DWORD PTR _buf_p$1$[esp+384]
	lea	ecx, DWORD PTR _arg$[esp+384]
	push	ecx
	push	DWORD PTR _params$GSCopy$1$[esp+388]
	push	esi
	mov	esi, DWORD PTR _llen$1$[esp+396]
	push	eax
	push	esi
	push	edi
	call	??$atcprintf@DD@@YAIPADIPBDPAUtagAMX@@PAH3@Z ; atcprintf<char,char>

; 707  : 				buf_p += written;
; 708  : 				llen -= written;
; 709  : 				break;

	mov	ecx, DWORD PTR _arg$[esp+408]
	add	edi, eax
	add	esp, 24					; 00000018H
	mov	DWORD PTR _buf_p$[esp+384], edi
	sub	esi, eax
	mov	DWORD PTR _llen$[esp+384], esi
	jmp	$LN148@atcprintf
$LN47@atcprintf:

; 710  : 			}
; 711  : 		case 'N':
; 712  : 			{
; 713  : 				CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$2$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN105@atcprintf

; 714  : 				cell *addr = get_amxaddr(amx, params[arg]);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	add	esp, 8

; 715  : 				char buffer[255];
; 716  : 				if (*addr)

	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	$LN49@atcprintf

; 717  : 				{
; 718  : 					CPlayer *player = NULL;
; 719  : 
; 720  : 					if (*addr >= 1 && *addr <= gpGlobals->maxClients)

	cmp	edx, 1
	jl	$LN118@atcprintf
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	cmp	edx, DWORD PTR [ecx+148]
	jg	$LN118@atcprintf

; 721  : 					{
; 722  : 						player = GET_PLAYER_POINTER_I(*addr);

	imul	esi, edx, 564
	add	esi, OFFSET ?g_players@@3PAVCPlayer@@A	; g_players
	mov	DWORD PTR _player$1$[esp+384], esi

; 723  : 					}
; 724  : 
; 725  : 					if (!player || !player->initialized)

	je	$LN118@atcprintf
	cmp	BYTE PTR [esi+28], 0
	je	$LN118@atcprintf

; 729  : 					}
; 730  : 
; 731  : 					unsigned int auth = GETPLAYERAUTHID(player->pEdict); //DYLAN FIX GETPLAYERAUTHID(player->pEdict);

	push	DWORD PTR [esi]
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+476

; 732  : #if 0
; 733  : 					if (!auth || auth[0] == '\0')
; 734  : 					{
; 735  : 						auth = "STEAM_ID_PENDING";
; 736  : 					}
; 737  : #endif
; 738  : 
; 739  : 					int userid = GETPLAYERUSERID(player->pEdict);

	push	DWORD PTR [esi]
	mov	edi, eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+464
	mov	esi, eax
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 128  :     if (!chars_)

	mov	edx, OFFSET ??_C@_00CNPNBAHC@?$AA@
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 144  :       return !t_;

	mov	eax, DWORD PTR _player$1$[esp+392]
	mov	ecx, DWORD PTR [eax+20]
	test	ecx, ecx
	mov	eax, DWORD PTR [eax+4]
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 128  :     if (!chars_)

	cmovne	edx, ecx
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 144  :       return !t_;

	test	eax, eax
; File e:\nightfire_sdk\amx\amxmodx\format.cpp

; 740  : 					ke::SafeSprintf(buffer, sizeof(buffer), "%s<%d><%u><%s>", player->name.chars(), userid, auth, player->team.chars());

	push	edx
	push	edi
	push	esi
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 128  :     if (!chars_)

	mov	ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
	cmovne	ecx, eax
; File e:\nightfire_sdk\amx\amxmodx\format.cpp

; 740  : 					ke::SafeSprintf(buffer, sizeof(buffer), "%s<%d><%u><%s>", player->name.chars(), userid, auth, player->team.chars());

	lea	eax, DWORD PTR _buffer$2[esp+404]
	push	ecx
	push	OFFSET ??_C@_0P@JDPKEEME@?$CFs?$DM?$CFd?$DO?$DM?$CFu?$DO?$DM?$CFs?$DO?$AA@
	push	255					; 000000ffH
	push	eax
	call	?SafeSprintf@ke@@YAIPADIPBDZZ		; ke::SafeSprintf

; 741  : 				}
; 742  : 				else

	mov	esi, DWORD PTR _prec$1$[esp+420]
	add	esp, 36					; 00000024H
	mov	edi, DWORD PTR _width$1$[esp+384]
	jmp	SHORT $LN50@atcprintf
$LN49@atcprintf:

; 743  : 				{
; 744  : 					ke::SafeSprintf(buffer, sizeof(buffer), "Console<0><Console><Console>");

	push	OFFSET ??_C@_0BN@PONBEONJ@Console?$DM0?$DO?$DMConsole?$DO?$DMConsole?$DO?$AA@
	lea	eax, DWORD PTR _buffer$2[esp+388]
	push	255					; 000000ffH
	push	eax
	call	?SafeSprintf@ke@@YAIPADIPBDZZ		; ke::SafeSprintf
	add	esp, 12					; 0000000cH
$LN50@atcprintf:

; 745  : 				}
; 746  : 
; 747  : 				AddString(&buf_p, llen, buffer, width, prec);

	push	esi
	push	edi
	lea	eax, DWORD PTR _buffer$2[esp+392]
	push	eax
	lea	eax, DWORD PTR _llen$[esp+396]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+400]
	push	eax
	call	??$AddString@DD@@YAXPAPADAAIPBDHH@Z	; AddString<char,char>
	mov	ecx, DWORD PTR _arg$[esp+404]
	add	esp, 20					; 00000014H
	mov	esi, DWORD PTR _llen$[esp+384]
	inc	ecx
	mov	edi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN146@atcprintf
$LN54@atcprintf:

; 748  : 				arg++;
; 749  : 				break;
; 750  : 			}
; 751  : 		case 'n':
; 752  : 			{
; 753  : 				CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$2$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN105@atcprintf

; 754  : 				cell *addr = get_amxaddr(amx, params[arg]);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	edx, eax
	add	esp, 8
	mov	DWORD PTR _addr$1$[esp+384], edx

; 755  : 				const char *name = "Console";

	mov	ecx, OFFSET ??_C@_07PGLPGHFC@Console?$AA@

; 756  : 
; 757  : 				if (*addr)

	mov	edx, DWORD PTR [edx]
	test	edx, edx
	je	SHORT $LN89@atcprintf

; 758  : 				{
; 759  : 					CPlayer *player = NULL;
; 760  : 
; 761  : 					if (*addr >= 1 && *addr <= gpGlobals->maxClients)

	cmp	edx, 1
	jl	$LN120@atcprintf
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	cmp	edx, DWORD PTR [ecx+148]
	jg	$LN120@atcprintf

; 762  : 					{
; 763  : 						player = GET_PLAYER_POINTER_I(*addr);

	imul	eax, edx, 564
	add	eax, OFFSET ?g_players@@3PAVCPlayer@@A	; g_players

; 764  : 					}
; 765  : 
; 766  : 					if (!player || !player->initialized)

	je	$LN120@atcprintf
	cmp	BYTE PTR [eax+28], 0
	je	$LN120@atcprintf
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 144  :       return !t_;

	mov	eax, DWORD PTR [eax+4]
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 128  :     if (!chars_)

	mov	ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 144  :       return !t_;

	test	eax, eax
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 128  :     if (!chars_)

	cmovne	ecx, eax
$LN89@atcprintf:
; File e:\nightfire_sdk\amx\amxmodx\format.cpp

; 775  : 				AddString(&buf_p, llen, name, width, prec);

	push	esi
	push	edi
	push	ecx
	lea	eax, DWORD PTR _llen$[esp+396]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+400]
	push	eax
	call	??$AddString@DD@@YAXPAPADAAIPBDHH@Z	; AddString<char,char>
	mov	ecx, DWORD PTR _arg$[esp+404]
	add	esp, 20					; 00000014H
	mov	esi, DWORD PTR _llen$[esp+384]
	inc	ecx
	mov	edi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN146@atcprintf
$LN60@atcprintf:

; 776  : 				arg++;
; 777  : 				break;
; 778  : 			}
; 779  : 		case '%':
; 780  : 			*buf_p++ = static_cast<D>(ch);

	mov	edi, DWORD PTR _buf_p$1$[esp+384]

; 781  : 			if (!llen)
; 782  : 				goto done;
; 783  : 			llen--;

	mov	esi, DWORD PTR _llen$1$[esp+384]
	mov	BYTE PTR [edi], dl
	inc	edi

; 784  : 			break;

	mov	eax, DWORD PTR _arg$[esp+384]
	dec	esi
	mov	DWORD PTR _buf_p$[esp+384], edi
	mov	DWORD PTR _llen$[esp+384], esi
	mov	DWORD PTR _arg$2$[esp+384], eax
	jmp	$LN149@atcprintf
$LN67@atcprintf:

; 790  : 			goto done;
; 791  : 			break;
; 792  : 		default:
; 793  : 			*buf_p++ = static_cast<D>(ch);

	mov	edi, DWORD PTR _buf_p$1$[esp+384]

; 794  : 			if (!llen)
; 795  : 				goto done;
; 796  : 			llen--;

	mov	esi, DWORD PTR _llen$1$[esp+384]
	mov	BYTE PTR [edi], dl
	inc	edi

; 797  : 			break;
; 798  : 		}
; 799  : 	}

	mov	ecx, DWORD PTR _arg$[esp+384]
	dec	esi
	mov	DWORD PTR _buf_p$[esp+384], edi
	mov	DWORD PTR _llen$[esp+384], esi
	jmp	$LN148@atcprintf
$LN105@atcprintf:

; 622  : 		case 'c':
; 623  : 			CHECK_ARGS(0);

	push	ecx
	push	eax
	push	OFFSET ??_C@_0DH@NEIDFOJI@String?5formatted?5incorrectly?5?9?5p@
	push	25					; 00000019H
	push	DWORD PTR _amx$GSCopy$1$[esp+400]
	call	_LogError
	add	esp, 20					; 00000014H
	xor	eax, eax

; 813  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+372]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN113@atcprintf:

; 666  : 				{
; 667  : 					LogError(amx, AMX_ERR_NATIVE, "Invalid vector string handle provided (%d)", *get_amxaddr(amx, params[arg]));

	mov	eax, DWORD PTR _arg$[esp+384]
	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	mov	ebx, DWORD PTR _amx$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	ebx
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	push	DWORD PTR [eax]
	push	OFFSET ??_C@_0CL@GCKMCDNK@Invalid?5vector?5string?5handle?5pro@
	push	10					; 0000000aH
	push	ebx
	call	_LogError
	add	esp, 24					; 00000018H

; 668  : 					return 0;

	xor	eax, eax

; 813  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+372]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN115@atcprintf:

; 686  : 				{
; 687  : 					CHECK_ARGS(1);

	push	edx
	push	ecx
	push	OFFSET ??_C@_0DH@NEIDFOJI@String?5formatted?5incorrectly?5?9?5p@
	push	25					; 00000019H
	push	DWORD PTR _amx$GSCopy$1$[esp+400]
	call	_LogError
	add	esp, 20					; 00000014H
	xor	eax, eax

; 813  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+372]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN118@atcprintf:

; 726  : 					{
; 727  : 						LogError(amx, AMX_ERR_NATIVE, "Client index %d is invalid", *addr);

	push	edx
	push	OFFSET ??_C@_0BL@KOKBGDMJ@Client?5index?5?$CFd?5is?5invalid?$AA@
	push	10					; 0000000aH
	push	DWORD PTR _amx$GSCopy$1$[esp+396]
	call	_LogError
	add	esp, 16					; 00000010H

; 728  : 						return 0;

	xor	eax, eax

; 813  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+372]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN120@atcprintf:

; 767  : 					{
; 768  : 						LogError(amx, AMX_ERR_NATIVE, "Client index %d is invalid", *addr);

	mov	eax, DWORD PTR _addr$1$[esp+384]
	push	DWORD PTR [eax]
	push	OFFSET ??_C@_0BL@KOKBGDMJ@Client?5index?5?$CFd?5is?5invalid?$AA@
	push	10					; 0000000aH
	push	DWORD PTR _amx$GSCopy$1$[esp+396]
	call	_LogError
	add	esp, 16					; 00000010H

; 769  : 						return 0;

	xor	eax, eax

; 813  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+372]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN63@atcprintf:

; 785  : 		case '\0':
; 786  : 			*buf_p++ = static_cast<D>('%');

	mov	edi, DWORD PTR _buf_p$1$[esp+384]

; 787  : 			if (!llen)
; 788  : 				goto done;
; 789  : 			llen--;

	mov	esi, DWORD PTR _llen$1$[esp+384]
	mov	BYTE PTR [edi], 37			; 00000025H
	inc	edi
	dec	esi
$done$152:

; 800  : 
; 801  : done:
; 802  : 	*buf_p = static_cast<D>(0);
; 803  : 	*param = arg;

	mov	ecx, DWORD PTR _param$GSCopy$1$[esp+384]
	mov	BYTE PTR [edi], 0
	mov	eax, DWORD PTR _arg$[esp+384]
	mov	DWORD PTR [ecx], eax

; 804  : 
; 805  : 	/* if max buffer length consumed, make sure we don't truncate a multi-byte character */
; 806  : 	if (llen <= 0 && *(buf_p - 1) & 1 << 7)

	test	esi, esi
	jne	SHORT $LN70@atcprintf
	cmp	BYTE PTR [edi-1], 0
	lea	eax, DWORD PTR [edi-1]
	jge	SHORT $LN70@atcprintf

; 807  : 	{
; 808  : 		llen += UTIL_CheckValidChar(buf_p - 1);

	push	eax
	call	??$UTIL_CheckValidChar@D@@YAHPAD@Z	; UTIL_CheckValidChar<char>
	mov	esi, eax
	add	esp, 4

; 809  : 		*(buf_p - llen) = static_cast<D>(0);

	sub	edi, esi
	mov	BYTE PTR [edi], 0
$LN70@atcprintf:

; 810  : 	}
; 811  : 
; 812  : 	return maxlen-llen;

	mov	eax, DWORD PTR _maxlen$[ebp]

; 813  : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+384]
	sub	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN151@atcprintf:
	DD	$LN63@atcprintf
	DD	$LN60@atcprintf
	DD	$LN17@atcprintf
	DD	$LN18@atcprintf
	DD	$LN19@atcprintf
	DD	$LN20@atcprintf
	DD	$LN40@atcprintf
	DD	$LN47@atcprintf
	DD	$LN31@atcprintf
	DD	$LN35@atcprintf
	DD	$LN23@atcprintf
	DD	$LN21@atcprintf
	DD	$LN25@atcprintf
	DD	$LN29@atcprintf
	DD	$LN54@atcprintf
	DD	$LN38@atcprintf
	DD	$LN27@atcprintf
	DD	$LN33@atcprintf
	DD	$LN67@atcprintf
$LN138@atcprintf:
	DB	0
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	1
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	2
	DB	3
	DB	18					; 00000012H
	DB	4
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	6
	DB	18					; 00000012H
	DB	7
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	8
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	18					; 00000012H
	DB	13					; 0000000dH
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	12					; 0000000cH
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	6
	DB	18					; 00000012H
	DB	14					; 0000000eH
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	15					; 0000000fH
	DB	18					; 00000012H
	DB	16					; 00000010H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	17					; 00000011H
??$atcprintf@DD@@YAIPADIPBDPAUtagAMX@@PAH3@Z ENDP	; atcprintf<char,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
;	COMDAT ??$atcprintf@HD@@YAIPAHIPBDPAUtagAMX@@00@Z
_TEXT	SEGMENT
_arg$ = -320						; size = 4
_amx$GSCopy$1$ = -316					; size = 4
_arg$2$ = -312						; size = 4
_buf_p$ = -308						; size = 4
_llen$ = -304						; size = 4
_buf_p$1$ = -300					; size = 4
_llen$1$ = -296						; size = 4
_params$GSCopy$1$ = -292				; size = 4
_args$1$ = -288						; size = 4
_player$1$ = -284					; size = 4
_flags$1$ = -284					; size = 4
_addr$1$ = -280						; size = 4
_width$1$ = -280					; size = 4
_prec$1$ = -276						; size = 4
_len$1 = -272						; size = 4
_param$GSCopy$1$ = -268					; size = 4
_buffer$2 = -264					; size = 255
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_maxlen$ = 12						; size = 4
_format$ = 16						; size = 4
_amx$ = 20						; size = 4
_params$ = 24						; size = 4
_param$ = 28						; size = 4
??$atcprintf@HD@@YAIPAHIPBDPAUtagAMX@@00@Z PROC		; atcprintf<int,char>, COMDAT

; 550  : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 372				; 00000174H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+372], eax
	mov	eax, DWORD PTR _amx$[ebp]
	mov	ecx, DWORD PTR _param$[ebp]

; 551  : 	int		arg;
; 552  : 	int		args = params[0] / sizeof(cell);
; 553  : 	D		*buf_p;
; 554  : 	D		ch;
; 555  : 	int		flags;
; 556  : 	int		width;
; 557  : 	int		prec;
; 558  : 	int		n;
; 559  : 	//char	sign;
; 560  : 	const S	*fmt;
; 561  : 	size_t	llen = maxlen;

	mov	edx, DWORD PTR _maxlen$[ebp]
	push	ebx

; 565  : 	fmt = format;

	mov	ebx, DWORD PTR _format$[ebp]
	mov	DWORD PTR _amx$GSCopy$1$[esp+376], eax
	mov	eax, DWORD PTR _params$[ebp]
	push	esi
	mov	esi, DWORD PTR _buffer$[ebp]
	push	edi
	mov	edi, DWORD PTR [eax]
	shr	edi, 2
	mov	DWORD PTR _param$GSCopy$1$[esp+384], ecx
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR _params$GSCopy$1$[esp+384], eax
	mov	DWORD PTR _args$1$[esp+384], edi
$LN142@atcprintf:

; 551  : 	int		arg;
; 552  : 	int		args = params[0] / sizeof(cell);
; 553  : 	D		*buf_p;
; 554  : 	D		ch;
; 555  : 	int		flags;
; 556  : 	int		width;
; 557  : 	int		prec;
; 558  : 	int		n;
; 559  : 	//char	sign;
; 560  : 	const S	*fmt;
; 561  : 	size_t	llen = maxlen;

	mov	DWORD PTR _buf_p$[esp+384], esi
	mov	DWORD PTR _llen$[esp+384], edx
$LN146@atcprintf:

; 562  : 
; 563  : 	buf_p = buffer;
; 564  : 	arg = *param;

	mov	DWORD PTR _arg$[esp+384], ecx
$LN148@atcprintf:
	mov	DWORD PTR _arg$2$[esp+384], ecx
$LN149@atcprintf:

; 566  : 
; 567  : 	while (true)
; 568  : 	{
; 569  : 		// run through the format string until we hit a '%' or '\0'
; 570  : 		for (ch = static_cast<D>(*fmt); 

	movsx	eax, BYTE PTR [ebx]
	mov	DWORD PTR _llen$1$[esp+384], edx
	mov	DWORD PTR _buf_p$1$[esp+384], esi

; 571  : 			llen && ((ch = static_cast<D>(*fmt)) != '\0' && ch != '%');

	test	edx, edx
	je	SHORT $LN5@atcprintf
$LL6@atcprintf:
	movsx	eax, BYTE PTR [ebx]
	test	eax, eax
	je	$done$156
	cmp	eax, 37					; 00000025H
	je	SHORT $LN139@atcprintf

; 573  : 		{
; 574  : 			*buf_p++ = static_cast<D>(ch);
; 575  : 			llen--;

	dec	edx
	mov	DWORD PTR [esi], eax
	add	esi, 4
	mov	DWORD PTR _llen$1$[esp+384], edx
	inc	ebx
	mov	DWORD PTR _buf_p$1$[esp+384], esi
	mov	DWORD PTR _buf_p$[esp+384], esi
	mov	DWORD PTR _llen$[esp+384], edx
	test	edx, edx
	jne	SHORT $LL6@atcprintf
$LN139@atcprintf:

; 571  : 			llen && ((ch = static_cast<D>(*fmt)) != '\0' && ch != '%');

	mov	ecx, DWORD PTR _arg$[esp+384]
	mov	DWORD PTR _arg$2$[esp+384], ecx
$LN5@atcprintf:

; 576  : 		}
; 577  : 		if (ch == '\0' || llen <= 0)

	test	eax, eax
	je	$done$156
	test	edx, edx
	je	$done$156

; 578  : 			goto done;
; 579  : 
; 580  : 		// skip over the '%'
; 581  : 		fmt++;
; 582  : 
; 583  : 		// reset formatting state
; 584  : 		flags = 0;

	xor	ecx, ecx

; 585  : 		width = 0;

	xor	edi, edi
	inc	ebx
	mov	DWORD PTR _flags$1$[esp+384], ecx

; 586  : 		prec = -1;

	or	esi, -1
	mov	DWORD PTR _width$1$[esp+384], edi
	mov	DWORD PTR _prec$1$[esp+384], esi
	npad	4
$rflag$157:

; 587  : 		//sign = '\0';
; 588  : 
; 589  : rflag:
; 590  : 		ch = static_cast<D>(*fmt++);

	movsx	ecx, BYTE PTR [ebx]
	inc	ebx
$reswitch$158:

; 591  : reswitch:
; 592  : 		switch(ch)

	cmp	ecx, 120				; 00000078H
	ja	$LN67@atcprintf
	movzx	eax, BYTE PTR $LN138@atcprintf[ecx]
	jmp	DWORD PTR $LN155@atcprintf[eax*4]
$LN18@atcprintf:

; 597  : 		case '.':
; 598  : 			n = 0;
; 599  : 			while( is_digit( ( ch = static_cast<D>(*fmt++)) ) )

	movsx	ecx, BYTE PTR [ebx]
	xor	esi, esi
	lea	eax, DWORD PTR [ecx-48]
	cmp	eax, 9
	ja	SHORT $LN124@atcprintf
$LL9@atcprintf:
	inc	ebx

; 600  : 				n = 10 * n + ( ch - '0' );

	lea	eax, DWORD PTR [esi-6]
	lea	eax, DWORD PTR [esi+eax*4]
	lea	esi, DWORD PTR [ecx+eax*2]
	movsx	ecx, BYTE PTR [ebx]
	lea	eax, DWORD PTR [ecx-48]
	cmp	eax, 9
	jbe	SHORT $LL9@atcprintf
$LN124@atcprintf:

; 597  : 		case '.':
; 598  : 			n = 0;
; 599  : 			while( is_digit( ( ch = static_cast<D>(*fmt++)) ) )

	inc	ebx

; 601  : 			prec = n < 0 ? -1 : n;

	mov	eax, -1
	test	esi, esi
	cmovs	esi, eax
	mov	DWORD PTR _prec$1$[esp+384], esi

; 602  : 			goto reswitch;

	jmp	SHORT $reswitch$158
$LN20@atcprintf:

; 605  : 			goto rflag;
; 606  : 		case '1':
; 607  : 		case '2':
; 608  : 		case '3':
; 609  : 		case '4':
; 610  : 		case '5':
; 611  : 		case '6':
; 612  : 		case '7':
; 613  : 		case '8':
; 614  : 		case '9':
; 615  : 			n = 0;

	xor	edi, edi
$LL13@atcprintf:

; 616  : 			do {
; 617  : 				n = 10 * n + ( ch - '0' );

	lea	eax, DWORD PTR [edi-6]
	lea	eax, DWORD PTR [edi+eax*4]
	lea	edi, DWORD PTR [ecx+eax*2]

; 618  : 				ch = static_cast<D>(*fmt++);

	movsx	ecx, BYTE PTR [ebx]
	inc	ebx

; 619  : 			} while( is_digit( ch ) );

	lea	eax, DWORD PTR [ecx-48]
	cmp	eax, 9
	jbe	SHORT $LL13@atcprintf
	mov	DWORD PTR _width$1$[esp+384], edi

; 620  : 			width = n;
; 621  : 			goto reswitch;

	jmp	SHORT $reswitch$158
$LN17@atcprintf:

; 593  : 		{
; 594  : 		case '-':
; 595  : 			flags |= LADJUST;

	or	DWORD PTR _flags$1$[esp+384], 4

; 596  : 			goto rflag;

	jmp	SHORT $rflag$157
$LN19@atcprintf:

; 603  : 		case '0':
; 604  : 			flags |= ZEROPAD;

	or	DWORD PTR _flags$1$[esp+384], 128	; 00000080H

; 572  : 			fmt++)

	jmp	SHORT $rflag$157
$LN21@atcprintf:

; 622  : 		case 'c':
; 623  : 			CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$2$[esp+384]
	mov	edi, DWORD PTR _args$1$[esp+384]
	cmp	eax, edi
	jg	$LN105@atcprintf

; 624  : 			*buf_p++ = static_cast<D>(*get_amxaddr(amx, params[arg]));

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	esi, DWORD PTR _buf_p$1$[esp+392]
	add	esp, 8

; 625  : 			llen--;

	mov	edx, DWORD PTR _llen$1$[esp+384]
	dec	edx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax
	add	esi, 4

; 626  : 			arg++;

	mov	ecx, DWORD PTR _arg$[esp+384]
	inc	ecx

; 627  : 			break;

	jmp	$LN142@atcprintf
$LN23@atcprintf:

; 628  : 		case 'b':
; 629  : 			CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$2$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN106@atcprintf

; 630  : 			AddBinary(&buf_p, llen, *get_amxaddr(amx, params[arg]), width, flags);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	ecx, DWORD PTR _flags$1$[esp+392]
	push	ecx
	push	edi
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR _llen$[esp+404]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+408]
	push	eax
	call	??$AddBinary@H@@YAXPAPAHAAIIHH@Z	; AddBinary<int>

; 631  : 			arg++;

	mov	ecx, DWORD PTR _arg$[esp+412]
	add	esp, 28					; 0000001cH

; 632  : 			break;

	mov	edx, DWORD PTR _llen$[esp+384]
	inc	ecx
	mov	esi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN146@atcprintf
$LN25@atcprintf:

; 633  : 		case 'd':
; 634  : 		case 'i':
; 635  : 			CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$2$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN106@atcprintf

; 636  : 			AddInt(&buf_p, llen, *get_amxaddr(amx, params[arg]), width, flags);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	ecx, DWORD PTR _flags$1$[esp+392]
	push	ecx
	push	edi
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR _llen$[esp+404]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+408]
	push	eax
	call	??$AddInt@H@@YAXPAPAHAAIHHH@Z		; AddInt<int>
	mov	ecx, DWORD PTR _arg$[esp+412]
	add	esp, 28					; 0000001cH
	mov	edx, DWORD PTR _llen$[esp+384]
	inc	ecx
	mov	esi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN146@atcprintf
$LN27@atcprintf:

; 637  : 			arg++;
; 638  : 			break;
; 639  : 		case 'u':
; 640  : 			CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$2$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN106@atcprintf

; 641  : 			AddUInt(&buf_p, llen, static_cast<unsigned int>(*get_amxaddr(amx, params[arg])), width, flags);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	ecx, DWORD PTR _flags$1$[esp+392]
	push	ecx
	push	edi
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR _llen$[esp+404]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+408]
	push	eax
	call	??$AddUInt@H@@YAXPAPAHAAIIHH@Z		; AddUInt<int>
	mov	ecx, DWORD PTR _arg$[esp+412]
	add	esp, 28					; 0000001cH
	mov	edx, DWORD PTR _llen$[esp+384]
	inc	ecx
	mov	esi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN146@atcprintf
$LN29@atcprintf:

; 642  : 			arg++;
; 643  : 			break;
; 644  : 		case 'f':
; 645  : 			CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$2$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN106@atcprintf

; 646  : 			AddFloat(&buf_p, llen, amx_ctof(*get_amxaddr(amx, params[arg])), width, prec, flags);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	ecx, DWORD PTR _flags$1$[esp+392]
	add	esp, 8
	movss	xmm0, DWORD PTR [eax]
	lea	eax, DWORD PTR _llen$[esp+384]
	push	ecx
	push	esi
	push	edi
	cvtps2pd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+408]
	push	eax
	call	??$AddFloat@H@@YAXPAPAHAAINHHH@Z	; AddFloat<int>
	mov	ecx, DWORD PTR _arg$[esp+412]
	add	esp, 28					; 0000001cH
	mov	edx, DWORD PTR _llen$[esp+384]
	inc	ecx
	mov	esi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN146@atcprintf
$LN31@atcprintf:

; 647  : 			arg++;
; 648  : 			break;
; 649  : 		case 'X':
; 650  : 			CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$2$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN106@atcprintf

; 651  : 			flags |= UPPERDIGITS;
; 652  : 			AddHex(&buf_p, llen, static_cast<unsigned int>(*get_amxaddr(amx, params[arg])), width, flags);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	ecx, DWORD PTR _flags$1$[esp+392]
	or	ecx, 512				; 00000200H
$LN143@atcprintf:
	push	ecx
	push	edi
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR _llen$[esp+404]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+408]
	push	eax
	call	??$AddHex@H@@YAXPAPAHAAIIHH@Z		; AddHex<int>
	mov	ecx, DWORD PTR _arg$[esp+412]
	add	esp, 28					; 0000001cH
	mov	edx, DWORD PTR _llen$[esp+384]
	inc	ecx
	mov	esi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN146@atcprintf
$LN33@atcprintf:

; 653  : 			arg++;
; 654  : 			break;
; 655  : 		case 'x':
; 656  : 			CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$2$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN106@atcprintf

; 657  : 			AddHex(&buf_p, llen, static_cast<unsigned int>(*get_amxaddr(amx, params[arg])), width, flags);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	ecx, DWORD PTR _flags$1$[esp+392]

; 658  : 			arg++;
; 659  : 			break;

	jmp	SHORT $LN143@atcprintf
$LN35@atcprintf:

; 660  : 		case 'a':
; 661  : 			{
; 662  : 				CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$2$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN106@atcprintf

; 663  : 				// %a is passed a pointer directly to a cell string.
; 664  : 				cell* ptr=reinterpret_cast<cell*>(*get_amxaddr(amx, params[arg]));

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 665  : 				if (!ptr)

	test	eax, eax
	je	$LN113@atcprintf

; 668  : 					return 0;
; 669  : 				}
; 670  : 
; 671  : 				AddString(&buf_p, llen, ptr, width, prec);

	push	esi
	push	edi
$LN144@atcprintf:
	push	eax
	lea	eax, DWORD PTR _llen$[esp+396]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+400]
	push	eax
	call	??$AddString@HH@@YAXPAPAHAAIPBHHH@Z	; AddString<int,int>
	mov	ecx, DWORD PTR _arg$[esp+404]
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _llen$[esp+384]
	inc	ecx
	mov	esi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN146@atcprintf
$LN38@atcprintf:

; 672  : 				arg++;
; 673  : 				break;
; 674  : 			}
; 675  : 		case 's':
; 676  : 			CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$2$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN106@atcprintf

; 677  : 			AddString(&buf_p, llen, get_amxaddr(amx, params[arg]), width, prec);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	esi
	push	edi
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+396]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	add	esp, 8

; 678  : 			arg++;
; 679  : 			break;

	jmp	SHORT $LN144@atcprintf
$LN40@atcprintf:

; 680  : 		case 'L':
; 681  : 		case 'l':
; 682  : 			{
; 683  : 				const char *lang;
; 684  : 				int len;
; 685  : 				if (ch == 'L')

	cmp	ecx, 76					; 0000004cH
	jne	SHORT $LN41@atcprintf

; 686  : 				{
; 687  : 					CHECK_ARGS(1);

	mov	ecx, DWORD PTR _arg$2$[esp+384]
	mov	edx, DWORD PTR _args$1$[esp+384]
	lea	eax, DWORD PTR [ecx+1]
	cmp	eax, edx
	jg	$LN115@atcprintf

; 688  : 					auto currParam = params[arg++];

	mov	edi, DWORD PTR _params$GSCopy$1$[esp+384]
	mov	edi, DWORD PTR [edi+ecx*4]

; 689  : 					lang = playerlang(*get_amxaddr(amx, currParam));

	push	edi
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	mov	DWORD PTR _arg$[esp+392], eax
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	push	DWORD PTR [eax]
	call	?playerlang@@YAPBDH@Z			; playerlang
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 690  : 					if (!lang)

	test	esi, esi
	jne	SHORT $LN42@atcprintf

; 691  : 						lang = get_amxstring(amx, currParam, 2, len);

	lea	eax, DWORD PTR _len$1[esp+384]
	push	eax
	push	2
	push	edi
	push	DWORD PTR _amx$GSCopy$1$[esp+396]
	call	?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z	; get_amxstring
	add	esp, 16					; 00000010H

; 692  : 				}
; 693  : 				else

	jmp	SHORT $LN147@atcprintf
$LN41@atcprintf:

; 694  : 				{
; 695  : 					CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$2$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN106@atcprintf

; 696  : 					lang = playerlang(g_langMngr.GetDefLang());

	push	DWORD PTR ?g_langMngr@@3VCLangMngr@@A+68
	call	?playerlang@@YAPBDH@Z			; playerlang
	add	esp, 4
$LN147@atcprintf:
	mov	esi, eax
$LN42@atcprintf:

; 697  : 				}
; 698  : 				const char *key = get_amxstring(amx, params[arg++], 3, len);

	mov	eax, DWORD PTR _arg$[esp+384]
	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	mov	ecx, DWORD PTR [ecx+eax*4]
	inc	eax
	mov	DWORD PTR _arg$[esp+384], eax
	lea	eax, DWORD PTR _len$1[esp+384]
	push	eax
	push	3
	push	ecx
	push	DWORD PTR _amx$GSCopy$1$[esp+396]
	call	?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z	; get_amxstring
	mov	edi, eax

; 699  : 				const char *def = translate(amx, lang, key);

	push	edi
	push	esi
	mov	esi, DWORD PTR _amx$GSCopy$1$[esp+408]
	push	esi
	call	?translate@@YAPBDPAUtagAMX@@PBD1@Z	; translate
	add	esp, 28					; 0000001cH

; 700  : 				if (!def)

	test	eax, eax
	jne	SHORT $LN46@atcprintf

; 701  : 				{
; 702  : 					static char buf[255];
; 703  : 					ke::SafeSprintf(buf, sizeof(buf), "ML_NOTFOUND: %s", key);

	push	edi
	push	OFFSET ??_C@_0BA@HJJJBHCN@ML_NOTFOUND?3?5?$CFs?$AA@
	push	255					; 000000ffH
	push	OFFSET ?buf@?DN@???$atcprintf@HD@@YAIPAHIPBDPAUtagAMX@@00@Z@4PADA ; `atcprintf<int,char>'::`61'::buf
	call	?SafeSprintf@ke@@YAIPADIPBDZZ		; ke::SafeSprintf
	add	esp, 16					; 00000010H

; 704  : 					def = buf;

	mov	eax, OFFSET ?buf@?DN@???$atcprintf@HD@@YAIPAHIPBDPAUtagAMX@@00@Z@4PADA ; `atcprintf<int,char>'::`61'::buf
$LN46@atcprintf:

; 705  : 				}
; 706  : 				size_t written = atcprintf(buf_p, llen, def, amx, params, &arg);

	lea	ecx, DWORD PTR _arg$[esp+384]
	push	ecx
	push	DWORD PTR _params$GSCopy$1$[esp+388]
	push	esi
	mov	esi, DWORD PTR _buf_p$1$[esp+396]
	push	eax
	push	DWORD PTR _llen$1$[esp+400]
	push	esi
	call	??$atcprintf@HD@@YAIPAHIPBDPAUtagAMX@@00@Z ; atcprintf<int,char>

; 707  : 				buf_p += written;
; 708  : 				llen -= written;

	mov	edx, DWORD PTR _llen$1$[esp+408]
	add	esp, 24					; 00000018H

; 709  : 				break;

	mov	ecx, DWORD PTR _arg$[esp+384]
	sub	edx, eax
	mov	DWORD PTR _llen$[esp+384], edx
	lea	esi, DWORD PTR [esi+eax*4]
	mov	DWORD PTR _buf_p$[esp+384], esi
	jmp	$LN148@atcprintf
$LN47@atcprintf:

; 710  : 			}
; 711  : 		case 'N':
; 712  : 			{
; 713  : 				CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$2$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN106@atcprintf

; 714  : 				cell *addr = get_amxaddr(amx, params[arg]);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	add	esp, 8

; 715  : 				char buffer[255];
; 716  : 				if (*addr)

	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	$LN49@atcprintf

; 717  : 				{
; 718  : 					CPlayer *player = NULL;
; 719  : 
; 720  : 					if (*addr >= 1 && *addr <= gpGlobals->maxClients)

	cmp	edx, 1
	jl	$LN118@atcprintf
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	cmp	edx, DWORD PTR [ecx+148]
	jg	$LN118@atcprintf

; 721  : 					{
; 722  : 						player = GET_PLAYER_POINTER_I(*addr);

	imul	esi, edx, 564
	add	esi, OFFSET ?g_players@@3PAVCPlayer@@A	; g_players
	mov	DWORD PTR _player$1$[esp+384], esi

; 723  : 					}
; 724  : 
; 725  : 					if (!player || !player->initialized)

	je	$LN118@atcprintf
	cmp	BYTE PTR [esi+28], 0
	je	$LN118@atcprintf

; 728  : 						return 0;
; 729  : 					}
; 730  : 
; 731  : 					unsigned int auth = GETPLAYERAUTHID(player->pEdict); //DYLAN FIX GETPLAYERAUTHID(player->pEdict);

	push	DWORD PTR [esi]
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+476

; 732  : #if 0
; 733  : 					if (!auth || auth[0] == '\0')
; 734  : 					{
; 735  : 						auth = "STEAM_ID_PENDING";
; 736  : 					}
; 737  : #endif
; 738  : 
; 739  : 					int userid = GETPLAYERUSERID(player->pEdict);

	push	DWORD PTR [esi]
	mov	edi, eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+464
	mov	esi, eax
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 128  :     if (!chars_)

	mov	edx, OFFSET ??_C@_00CNPNBAHC@?$AA@
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 144  :       return !t_;

	mov	eax, DWORD PTR _player$1$[esp+392]
	mov	ecx, DWORD PTR [eax+20]
	test	ecx, ecx
	mov	eax, DWORD PTR [eax+4]
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 128  :     if (!chars_)

	cmovne	edx, ecx
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 144  :       return !t_;

	test	eax, eax
; File e:\nightfire_sdk\amx\amxmodx\format.cpp

; 740  : 					ke::SafeSprintf(buffer, sizeof(buffer), "%s<%d><%u><%s>", player->name.chars(), userid, auth, player->team.chars());

	push	edx
	push	edi
	push	esi
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 128  :     if (!chars_)

	mov	ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
	cmovne	ecx, eax
; File e:\nightfire_sdk\amx\amxmodx\format.cpp

; 740  : 					ke::SafeSprintf(buffer, sizeof(buffer), "%s<%d><%u><%s>", player->name.chars(), userid, auth, player->team.chars());

	lea	eax, DWORD PTR _buffer$2[esp+404]
	push	ecx
	push	OFFSET ??_C@_0P@JDPKEEME@?$CFs?$DM?$CFd?$DO?$DM?$CFu?$DO?$DM?$CFs?$DO?$AA@
	push	255					; 000000ffH
	push	eax
	call	?SafeSprintf@ke@@YAIPADIPBDZZ		; ke::SafeSprintf

; 741  : 				}
; 742  : 				else

	mov	esi, DWORD PTR _prec$1$[esp+420]
	add	esp, 36					; 00000024H
	mov	edi, DWORD PTR _width$1$[esp+384]
	jmp	SHORT $LN50@atcprintf
$LN49@atcprintf:

; 743  : 				{
; 744  : 					ke::SafeSprintf(buffer, sizeof(buffer), "Console<0><Console><Console>");

	push	OFFSET ??_C@_0BN@PONBEONJ@Console?$DM0?$DO?$DMConsole?$DO?$DMConsole?$DO?$AA@
	lea	eax, DWORD PTR _buffer$2[esp+388]
	push	255					; 000000ffH
	push	eax
	call	?SafeSprintf@ke@@YAIPADIPBDZZ		; ke::SafeSprintf
	add	esp, 12					; 0000000cH
$LN50@atcprintf:

; 745  : 				}
; 746  : 
; 747  : 				AddString(&buf_p, llen, buffer, width, prec);

	push	esi
	push	edi
	lea	eax, DWORD PTR _buffer$2[esp+392]
	push	eax
	lea	eax, DWORD PTR _llen$[esp+396]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+400]
	push	eax
	call	??$AddString@HD@@YAXPAPAHAAIPBDHH@Z	; AddString<int,char>
	mov	ecx, DWORD PTR _arg$[esp+404]
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _llen$[esp+384]
	inc	ecx
	mov	esi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN146@atcprintf
$LN54@atcprintf:

; 748  : 				arg++;
; 749  : 				break;
; 750  : 			}
; 751  : 		case 'n':
; 752  : 			{
; 753  : 				CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$2$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN106@atcprintf

; 754  : 				cell *addr = get_amxaddr(amx, params[arg]);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	edx, eax
	add	esp, 8
	mov	DWORD PTR _addr$1$[esp+384], edx

; 755  : 				const char *name = "Console";

	mov	ecx, OFFSET ??_C@_07PGLPGHFC@Console?$AA@

; 756  : 
; 757  : 				if (*addr)

	mov	edx, DWORD PTR [edx]
	test	edx, edx
	je	SHORT $LN89@atcprintf

; 758  : 				{
; 759  : 					CPlayer *player = NULL;
; 760  : 
; 761  : 					if (*addr >= 1 && *addr <= gpGlobals->maxClients)

	cmp	edx, 1
	jl	$LN120@atcprintf
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	cmp	edx, DWORD PTR [ecx+148]
	jg	$LN120@atcprintf

; 762  : 					{
; 763  : 						player = GET_PLAYER_POINTER_I(*addr);

	imul	eax, edx, 564
	add	eax, OFFSET ?g_players@@3PAVCPlayer@@A	; g_players

; 764  : 					}
; 765  : 
; 766  : 					if (!player || !player->initialized)

	je	$LN120@atcprintf
	cmp	BYTE PTR [eax+28], 0
	je	$LN120@atcprintf
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 144  :       return !t_;

	mov	eax, DWORD PTR [eax+4]
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 128  :     if (!chars_)

	mov	ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 144  :       return !t_;

	test	eax, eax
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 128  :     if (!chars_)

	cmovne	ecx, eax
$LN89@atcprintf:
; File e:\nightfire_sdk\amx\amxmodx\format.cpp

; 775  : 				AddString(&buf_p, llen, name, width, prec);

	push	esi
	push	edi
	push	ecx
	lea	eax, DWORD PTR _llen$[esp+396]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+400]
	push	eax
	call	??$AddString@HD@@YAXPAPAHAAIPBDHH@Z	; AddString<int,char>
	mov	ecx, DWORD PTR _arg$[esp+404]
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _llen$[esp+384]
	inc	ecx
	mov	esi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN146@atcprintf
$LN60@atcprintf:

; 776  : 				arg++;
; 777  : 				break;
; 778  : 			}
; 779  : 		case '%':
; 780  : 			*buf_p++ = static_cast<D>(ch);

	mov	esi, DWORD PTR _buf_p$1$[esp+384]
	mov	DWORD PTR [esi], 37			; 00000025H
	add	esi, 4

; 781  : 			if (!llen)
; 782  : 				goto done;
; 783  : 			llen--;
; 784  : 			break;

	mov	eax, DWORD PTR _arg$[esp+384]
	dec	edx
	mov	DWORD PTR _buf_p$[esp+384], esi
	mov	DWORD PTR _llen$[esp+384], edx
	mov	DWORD PTR _arg$2$[esp+384], eax
	jmp	$LN149@atcprintf
$LN67@atcprintf:

; 790  : 			goto done;
; 791  : 			break;
; 792  : 		default:
; 793  : 			*buf_p++ = static_cast<D>(ch);

	mov	esi, DWORD PTR _buf_p$1$[esp+384]
	mov	DWORD PTR [esi], ecx
	add	esi, 4

; 794  : 			if (!llen)
; 795  : 				goto done;
; 796  : 			llen--;
; 797  : 			break;
; 798  : 		}
; 799  : 	}

	mov	ecx, DWORD PTR _arg$[esp+384]
	dec	edx
	mov	DWORD PTR _buf_p$[esp+384], esi
	mov	DWORD PTR _llen$[esp+384], edx
	jmp	$LN148@atcprintf
$LN105@atcprintf:

; 622  : 		case 'c':
; 623  : 			CHECK_ARGS(0);

	push	edi
$LN150@atcprintf:
	push	eax
$LN152@atcprintf:
	push	OFFSET ??_C@_0DH@NEIDFOJI@String?5formatted?5incorrectly?5?9?5p@
	push	25					; 00000019H
	push	DWORD PTR _amx$GSCopy$1$[esp+400]
	call	_LogError
	add	esp, 20					; 00000014H
	xor	eax, eax

; 810  : 	}
; 811  : 
; 812  : 	return maxlen-llen;
; 813  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+372]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN106@atcprintf:

; 628  : 		case 'b':
; 629  : 			CHECK_ARGS(0);

	push	ecx
	jmp	SHORT $LN150@atcprintf
$LN113@atcprintf:

; 666  : 				{
; 667  : 					LogError(amx, AMX_ERR_NATIVE, "Invalid vector string handle provided (%d)", *get_amxaddr(amx, params[arg]));

	mov	eax, DWORD PTR _arg$[esp+384]
	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	mov	ebx, DWORD PTR _amx$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	ebx
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	push	DWORD PTR [eax]
	push	OFFSET ??_C@_0CL@GCKMCDNK@Invalid?5vector?5string?5handle?5pro@
	push	10					; 0000000aH
	push	ebx
	call	_LogError
	add	esp, 24					; 00000018H
	xor	eax, eax

; 810  : 	}
; 811  : 
; 812  : 	return maxlen-llen;
; 813  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+372]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN115@atcprintf:

; 686  : 				{
; 687  : 					CHECK_ARGS(1);

	push	edx
	push	ecx
	jmp	SHORT $LN152@atcprintf
$LN118@atcprintf:

; 726  : 					{
; 727  : 						LogError(amx, AMX_ERR_NATIVE, "Client index %d is invalid", *addr);

	push	edx
$LN153@atcprintf:
	push	OFFSET ??_C@_0BL@KOKBGDMJ@Client?5index?5?$CFd?5is?5invalid?$AA@
	push	10					; 0000000aH
	push	DWORD PTR _amx$GSCopy$1$[esp+396]
	call	_LogError
	add	esp, 16					; 00000010H
	xor	eax, eax

; 810  : 	}
; 811  : 
; 812  : 	return maxlen-llen;
; 813  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+372]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN120@atcprintf:

; 767  : 					{
; 768  : 						LogError(amx, AMX_ERR_NATIVE, "Client index %d is invalid", *addr);

	mov	eax, DWORD PTR _addr$1$[esp+384]
	push	DWORD PTR [eax]

; 769  : 						return 0;

	jmp	SHORT $LN153@atcprintf
$LN63@atcprintf:

; 785  : 		case '\0':
; 786  : 			*buf_p++ = static_cast<D>('%');

	mov	esi, DWORD PTR _buf_p$1$[esp+384]
	mov	DWORD PTR [esi], 37			; 00000025H
	add	esi, 4

; 787  : 			if (!llen)
; 788  : 				goto done;
; 789  : 			llen--;

	dec	edx
	mov	DWORD PTR _llen$1$[esp+384], edx
$done$156:

; 800  : 
; 801  : done:
; 802  : 	*buf_p = static_cast<D>(0);
; 803  : 	*param = arg;

	mov	ecx, DWORD PTR _param$GSCopy$1$[esp+384]
	mov	DWORD PTR [esi], 0
	mov	eax, DWORD PTR _arg$[esp+384]
	mov	DWORD PTR [ecx], eax

; 804  : 
; 805  : 	/* if max buffer length consumed, make sure we don't truncate a multi-byte character */
; 806  : 	if (llen <= 0 && *(buf_p - 1) & 1 << 7)

	test	edx, edx
	jne	SHORT $LN70@atcprintf
	test	BYTE PTR [esi-4], 128			; 00000080H
	lea	eax, DWORD PTR [esi-4]
	je	SHORT $LN70@atcprintf

; 807  : 	{
; 808  : 		llen += UTIL_CheckValidChar(buf_p - 1);

	push	eax
	call	??$UTIL_CheckValidChar@H@@YAHPAH@Z	; UTIL_CheckValidChar<int>
	mov	edx, DWORD PTR _llen$1$[esp+388]
	add	esp, 4
	add	edx, eax

; 809  : 		*(buf_p - llen) = static_cast<D>(0);

	lea	ecx, DWORD PTR [edx*4]
	sub	esi, ecx
	mov	DWORD PTR [esi], 0
$LN70@atcprintf:

; 810  : 	}
; 811  : 
; 812  : 	return maxlen-llen;
; 813  : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+384]
	mov	eax, DWORD PTR _maxlen$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	sub	eax, edx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN155@atcprintf:
	DD	$LN63@atcprintf
	DD	$LN60@atcprintf
	DD	$LN17@atcprintf
	DD	$LN18@atcprintf
	DD	$LN19@atcprintf
	DD	$LN20@atcprintf
	DD	$LN40@atcprintf
	DD	$LN47@atcprintf
	DD	$LN31@atcprintf
	DD	$LN35@atcprintf
	DD	$LN23@atcprintf
	DD	$LN21@atcprintf
	DD	$LN25@atcprintf
	DD	$LN29@atcprintf
	DD	$LN54@atcprintf
	DD	$LN38@atcprintf
	DD	$LN27@atcprintf
	DD	$LN33@atcprintf
	DD	$LN67@atcprintf
$LN138@atcprintf:
	DB	0
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	1
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	2
	DB	3
	DB	18					; 00000012H
	DB	4
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	6
	DB	18					; 00000012H
	DB	7
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	8
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	18					; 00000012H
	DB	13					; 0000000dH
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	12					; 0000000cH
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	6
	DB	18					; 00000012H
	DB	14					; 0000000eH
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	15					; 0000000fH
	DB	18					; 00000012H
	DB	16					; 00000010H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	17					; 00000011H
??$atcprintf@HD@@YAIPAHIPBDPAUtagAMX@@00@Z ENDP		; atcprintf<int,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
;	COMDAT ??$atcprintf@DH@@YAIPADIPBHPAUtagAMX@@PAH3@Z
_TEXT	SEGMENT
_arg$1$ = -316						; size = 4
_amx$GSCopy$1$ = -312					; size = 4
_buf_p$ = -308						; size = 4
_llen$ = -304						; size = 4
_buf_p$1$ = -300					; size = 4
_llen$1$ = -296						; size = 4
_params$GSCopy$1$ = -292				; size = 4
_player$1$ = -288					; size = 4
_flags$1$ = -288					; size = 4
_arg$ = -288						; size = 4
_args$1$ = -284						; size = 4
_addr$1$ = -280						; size = 4
_width$1$ = -280					; size = 4
_prec$1$ = -276						; size = 4
_len$1 = -272						; size = 4
_param$GSCopy$1$ = -268					; size = 4
_buffer$2 = -264					; size = 255
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_maxlen$ = 12						; size = 4
_format$ = 16						; size = 4
_amx$ = 20						; size = 4
_params$ = 24						; size = 4
_param$ = 28						; size = 4
??$atcprintf@DH@@YAIPADIPBHPAUtagAMX@@PAH3@Z PROC	; atcprintf<char,int>, COMDAT

; 550  : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 372				; 00000174H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+372], eax
	mov	eax, DWORD PTR _amx$[ebp]
	mov	ecx, DWORD PTR _param$[ebp]
	mov	DWORD PTR _amx$GSCopy$1$[esp+372], eax
	mov	eax, DWORD PTR _params$[ebp]
	push	ebx

; 562  : 
; 563  : 	buf_p = buffer;
; 564  : 	arg = *param;
; 565  : 	fmt = format;

	mov	ebx, DWORD PTR _format$[ebp]
	mov	DWORD PTR _params$GSCopy$1$[esp+376], eax
	mov	eax, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _maxlen$[ebp]
	mov	DWORD PTR _param$GSCopy$1$[esp+380], ecx
	mov	ecx, DWORD PTR [ecx]
	shr	eax, 2
	push	edi
	mov	edi, DWORD PTR _buffer$[ebp]
	mov	DWORD PTR _args$1$[esp+384], eax
	mov	DWORD PTR _arg$1$[esp+384], ecx
$LN141@atcprintf:

; 551  : 	int		arg;
; 552  : 	int		args = params[0] / sizeof(cell);
; 553  : 	D		*buf_p;
; 554  : 	D		ch;
; 555  : 	int		flags;
; 556  : 	int		width;
; 557  : 	int		prec;
; 558  : 	int		n;
; 559  : 	//char	sign;
; 560  : 	const S	*fmt;
; 561  : 	size_t	llen = maxlen;

	mov	DWORD PTR _buf_p$[esp+384], edi
	mov	DWORD PTR _llen$[esp+384], esi
$LN145@atcprintf:

; 566  : 
; 567  : 	while (true)
; 568  : 	{
; 569  : 		// run through the format string until we hit a '%' or '\0'
; 570  : 		for (ch = static_cast<D>(*fmt); 

	mov	al, BYTE PTR [ebx]
	mov	DWORD PTR _buf_p$1$[esp+384], edi
	mov	DWORD PTR _llen$1$[esp+384], esi

; 571  : 			llen && ((ch = static_cast<D>(*fmt)) != '\0' && ch != '%');

	test	esi, esi
	je	SHORT $LN5@atcprintf
$LL6@atcprintf:
	mov	al, BYTE PTR [ebx]
	test	al, al
	je	$done$149
	cmp	al, 37					; 00000025H
	je	SHORT $LN5@atcprintf

; 573  : 		{
; 574  : 			*buf_p++ = static_cast<D>(ch);
; 575  : 			llen--;

	dec	esi
	mov	BYTE PTR [edi], al
	inc	edi
	mov	DWORD PTR _llen$1$[esp+384], esi
	add	ebx, 4
	mov	DWORD PTR _buf_p$1$[esp+384], edi
	mov	DWORD PTR _buf_p$[esp+384], edi
	mov	DWORD PTR _llen$[esp+384], esi
	test	esi, esi
	jne	SHORT $LL6@atcprintf
$LN5@atcprintf:

; 576  : 		}
; 577  : 		if (ch == '\0' || llen <= 0)

	test	al, al
	je	$done$149
	test	esi, esi
	je	$done$149

; 578  : 			goto done;
; 579  : 
; 580  : 		// skip over the '%'
; 581  : 		fmt++;
; 582  : 
; 583  : 		// reset formatting state
; 584  : 		flags = 0;

	xor	ecx, ecx

; 585  : 		width = 0;

	xor	edi, edi
	add	ebx, 4
	mov	DWORD PTR _flags$1$[esp+384], ecx

; 586  : 		prec = -1;

	or	esi, -1
	mov	DWORD PTR _width$1$[esp+384], edi
	mov	DWORD PTR _prec$1$[esp+384], esi
	npad	1
$rflag$150:

; 587  : 		//sign = '\0';
; 588  : 
; 589  : rflag:
; 590  : 		ch = static_cast<D>(*fmt++);

	mov	dl, BYTE PTR [ebx]
	add	ebx, 4
	movsx	ecx, dl
	npad	8
$reswitch$151:

; 591  : reswitch:
; 592  : 		switch(ch)

	cmp	ecx, 120				; 00000078H
	ja	$LN67@atcprintf
	movzx	eax, BYTE PTR $LN138@atcprintf[ecx]
	jmp	DWORD PTR $LN148@atcprintf[eax*4]
$LN18@atcprintf:

; 597  : 		case '.':
; 598  : 			n = 0;
; 599  : 			while( is_digit( ( ch = static_cast<D>(*fmt++)) ) )

	mov	dl, BYTE PTR [ebx]
	xor	esi, esi
	movsx	ecx, dl
	lea	eax, DWORD PTR [ecx-48]
	cmp	eax, 9
	ja	SHORT $LN124@atcprintf
$LL9@atcprintf:
	mov	dl, BYTE PTR [ebx+4]

; 600  : 				n = 10 * n + ( ch - '0' );

	lea	eax, DWORD PTR [esi-6]
	add	ebx, 4
	lea	eax, DWORD PTR [esi+eax*4]
	lea	esi, DWORD PTR [ecx+eax*2]
	movsx	ecx, dl
	lea	eax, DWORD PTR [ecx-48]
	cmp	eax, 9
	jbe	SHORT $LL9@atcprintf
$LN124@atcprintf:

; 597  : 		case '.':
; 598  : 			n = 0;
; 599  : 			while( is_digit( ( ch = static_cast<D>(*fmt++)) ) )

	add	ebx, 4

; 601  : 			prec = n < 0 ? -1 : n;

	mov	eax, -1
	test	esi, esi
	cmovs	esi, eax
	mov	DWORD PTR _prec$1$[esp+384], esi

; 602  : 			goto reswitch;

	jmp	SHORT $reswitch$151
$LN20@atcprintf:

; 605  : 			goto rflag;
; 606  : 		case '1':
; 607  : 		case '2':
; 608  : 		case '3':
; 609  : 		case '4':
; 610  : 		case '5':
; 611  : 		case '6':
; 612  : 		case '7':
; 613  : 		case '8':
; 614  : 		case '9':
; 615  : 			n = 0;

	xor	edi, edi
$LL13@atcprintf:

; 616  : 			do {
; 617  : 				n = 10 * n + ( ch - '0' );
; 618  : 				ch = static_cast<D>(*fmt++);

	mov	dl, BYTE PTR [ebx]
	lea	eax, DWORD PTR [edi-6]
	lea	eax, DWORD PTR [edi+eax*4]
	add	ebx, 4
	lea	edi, DWORD PTR [ecx+eax*2]

; 619  : 			} while( is_digit( ch ) );

	movsx	ecx, dl
	lea	eax, DWORD PTR [ecx-48]
	cmp	eax, 9
	jbe	SHORT $LL13@atcprintf
	mov	DWORD PTR _width$1$[esp+384], edi

; 620  : 			width = n;
; 621  : 			goto reswitch;

	jmp	SHORT $reswitch$151
$LN17@atcprintf:

; 593  : 		{
; 594  : 		case '-':
; 595  : 			flags |= LADJUST;

	or	DWORD PTR _flags$1$[esp+384], 4

; 596  : 			goto rflag;

	jmp	$rflag$150
$LN19@atcprintf:

; 603  : 		case '0':
; 604  : 			flags |= ZEROPAD;

	or	DWORD PTR _flags$1$[esp+384], 128	; 00000080H

; 572  : 			fmt++)

	jmp	$rflag$150
$LN21@atcprintf:

; 622  : 		case 'c':
; 623  : 			CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$1$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN105@atcprintf

; 624  : 			*buf_p++ = static_cast<D>(*get_amxaddr(amx, params[arg]));

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	edi, DWORD PTR _buf_p$1$[esp+392]
	add	esp, 8

; 625  : 			llen--;

	mov	esi, DWORD PTR _llen$1$[esp+384]
	dec	esi
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [edi], al
	inc	edi

; 626  : 			arg++;

	inc	DWORD PTR _arg$1$[esp+384]

; 627  : 			break;

	jmp	$LN141@atcprintf
$LN23@atcprintf:

; 628  : 		case 'b':
; 629  : 			CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$1$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN105@atcprintf

; 630  : 			AddBinary(&buf_p, llen, *get_amxaddr(amx, params[arg]), width, flags);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	ecx, DWORD PTR _flags$1$[esp+392]
	push	ecx
	push	edi
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR _llen$[esp+404]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+408]
	push	eax
	call	??$AddBinary@D@@YAXPAPADAAIIHH@Z	; AddBinary<char>

; 631  : 			arg++;
; 632  : 			break;

	mov	esi, DWORD PTR _llen$[esp+412]
	add	esp, 28					; 0000001cH
	inc	DWORD PTR _arg$1$[esp+384]
	mov	edi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN145@atcprintf
$LN25@atcprintf:

; 633  : 		case 'd':
; 634  : 		case 'i':
; 635  : 			CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$1$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN105@atcprintf

; 636  : 			AddInt(&buf_p, llen, *get_amxaddr(amx, params[arg]), width, flags);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	ecx, DWORD PTR _flags$1$[esp+392]
	push	ecx
	push	edi
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR _llen$[esp+404]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+408]
	push	eax
	call	??$AddInt@D@@YAXPAPADAAIHHH@Z		; AddInt<char>
	mov	esi, DWORD PTR _llen$[esp+412]
	add	esp, 28					; 0000001cH
	inc	DWORD PTR _arg$1$[esp+384]
	mov	edi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN145@atcprintf
$LN27@atcprintf:

; 637  : 			arg++;
; 638  : 			break;
; 639  : 		case 'u':
; 640  : 			CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$1$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN105@atcprintf

; 641  : 			AddUInt(&buf_p, llen, static_cast<unsigned int>(*get_amxaddr(amx, params[arg])), width, flags);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	ecx, DWORD PTR _flags$1$[esp+392]
	push	ecx
	push	edi
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR _llen$[esp+404]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+408]
	push	eax
	call	??$AddUInt@D@@YAXPAPADAAIIHH@Z		; AddUInt<char>
	mov	esi, DWORD PTR _llen$[esp+412]
	add	esp, 28					; 0000001cH
	inc	DWORD PTR _arg$1$[esp+384]
	mov	edi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN145@atcprintf
$LN29@atcprintf:

; 642  : 			arg++;
; 643  : 			break;
; 644  : 		case 'f':
; 645  : 			CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$1$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN105@atcprintf

; 646  : 			AddFloat(&buf_p, llen, amx_ctof(*get_amxaddr(amx, params[arg])), width, prec, flags);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	ecx, DWORD PTR _flags$1$[esp+392]
	add	esp, 8
	movss	xmm0, DWORD PTR [eax]
	lea	eax, DWORD PTR _llen$[esp+384]
	push	ecx
	push	esi
	push	edi
	cvtps2pd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+408]
	push	eax
	call	??$AddFloat@D@@YAXPAPADAAINHHH@Z	; AddFloat<char>
	mov	esi, DWORD PTR _llen$[esp+412]
	add	esp, 28					; 0000001cH
	inc	DWORD PTR _arg$1$[esp+384]
	mov	edi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN145@atcprintf
$LN31@atcprintf:

; 647  : 			arg++;
; 648  : 			break;
; 649  : 		case 'X':
; 650  : 			CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$1$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN105@atcprintf

; 651  : 			flags |= UPPERDIGITS;
; 652  : 			AddHex(&buf_p, llen, static_cast<unsigned int>(*get_amxaddr(amx, params[arg])), width, flags);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	ecx, DWORD PTR _flags$1$[esp+392]
	or	ecx, 512				; 00000200H
$LN142@atcprintf:
	push	ecx
	push	edi
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR _llen$[esp+404]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+408]
	push	eax
	call	??$AddHex@D@@YAXPAPADAAIIHH@Z		; AddHex<char>
	mov	esi, DWORD PTR _llen$[esp+412]
	add	esp, 28					; 0000001cH
	inc	DWORD PTR _arg$1$[esp+384]
	mov	edi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN145@atcprintf
$LN33@atcprintf:

; 653  : 			arg++;
; 654  : 			break;
; 655  : 		case 'x':
; 656  : 			CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$1$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN105@atcprintf

; 657  : 			AddHex(&buf_p, llen, static_cast<unsigned int>(*get_amxaddr(amx, params[arg])), width, flags);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	ecx, DWORD PTR _flags$1$[esp+392]

; 658  : 			arg++;
; 659  : 			break;

	jmp	SHORT $LN142@atcprintf
$LN35@atcprintf:

; 660  : 		case 'a':
; 661  : 			{
; 662  : 				CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$1$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN105@atcprintf

; 663  : 				// %a is passed a pointer directly to a cell string.
; 664  : 				cell* ptr=reinterpret_cast<cell*>(*get_amxaddr(amx, params[arg]));

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 665  : 				if (!ptr)

	test	eax, eax
	je	$LN113@atcprintf

; 669  : 				}
; 670  : 
; 671  : 				AddString(&buf_p, llen, ptr, width, prec);

	push	esi
	push	edi
$LN143@atcprintf:
	push	eax
	lea	eax, DWORD PTR _llen$[esp+396]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+400]
	push	eax
	call	??$AddString@DH@@YAXPAPADAAIPBHHH@Z	; AddString<char,int>
	mov	esi, DWORD PTR _llen$[esp+404]
	add	esp, 20					; 00000014H
	inc	DWORD PTR _arg$1$[esp+384]
	mov	edi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN145@atcprintf
$LN38@atcprintf:

; 672  : 				arg++;
; 673  : 				break;
; 674  : 			}
; 675  : 		case 's':
; 676  : 			CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$1$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN105@atcprintf

; 677  : 			AddString(&buf_p, llen, get_amxaddr(amx, params[arg]), width, prec);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	esi
	push	edi
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+396]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	add	esp, 8

; 678  : 			arg++;
; 679  : 			break;

	jmp	SHORT $LN143@atcprintf
$LN40@atcprintf:

; 680  : 		case 'L':
; 681  : 		case 'l':
; 682  : 			{
; 683  : 				const char *lang;
; 684  : 				int len;
; 685  : 				if (ch == 'L')

	cmp	dl, 76					; 0000004cH
	jne	SHORT $LN41@atcprintf

; 686  : 				{
; 687  : 					CHECK_ARGS(1);

	mov	ecx, DWORD PTR _arg$1$[esp+384]
	mov	edx, DWORD PTR _args$1$[esp+384]
	lea	eax, DWORD PTR [ecx+1]
	cmp	eax, edx
	jg	$LN115@atcprintf

; 688  : 					auto currParam = params[arg++];

	mov	edi, DWORD PTR _params$GSCopy$1$[esp+384]
	mov	DWORD PTR _arg$1$[esp+384], eax
	mov	edi, DWORD PTR [edi+ecx*4]

; 689  : 					lang = playerlang(*get_amxaddr(amx, currParam));

	push	edi
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	push	DWORD PTR [eax]
	call	?playerlang@@YAPBDH@Z			; playerlang
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 690  : 					if (!lang)

	test	esi, esi
	jne	SHORT $LN42@atcprintf

; 691  : 						lang = get_amxstring(amx, currParam, 2, len);

	lea	eax, DWORD PTR _len$1[esp+384]
	push	eax
	push	2
	push	edi
	push	DWORD PTR _amx$GSCopy$1$[esp+396]
	call	?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z	; get_amxstring
	add	esp, 16					; 00000010H

; 692  : 				}
; 693  : 				else

	jmp	SHORT $LN146@atcprintf
$LN41@atcprintf:

; 694  : 				{
; 695  : 					CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$1$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN105@atcprintf

; 696  : 					lang = playerlang(g_langMngr.GetDefLang());

	push	DWORD PTR ?g_langMngr@@3VCLangMngr@@A+68
	call	?playerlang@@YAPBDH@Z			; playerlang
	add	esp, 4
$LN146@atcprintf:
	mov	esi, eax
$LN42@atcprintf:

; 697  : 				}
; 698  : 				const char *key = get_amxstring(amx, params[arg++], 3, len);

	mov	ecx, DWORD PTR _arg$1$[esp+384]
	mov	eax, DWORD PTR _params$GSCopy$1$[esp+384]
	mov	eax, DWORD PTR [eax+ecx*4]
	inc	ecx
	mov	DWORD PTR _arg$[esp+384], ecx
	lea	ecx, DWORD PTR _len$1[esp+384]
	push	ecx
	push	3
	push	eax
	push	DWORD PTR _amx$GSCopy$1$[esp+396]
	call	?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z	; get_amxstring
	mov	edi, eax

; 699  : 				const char *def = translate(amx, lang, key);

	push	edi
	push	esi
	mov	esi, DWORD PTR _amx$GSCopy$1$[esp+408]
	push	esi
	call	?translate@@YAPBDPAUtagAMX@@PBD1@Z	; translate
	add	esp, 28					; 0000001cH

; 700  : 				if (!def)

	test	eax, eax
	jne	SHORT $LN46@atcprintf

; 701  : 				{
; 702  : 					static char buf[255];
; 703  : 					ke::SafeSprintf(buf, sizeof(buf), "ML_NOTFOUND: %s", key);

	push	edi
	push	OFFSET ??_C@_0BA@HJJJBHCN@ML_NOTFOUND?3?5?$CFs?$AA@
	push	255					; 000000ffH
	push	OFFSET ?buf@?DN@???$atcprintf@DH@@YAIPADIPBHPAUtagAMX@@PAH3@Z@4PADA ; `atcprintf<char,int>'::`61'::buf
	call	?SafeSprintf@ke@@YAIPADIPBDZZ		; ke::SafeSprintf
	add	esp, 16					; 00000010H

; 704  : 					def = buf;

	mov	eax, OFFSET ?buf@?DN@???$atcprintf@DH@@YAIPADIPBHPAUtagAMX@@PAH3@Z@4PADA ; `atcprintf<char,int>'::`61'::buf
$LN46@atcprintf:

; 705  : 				}
; 706  : 				size_t written = atcprintf(buf_p, llen, def, amx, params, &arg);

	mov	edi, DWORD PTR _buf_p$1$[esp+384]
	lea	ecx, DWORD PTR _arg$[esp+384]
	push	ecx
	push	DWORD PTR _params$GSCopy$1$[esp+388]
	push	esi
	mov	esi, DWORD PTR _llen$1$[esp+396]
	push	eax
	push	esi
	push	edi
	call	??$atcprintf@DD@@YAIPADIPBDPAUtagAMX@@PAH3@Z ; atcprintf<char,char>

; 707  : 				buf_p += written;

	add	edi, eax
	add	esp, 24					; 00000018H

; 708  : 				llen -= written;

	sub	esi, eax

; 709  : 				break;

	mov	eax, DWORD PTR _arg$[esp+384]
	mov	DWORD PTR _arg$1$[esp+384], eax
	jmp	$LN141@atcprintf
$LN47@atcprintf:

; 710  : 			}
; 711  : 		case 'N':
; 712  : 			{
; 713  : 				CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$1$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN105@atcprintf

; 714  : 				cell *addr = get_amxaddr(amx, params[arg]);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	add	esp, 8

; 715  : 				char buffer[255];
; 716  : 				if (*addr)

	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	$LN49@atcprintf

; 717  : 				{
; 718  : 					CPlayer *player = NULL;
; 719  : 
; 720  : 					if (*addr >= 1 && *addr <= gpGlobals->maxClients)

	cmp	edx, 1
	jl	$LN118@atcprintf
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	cmp	edx, DWORD PTR [ecx+148]
	jg	$LN118@atcprintf

; 721  : 					{
; 722  : 						player = GET_PLAYER_POINTER_I(*addr);

	imul	esi, edx, 564
	add	esi, OFFSET ?g_players@@3PAVCPlayer@@A	; g_players
	mov	DWORD PTR _player$1$[esp+384], esi

; 723  : 					}
; 724  : 
; 725  : 					if (!player || !player->initialized)

	je	$LN118@atcprintf
	cmp	BYTE PTR [esi+28], 0
	je	$LN118@atcprintf

; 729  : 					}
; 730  : 
; 731  : 					unsigned int auth = GETPLAYERAUTHID(player->pEdict); //DYLAN FIX GETPLAYERAUTHID(player->pEdict);

	push	DWORD PTR [esi]
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+476

; 732  : #if 0
; 733  : 					if (!auth || auth[0] == '\0')
; 734  : 					{
; 735  : 						auth = "STEAM_ID_PENDING";
; 736  : 					}
; 737  : #endif
; 738  : 
; 739  : 					int userid = GETPLAYERUSERID(player->pEdict);

	push	DWORD PTR [esi]
	mov	edi, eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+464
	mov	esi, eax
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 128  :     if (!chars_)

	mov	edx, OFFSET ??_C@_00CNPNBAHC@?$AA@
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 144  :       return !t_;

	mov	eax, DWORD PTR _player$1$[esp+392]
	mov	ecx, DWORD PTR [eax+20]
	test	ecx, ecx
	mov	eax, DWORD PTR [eax+4]
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 128  :     if (!chars_)

	cmovne	edx, ecx
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 144  :       return !t_;

	test	eax, eax
; File e:\nightfire_sdk\amx\amxmodx\format.cpp

; 740  : 					ke::SafeSprintf(buffer, sizeof(buffer), "%s<%d><%u><%s>", player->name.chars(), userid, auth, player->team.chars());

	push	edx
	push	edi
	push	esi
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 128  :     if (!chars_)

	mov	ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
	cmovne	ecx, eax
; File e:\nightfire_sdk\amx\amxmodx\format.cpp

; 740  : 					ke::SafeSprintf(buffer, sizeof(buffer), "%s<%d><%u><%s>", player->name.chars(), userid, auth, player->team.chars());

	lea	eax, DWORD PTR _buffer$2[esp+404]
	push	ecx
	push	OFFSET ??_C@_0P@JDPKEEME@?$CFs?$DM?$CFd?$DO?$DM?$CFu?$DO?$DM?$CFs?$DO?$AA@
	push	255					; 000000ffH
	push	eax
	call	?SafeSprintf@ke@@YAIPADIPBDZZ		; ke::SafeSprintf

; 741  : 				}
; 742  : 				else

	mov	esi, DWORD PTR _prec$1$[esp+420]
	add	esp, 36					; 00000024H
	mov	edi, DWORD PTR _width$1$[esp+384]
	jmp	SHORT $LN50@atcprintf
$LN49@atcprintf:

; 743  : 				{
; 744  : 					ke::SafeSprintf(buffer, sizeof(buffer), "Console<0><Console><Console>");

	push	OFFSET ??_C@_0BN@PONBEONJ@Console?$DM0?$DO?$DMConsole?$DO?$DMConsole?$DO?$AA@
	lea	eax, DWORD PTR _buffer$2[esp+388]
	push	255					; 000000ffH
	push	eax
	call	?SafeSprintf@ke@@YAIPADIPBDZZ		; ke::SafeSprintf
	add	esp, 12					; 0000000cH
$LN50@atcprintf:

; 745  : 				}
; 746  : 
; 747  : 				AddString(&buf_p, llen, buffer, width, prec);

	push	esi
	push	edi
	lea	eax, DWORD PTR _buffer$2[esp+392]
	push	eax
	lea	eax, DWORD PTR _llen$[esp+396]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+400]
	push	eax
	call	??$AddString@DD@@YAXPAPADAAIPBDHH@Z	; AddString<char,char>
	mov	esi, DWORD PTR _llen$[esp+404]
	add	esp, 20					; 00000014H
	inc	DWORD PTR _arg$1$[esp+384]
	mov	edi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN145@atcprintf
$LN54@atcprintf:

; 748  : 				arg++;
; 749  : 				break;
; 750  : 			}
; 751  : 		case 'n':
; 752  : 			{
; 753  : 				CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$1$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN105@atcprintf

; 754  : 				cell *addr = get_amxaddr(amx, params[arg]);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	edx, eax
	add	esp, 8
	mov	DWORD PTR _addr$1$[esp+384], edx

; 755  : 				const char *name = "Console";

	mov	ecx, OFFSET ??_C@_07PGLPGHFC@Console?$AA@

; 756  : 
; 757  : 				if (*addr)

	mov	edx, DWORD PTR [edx]
	test	edx, edx
	je	SHORT $LN89@atcprintf

; 758  : 				{
; 759  : 					CPlayer *player = NULL;
; 760  : 
; 761  : 					if (*addr >= 1 && *addr <= gpGlobals->maxClients)

	cmp	edx, 1
	jl	$LN120@atcprintf
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	cmp	edx, DWORD PTR [ecx+148]
	jg	$LN120@atcprintf

; 762  : 					{
; 763  : 						player = GET_PLAYER_POINTER_I(*addr);

	imul	eax, edx, 564
	add	eax, OFFSET ?g_players@@3PAVCPlayer@@A	; g_players

; 764  : 					}
; 765  : 
; 766  : 					if (!player || !player->initialized)

	je	$LN120@atcprintf
	cmp	BYTE PTR [eax+28], 0
	je	$LN120@atcprintf
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 144  :       return !t_;

	mov	eax, DWORD PTR [eax+4]
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 128  :     if (!chars_)

	mov	ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 144  :       return !t_;

	test	eax, eax
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 128  :     if (!chars_)

	cmovne	ecx, eax
$LN89@atcprintf:
; File e:\nightfire_sdk\amx\amxmodx\format.cpp

; 775  : 				AddString(&buf_p, llen, name, width, prec);

	push	esi
	push	edi
	push	ecx
	lea	eax, DWORD PTR _llen$[esp+396]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+400]
	push	eax
	call	??$AddString@DD@@YAXPAPADAAIPBDHH@Z	; AddString<char,char>
	mov	esi, DWORD PTR _llen$[esp+404]
	add	esp, 20					; 00000014H
	inc	DWORD PTR _arg$1$[esp+384]
	mov	edi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN145@atcprintf
$LN67@atcprintf:

; 790  : 			goto done;
; 791  : 			break;
; 792  : 		default:
; 793  : 			*buf_p++ = static_cast<D>(ch);

	mov	edi, DWORD PTR _buf_p$1$[esp+384]

; 794  : 			if (!llen)
; 795  : 				goto done;
; 796  : 			llen--;

	mov	esi, DWORD PTR _llen$1$[esp+384]
	mov	BYTE PTR [edi], dl
	inc	edi
	dec	esi

; 797  : 			break;
; 798  : 		}
; 799  : 	}

	jmp	$LN141@atcprintf
$LN105@atcprintf:

; 622  : 		case 'c':
; 623  : 			CHECK_ARGS(0);

	push	ecx
	push	eax
	push	OFFSET ??_C@_0DH@NEIDFOJI@String?5formatted?5incorrectly?5?9?5p@
	push	25					; 00000019H
	push	DWORD PTR _amx$GSCopy$1$[esp+400]
	call	_LogError
	add	esp, 20					; 00000014H
	xor	eax, eax

; 813  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+372]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN113@atcprintf:

; 666  : 				{
; 667  : 					LogError(amx, AMX_ERR_NATIVE, "Invalid vector string handle provided (%d)", *get_amxaddr(amx, params[arg]));

	mov	eax, DWORD PTR _arg$1$[esp+384]
	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	mov	ebx, DWORD PTR _amx$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	ebx
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	push	DWORD PTR [eax]
	push	OFFSET ??_C@_0CL@GCKMCDNK@Invalid?5vector?5string?5handle?5pro@
	push	10					; 0000000aH
	push	ebx
	call	_LogError
	add	esp, 24					; 00000018H

; 668  : 					return 0;

	xor	eax, eax

; 813  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+372]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN115@atcprintf:

; 686  : 				{
; 687  : 					CHECK_ARGS(1);

	push	edx
	push	ecx
	push	OFFSET ??_C@_0DH@NEIDFOJI@String?5formatted?5incorrectly?5?9?5p@
	push	25					; 00000019H
	push	DWORD PTR _amx$GSCopy$1$[esp+400]
	call	_LogError
	add	esp, 20					; 00000014H
	xor	eax, eax

; 813  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+372]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN118@atcprintf:

; 726  : 					{
; 727  : 						LogError(amx, AMX_ERR_NATIVE, "Client index %d is invalid", *addr);

	push	edx
	push	OFFSET ??_C@_0BL@KOKBGDMJ@Client?5index?5?$CFd?5is?5invalid?$AA@
	push	10					; 0000000aH
	push	DWORD PTR _amx$GSCopy$1$[esp+396]
	call	_LogError
	add	esp, 16					; 00000010H

; 728  : 						return 0;

	xor	eax, eax

; 813  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+372]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN120@atcprintf:

; 767  : 					{
; 768  : 						LogError(amx, AMX_ERR_NATIVE, "Client index %d is invalid", *addr);

	mov	eax, DWORD PTR _addr$1$[esp+384]
	push	DWORD PTR [eax]
	push	OFFSET ??_C@_0BL@KOKBGDMJ@Client?5index?5?$CFd?5is?5invalid?$AA@
	push	10					; 0000000aH
	push	DWORD PTR _amx$GSCopy$1$[esp+396]
	call	_LogError
	add	esp, 16					; 00000010H

; 769  : 						return 0;

	xor	eax, eax

; 813  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+372]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN63@atcprintf:

; 776  : 				arg++;
; 777  : 				break;
; 778  : 			}
; 779  : 		case '%':
; 780  : 			*buf_p++ = static_cast<D>(ch);
; 781  : 			if (!llen)
; 782  : 				goto done;
; 783  : 			llen--;
; 784  : 			break;
; 785  : 		case '\0':
; 786  : 			*buf_p++ = static_cast<D>('%');

	mov	edi, DWORD PTR _buf_p$1$[esp+384]

; 787  : 			if (!llen)
; 788  : 				goto done;
; 789  : 			llen--;

	mov	esi, DWORD PTR _llen$1$[esp+384]
	mov	BYTE PTR [edi], 37			; 00000025H
	inc	edi
	dec	esi
$done$149:

; 800  : 
; 801  : done:
; 802  : 	*buf_p = static_cast<D>(0);
; 803  : 	*param = arg;

	mov	ecx, DWORD PTR _param$GSCopy$1$[esp+384]
	mov	eax, DWORD PTR _arg$1$[esp+384]
	mov	BYTE PTR [edi], 0
	mov	DWORD PTR [ecx], eax

; 804  : 
; 805  : 	/* if max buffer length consumed, make sure we don't truncate a multi-byte character */
; 806  : 	if (llen <= 0 && *(buf_p - 1) & 1 << 7)

	test	esi, esi
	jne	SHORT $LN70@atcprintf
	cmp	BYTE PTR [edi-1], 0
	lea	eax, DWORD PTR [edi-1]
	jge	SHORT $LN70@atcprintf

; 807  : 	{
; 808  : 		llen += UTIL_CheckValidChar(buf_p - 1);

	push	eax
	call	??$UTIL_CheckValidChar@D@@YAHPAD@Z	; UTIL_CheckValidChar<char>
	mov	esi, eax
	add	esp, 4

; 809  : 		*(buf_p - llen) = static_cast<D>(0);

	sub	edi, esi
	mov	BYTE PTR [edi], 0
$LN70@atcprintf:

; 810  : 	}
; 811  : 
; 812  : 	return maxlen-llen;

	mov	eax, DWORD PTR _maxlen$[ebp]

; 813  : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+384]
	sub	eax, esi
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN148@atcprintf:
	DD	$LN63@atcprintf
	DD	$LN67@atcprintf
	DD	$LN17@atcprintf
	DD	$LN18@atcprintf
	DD	$LN19@atcprintf
	DD	$LN20@atcprintf
	DD	$LN40@atcprintf
	DD	$LN47@atcprintf
	DD	$LN31@atcprintf
	DD	$LN35@atcprintf
	DD	$LN23@atcprintf
	DD	$LN21@atcprintf
	DD	$LN25@atcprintf
	DD	$LN29@atcprintf
	DD	$LN54@atcprintf
	DD	$LN38@atcprintf
	DD	$LN27@atcprintf
	DD	$LN33@atcprintf
	DD	$LN67@atcprintf
$LN138@atcprintf:
	DB	0
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	1
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	2
	DB	3
	DB	18					; 00000012H
	DB	4
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	6
	DB	18					; 00000012H
	DB	7
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	8
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	18					; 00000012H
	DB	13					; 0000000dH
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	12					; 0000000cH
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	6
	DB	18					; 00000012H
	DB	14					; 0000000eH
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	15					; 0000000fH
	DB	18					; 00000012H
	DB	16					; 00000010H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	17					; 00000011H
??$atcprintf@DH@@YAIPADIPBHPAUtagAMX@@PAH3@Z ENDP	; atcprintf<char,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
;	COMDAT ??$atcprintf@HH@@YAIPAHIPBHPAUtagAMX@@00@Z
_TEXT	SEGMENT
_arg$1$ = -316						; size = 4
_amx$GSCopy$1$ = -312					; size = 4
_buf_p$ = -308						; size = 4
_llen$ = -304						; size = 4
_buf_p$1$ = -300					; size = 4
_llen$1$ = -296						; size = 4
_params$GSCopy$1$ = -292				; size = 4
_player$1$ = -288					; size = 4
_flags$1$ = -288					; size = 4
_arg$ = -288						; size = 4
_args$1$ = -284						; size = 4
_addr$1$ = -280						; size = 4
_width$1$ = -280					; size = 4
_prec$1$ = -276						; size = 4
_len$1 = -272						; size = 4
_param$GSCopy$1$ = -268					; size = 4
_buffer$2 = -264					; size = 255
__$ArrayPad$ = -4					; size = 4
_buffer$ = 8						; size = 4
_maxlen$ = 12						; size = 4
_format$ = 16						; size = 4
_amx$ = 20						; size = 4
_params$ = 24						; size = 4
_param$ = 28						; size = 4
??$atcprintf@HH@@YAIPAHIPBHPAUtagAMX@@00@Z PROC		; atcprintf<int,int>, COMDAT

; 550  : {

	push	ebp
	mov	ebp, esp
	and	esp, -64				; ffffffc0H
	sub	esp, 372				; 00000174H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+372], eax
	mov	eax, DWORD PTR _amx$[ebp]
	mov	ecx, DWORD PTR _param$[ebp]

; 551  : 	int		arg;
; 552  : 	int		args = params[0] / sizeof(cell);
; 553  : 	D		*buf_p;
; 554  : 	D		ch;
; 555  : 	int		flags;
; 556  : 	int		width;
; 557  : 	int		prec;
; 558  : 	int		n;
; 559  : 	//char	sign;
; 560  : 	const S	*fmt;
; 561  : 	size_t	llen = maxlen;

	mov	edx, DWORD PTR _maxlen$[ebp]
	mov	DWORD PTR _amx$GSCopy$1$[esp+372], eax
	mov	eax, DWORD PTR _params$[ebp]
	push	ebx

; 565  : 	fmt = format;

	mov	ebx, DWORD PTR _format$[ebp]
	mov	DWORD PTR _params$GSCopy$1$[esp+376], eax
	mov	eax, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR _buffer$[ebp]
	shr	eax, 2
	push	edi
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR _param$GSCopy$1$[esp+384], ecx
	mov	DWORD PTR _args$1$[esp+384], eax
$LN143@atcprintf:

; 562  : 
; 563  : 	buf_p = buffer;

	mov	DWORD PTR _llen$[esp+384], edx
	mov	DWORD PTR _buf_p$[esp+384], esi
$LN146@atcprintf:

; 564  : 	arg = *param;

	mov	DWORD PTR _arg$1$[esp+384], edi
$LN148@atcprintf:

; 566  : 
; 567  : 	while (true)
; 568  : 	{
; 569  : 		// run through the format string until we hit a '%' or '\0'
; 570  : 		for (ch = static_cast<D>(*fmt); 

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR _buf_p$1$[esp+384], esi
	mov	DWORD PTR _llen$1$[esp+384], edx

; 571  : 			llen && ((ch = static_cast<D>(*fmt)) != '\0' && ch != '%');

	test	edx, edx
	je	SHORT $LN5@atcprintf
$LL6@atcprintf:
	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	$done$155
	cmp	eax, 37					; 00000025H
	je	SHORT $LN5@atcprintf

; 573  : 		{
; 574  : 			*buf_p++ = static_cast<D>(ch);
; 575  : 			llen--;

	dec	edx
	mov	DWORD PTR [esi], eax
	add	esi, 4
	mov	DWORD PTR _llen$1$[esp+384], edx
	add	ebx, 4
	mov	DWORD PTR _buf_p$1$[esp+384], esi
	mov	DWORD PTR _buf_p$[esp+384], esi
	mov	DWORD PTR _llen$[esp+384], edx
	test	edx, edx
	jne	SHORT $LL6@atcprintf
$LN5@atcprintf:

; 576  : 		}
; 577  : 		if (ch == '\0' || llen <= 0)

	test	eax, eax
	je	$done$155
	test	edx, edx
	je	$done$155

; 578  : 			goto done;
; 579  : 
; 580  : 		// skip over the '%'
; 581  : 		fmt++;
; 582  : 
; 583  : 		// reset formatting state
; 584  : 		flags = 0;

	xor	ecx, ecx

; 585  : 		width = 0;

	xor	edi, edi
	add	ebx, 4
	mov	DWORD PTR _flags$1$[esp+384], ecx

; 586  : 		prec = -1;

	or	esi, -1
	mov	DWORD PTR _width$1$[esp+384], edi
	mov	DWORD PTR _prec$1$[esp+384], esi
$rflag$156:

; 587  : 		//sign = '\0';
; 588  : 
; 589  : rflag:
; 590  : 		ch = static_cast<D>(*fmt++);

	mov	ecx, DWORD PTR [ebx]
	add	ebx, 4
$reswitch$157:

; 591  : reswitch:
; 592  : 		switch(ch)

	cmp	ecx, 120				; 00000078H
	ja	$LN67@atcprintf
	movzx	eax, BYTE PTR $LN138@atcprintf[ecx]
	jmp	DWORD PTR $LN154@atcprintf[eax*4]
$LN18@atcprintf:

; 597  : 		case '.':
; 598  : 			n = 0;
; 599  : 			while( is_digit( ( ch = static_cast<D>(*fmt++)) ) )

	mov	ecx, DWORD PTR [ebx]
	xor	esi, esi
	lea	eax, DWORD PTR [ecx-48]
	cmp	eax, 9
	ja	SHORT $LN124@atcprintf
	npad	6
$LL9@atcprintf:
	add	ebx, 4

; 600  : 				n = 10 * n + ( ch - '0' );

	lea	eax, DWORD PTR [esi-6]
	lea	eax, DWORD PTR [esi+eax*4]
	lea	esi, DWORD PTR [ecx+eax*2]
	mov	ecx, DWORD PTR [ebx]
	lea	eax, DWORD PTR [ecx-48]
	cmp	eax, 9
	jbe	SHORT $LL9@atcprintf
$LN124@atcprintf:

; 597  : 		case '.':
; 598  : 			n = 0;
; 599  : 			while( is_digit( ( ch = static_cast<D>(*fmt++)) ) )

	add	ebx, 4

; 601  : 			prec = n < 0 ? -1 : n;

	mov	eax, -1
	test	esi, esi
	cmovs	esi, eax
	mov	DWORD PTR _prec$1$[esp+384], esi

; 602  : 			goto reswitch;

	jmp	SHORT $reswitch$157
$LN20@atcprintf:

; 605  : 			goto rflag;
; 606  : 		case '1':
; 607  : 		case '2':
; 608  : 		case '3':
; 609  : 		case '4':
; 610  : 		case '5':
; 611  : 		case '6':
; 612  : 		case '7':
; 613  : 		case '8':
; 614  : 		case '9':
; 615  : 			n = 0;

	xor	edi, edi
	npad	5
$LL13@atcprintf:

; 616  : 			do {
; 617  : 				n = 10 * n + ( ch - '0' );

	lea	eax, DWORD PTR [edi-6]
	lea	eax, DWORD PTR [edi+eax*4]
	lea	edi, DWORD PTR [ecx+eax*2]

; 618  : 				ch = static_cast<D>(*fmt++);

	mov	ecx, DWORD PTR [ebx]
	add	ebx, 4

; 619  : 			} while( is_digit( ch ) );

	lea	eax, DWORD PTR [ecx-48]
	cmp	eax, 9
	jbe	SHORT $LL13@atcprintf
	mov	DWORD PTR _width$1$[esp+384], edi

; 620  : 			width = n;
; 621  : 			goto reswitch;

	jmp	SHORT $reswitch$157
$LN17@atcprintf:

; 593  : 		{
; 594  : 		case '-':
; 595  : 			flags |= LADJUST;

	or	DWORD PTR _flags$1$[esp+384], 4

; 596  : 			goto rflag;

	jmp	$rflag$156
$LN19@atcprintf:

; 603  : 		case '0':
; 604  : 			flags |= ZEROPAD;

	or	DWORD PTR _flags$1$[esp+384], 128	; 00000080H

; 572  : 			fmt++)

	jmp	$rflag$156
$LN21@atcprintf:

; 622  : 		case 'c':
; 623  : 			CHECK_ARGS(0);

	mov	edi, DWORD PTR _arg$1$[esp+384]
	mov	eax, DWORD PTR _args$1$[esp+384]
	cmp	edi, eax
	jg	$LN105@atcprintf

; 624  : 			*buf_p++ = static_cast<D>(*get_amxaddr(amx, params[arg]));

	mov	eax, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [eax+edi*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	esi, DWORD PTR _buf_p$1$[esp+392]
	add	esp, 8

; 625  : 			llen--;

	mov	edx, DWORD PTR _llen$1$[esp+384]
	dec	edx
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax
	add	esi, 4

; 626  : 			arg++;

	inc	edi

; 627  : 			break;

	jmp	$LN143@atcprintf
$LN23@atcprintf:

; 628  : 		case 'b':
; 629  : 			CHECK_ARGS(0);

	mov	ecx, DWORD PTR _arg$1$[esp+384]
	mov	eax, DWORD PTR _args$1$[esp+384]
	cmp	ecx, eax
	jg	$LN106@atcprintf

; 630  : 			AddBinary(&buf_p, llen, *get_amxaddr(amx, params[arg]), width, flags);

	mov	eax, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [eax+ecx*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	ecx, DWORD PTR _flags$1$[esp+392]
	push	ecx
	push	edi
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR _llen$[esp+404]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+408]
	push	eax
	call	??$AddBinary@H@@YAXPAPAHAAIIHH@Z	; AddBinary<int>

; 631  : 			arg++;

	mov	edi, DWORD PTR _arg$1$[esp+412]
	add	esp, 28					; 0000001cH

; 632  : 			break;

	mov	edx, DWORD PTR _llen$[esp+384]
	inc	edi
	mov	esi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN146@atcprintf
$LN25@atcprintf:

; 633  : 		case 'd':
; 634  : 		case 'i':
; 635  : 			CHECK_ARGS(0);

	mov	ecx, DWORD PTR _arg$1$[esp+384]
	mov	eax, DWORD PTR _args$1$[esp+384]
	cmp	ecx, eax
	jg	$LN106@atcprintf

; 636  : 			AddInt(&buf_p, llen, *get_amxaddr(amx, params[arg]), width, flags);

	mov	eax, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [eax+ecx*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	ecx, DWORD PTR _flags$1$[esp+392]
	push	ecx
	push	edi
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR _llen$[esp+404]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+408]
	push	eax
	call	??$AddInt@H@@YAXPAPAHAAIHHH@Z		; AddInt<int>
	mov	edi, DWORD PTR _arg$1$[esp+412]
	add	esp, 28					; 0000001cH
	mov	edx, DWORD PTR _llen$[esp+384]
	inc	edi
	mov	esi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN146@atcprintf
$LN27@atcprintf:

; 637  : 			arg++;
; 638  : 			break;
; 639  : 		case 'u':
; 640  : 			CHECK_ARGS(0);

	mov	ecx, DWORD PTR _arg$1$[esp+384]
	mov	eax, DWORD PTR _args$1$[esp+384]
	cmp	ecx, eax
	jg	$LN106@atcprintf

; 641  : 			AddUInt(&buf_p, llen, static_cast<unsigned int>(*get_amxaddr(amx, params[arg])), width, flags);

	mov	eax, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [eax+ecx*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	ecx, DWORD PTR _flags$1$[esp+392]
	push	ecx
	push	edi
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR _llen$[esp+404]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+408]
	push	eax
	call	??$AddUInt@H@@YAXPAPAHAAIIHH@Z		; AddUInt<int>
	mov	edi, DWORD PTR _arg$1$[esp+412]
	add	esp, 28					; 0000001cH
	mov	edx, DWORD PTR _llen$[esp+384]
	inc	edi
	mov	esi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN146@atcprintf
$LN29@atcprintf:

; 642  : 			arg++;
; 643  : 			break;
; 644  : 		case 'f':
; 645  : 			CHECK_ARGS(0);

	mov	ecx, DWORD PTR _arg$1$[esp+384]
	mov	eax, DWORD PTR _args$1$[esp+384]
	cmp	ecx, eax
	jg	$LN106@atcprintf

; 646  : 			AddFloat(&buf_p, llen, amx_ctof(*get_amxaddr(amx, params[arg])), width, prec, flags);

	mov	eax, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [eax+ecx*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	ecx, DWORD PTR _flags$1$[esp+392]
	add	esp, 8
	movss	xmm0, DWORD PTR [eax]
	lea	eax, DWORD PTR _llen$[esp+384]
	push	ecx
	push	esi
	push	edi
	cvtps2pd xmm0, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+408]
	push	eax
	call	??$AddFloat@H@@YAXPAPAHAAINHHH@Z	; AddFloat<int>
	mov	edi, DWORD PTR _arg$1$[esp+412]
	add	esp, 28					; 0000001cH
	mov	edx, DWORD PTR _llen$[esp+384]
	inc	edi
	mov	esi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN146@atcprintf
$LN31@atcprintf:

; 647  : 			arg++;
; 648  : 			break;
; 649  : 		case 'X':
; 650  : 			CHECK_ARGS(0);

	mov	ecx, DWORD PTR _arg$1$[esp+384]
	mov	eax, DWORD PTR _args$1$[esp+384]
	cmp	ecx, eax
	jg	$LN106@atcprintf

; 651  : 			flags |= UPPERDIGITS;
; 652  : 			AddHex(&buf_p, llen, static_cast<unsigned int>(*get_amxaddr(amx, params[arg])), width, flags);

	mov	eax, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [eax+ecx*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	ecx, DWORD PTR _flags$1$[esp+392]
	or	ecx, 512				; 00000200H
$LN144@atcprintf:
	push	ecx
	push	edi
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR _llen$[esp+404]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+408]
	push	eax
	call	??$AddHex@H@@YAXPAPAHAAIIHH@Z		; AddHex<int>
	mov	edi, DWORD PTR _arg$1$[esp+412]
	add	esp, 28					; 0000001cH
	mov	edx, DWORD PTR _llen$[esp+384]
	inc	edi
	mov	esi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN146@atcprintf
$LN33@atcprintf:

; 653  : 			arg++;
; 654  : 			break;
; 655  : 		case 'x':
; 656  : 			CHECK_ARGS(0);

	mov	ecx, DWORD PTR _arg$1$[esp+384]
	mov	eax, DWORD PTR _args$1$[esp+384]
	cmp	ecx, eax
	jg	$LN106@atcprintf

; 657  : 			AddHex(&buf_p, llen, static_cast<unsigned int>(*get_amxaddr(amx, params[arg])), width, flags);

	mov	eax, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [eax+ecx*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	ecx, DWORD PTR _flags$1$[esp+392]

; 658  : 			arg++;
; 659  : 			break;

	jmp	SHORT $LN144@atcprintf
$LN35@atcprintf:

; 660  : 		case 'a':
; 661  : 			{
; 662  : 				CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$1$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN112@atcprintf

; 663  : 				// %a is passed a pointer directly to a cell string.
; 664  : 				cell* ptr=reinterpret_cast<cell*>(*get_amxaddr(amx, params[arg]));

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 665  : 				if (!ptr)

	test	eax, eax
	je	$LN113@atcprintf

; 669  : 				}
; 670  : 
; 671  : 				AddString(&buf_p, llen, ptr, width, prec);

	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR _llen$[esp+396]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+400]
	push	eax
	call	??$AddString@HH@@YAXPAPAHAAIPBHHH@Z	; AddString<int,int>
	mov	edi, DWORD PTR _arg$1$[esp+404]
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _llen$[esp+384]
	inc	edi
	mov	esi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN146@atcprintf
$LN38@atcprintf:

; 672  : 				arg++;
; 673  : 				break;
; 674  : 			}
; 675  : 		case 's':
; 676  : 			CHECK_ARGS(0);

	mov	ecx, DWORD PTR _arg$1$[esp+384]
	mov	eax, DWORD PTR _args$1$[esp+384]
	cmp	ecx, eax
	jg	$LN106@atcprintf

; 677  : 			AddString(&buf_p, llen, get_amxaddr(amx, params[arg]), width, prec);

	mov	eax, DWORD PTR _params$GSCopy$1$[esp+384]
	push	esi
	push	edi
	mov	edi, ecx
	push	DWORD PTR [eax+edi*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+396]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	add	esp, 8
	push	eax
	lea	eax, DWORD PTR _llen$[esp+396]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+400]
	push	eax
	call	??$AddString@HH@@YAXPAPAHAAIPBHHH@Z	; AddString<int,int>
	mov	edx, DWORD PTR _llen$[esp+404]
	add	esp, 20					; 00000014H
	mov	esi, DWORD PTR _buf_p$[esp+384]
	inc	edi
	jmp	$LN146@atcprintf
$LN40@atcprintf:

; 678  : 			arg++;
; 679  : 			break;
; 680  : 		case 'L':
; 681  : 		case 'l':
; 682  : 			{
; 683  : 				const char *lang;
; 684  : 				int len;
; 685  : 				if (ch == 'L')

	cmp	ecx, 76					; 0000004cH

; 686  : 				{
; 687  : 					CHECK_ARGS(1);

	mov	ecx, DWORD PTR _arg$1$[esp+384]
	jne	SHORT $LN41@atcprintf
	mov	edx, DWORD PTR _args$1$[esp+384]
	lea	eax, DWORD PTR [ecx+1]
	cmp	eax, edx
	jg	$LN115@atcprintf

; 688  : 					auto currParam = params[arg++];

	mov	edi, DWORD PTR _params$GSCopy$1$[esp+384]
	mov	edi, DWORD PTR [edi+ecx*4]
	mov	ecx, eax

; 689  : 					lang = playerlang(*get_amxaddr(amx, currParam));

	push	edi
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	mov	DWORD PTR _arg$1$[esp+392], ecx
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	push	DWORD PTR [eax]
	call	?playerlang@@YAPBDH@Z			; playerlang
	mov	esi, eax
	add	esp, 12					; 0000000cH

; 690  : 					if (!lang)

	test	esi, esi
	jne	SHORT $LN42@atcprintf

; 691  : 						lang = get_amxstring(amx, currParam, 2, len);

	lea	eax, DWORD PTR _len$1[esp+384]
	push	eax
	push	2
	push	edi
	push	DWORD PTR _amx$GSCopy$1$[esp+396]
	call	?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z	; get_amxstring
	add	esp, 16					; 00000010H

; 692  : 				}
; 693  : 				else

	jmp	SHORT $LN147@atcprintf
$LN41@atcprintf:

; 694  : 				{
; 695  : 					CHECK_ARGS(0);

	mov	eax, DWORD PTR _args$1$[esp+384]
	cmp	ecx, eax
	jg	$LN106@atcprintf

; 696  : 					lang = playerlang(g_langMngr.GetDefLang());

	push	DWORD PTR ?g_langMngr@@3VCLangMngr@@A+68
	call	?playerlang@@YAPBDH@Z			; playerlang
	add	esp, 4
$LN147@atcprintf:
	mov	esi, eax
$LN42@atcprintf:

; 697  : 				}
; 698  : 				const char *key = get_amxstring(amx, params[arg++], 3, len);

	mov	ecx, DWORD PTR _arg$1$[esp+384]
	mov	eax, DWORD PTR _params$GSCopy$1$[esp+384]
	mov	eax, DWORD PTR [eax+ecx*4]
	inc	ecx
	mov	DWORD PTR _arg$[esp+384], ecx
	lea	ecx, DWORD PTR _len$1[esp+384]
	push	ecx
	push	3
	push	eax
	push	DWORD PTR _amx$GSCopy$1$[esp+396]
	call	?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z	; get_amxstring
	mov	edi, eax

; 699  : 				const char *def = translate(amx, lang, key);

	push	edi
	push	esi
	mov	esi, DWORD PTR _amx$GSCopy$1$[esp+408]
	push	esi
	call	?translate@@YAPBDPAUtagAMX@@PBD1@Z	; translate
	add	esp, 28					; 0000001cH

; 700  : 				if (!def)

	test	eax, eax
	jne	SHORT $LN46@atcprintf

; 701  : 				{
; 702  : 					static char buf[255];
; 703  : 					ke::SafeSprintf(buf, sizeof(buf), "ML_NOTFOUND: %s", key);

	push	edi
	push	OFFSET ??_C@_0BA@HJJJBHCN@ML_NOTFOUND?3?5?$CFs?$AA@
	push	255					; 000000ffH
	push	OFFSET ?buf@?DN@???$atcprintf@HH@@YAIPAHIPBHPAUtagAMX@@00@Z@4PADA ; `atcprintf<int,int>'::`61'::buf
	call	?SafeSprintf@ke@@YAIPADIPBDZZ		; ke::SafeSprintf
	add	esp, 16					; 00000010H

; 704  : 					def = buf;

	mov	eax, OFFSET ?buf@?DN@???$atcprintf@HH@@YAIPAHIPBHPAUtagAMX@@00@Z@4PADA ; `atcprintf<int,int>'::`61'::buf
$LN46@atcprintf:

; 705  : 				}
; 706  : 				size_t written = atcprintf(buf_p, llen, def, amx, params, &arg);

	lea	ecx, DWORD PTR _arg$[esp+384]
	push	ecx
	push	DWORD PTR _params$GSCopy$1$[esp+388]
	push	esi
	mov	esi, DWORD PTR _buf_p$1$[esp+396]
	push	eax
	push	DWORD PTR _llen$1$[esp+400]
	push	esi
	call	??$atcprintf@HD@@YAIPAHIPBDPAUtagAMX@@00@Z ; atcprintf<int,char>

; 707  : 				buf_p += written;
; 708  : 				llen -= written;

	mov	edx, DWORD PTR _llen$1$[esp+408]
	add	esp, 24					; 00000018H

; 709  : 				break;

	mov	edi, DWORD PTR _arg$[esp+384]
	sub	edx, eax
	lea	esi, DWORD PTR [esi+eax*4]
	jmp	$LN143@atcprintf
$LN47@atcprintf:

; 710  : 			}
; 711  : 		case 'N':
; 712  : 			{
; 713  : 				CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$1$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN117@atcprintf

; 714  : 				cell *addr = get_amxaddr(amx, params[arg]);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	add	esp, 8

; 715  : 				char buffer[255];
; 716  : 				if (*addr)

	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	$LN49@atcprintf

; 717  : 				{
; 718  : 					CPlayer *player = NULL;
; 719  : 
; 720  : 					if (*addr >= 1 && *addr <= gpGlobals->maxClients)

	cmp	edx, 1
	jl	$LN118@atcprintf
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	cmp	edx, DWORD PTR [ecx+148]
	jg	$LN118@atcprintf

; 721  : 					{
; 722  : 						player = GET_PLAYER_POINTER_I(*addr);

	imul	esi, edx, 564
	add	esi, OFFSET ?g_players@@3PAVCPlayer@@A	; g_players
	mov	DWORD PTR _player$1$[esp+384], esi

; 723  : 					}
; 724  : 
; 725  : 					if (!player || !player->initialized)

	je	$LN118@atcprintf
	cmp	BYTE PTR [esi+28], 0
	je	$LN118@atcprintf

; 728  : 						return 0;
; 729  : 					}
; 730  : 
; 731  : 					unsigned int auth = GETPLAYERAUTHID(player->pEdict); //DYLAN FIX GETPLAYERAUTHID(player->pEdict);

	push	DWORD PTR [esi]
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+476

; 732  : #if 0
; 733  : 					if (!auth || auth[0] == '\0')
; 734  : 					{
; 735  : 						auth = "STEAM_ID_PENDING";
; 736  : 					}
; 737  : #endif
; 738  : 
; 739  : 					int userid = GETPLAYERUSERID(player->pEdict);

	push	DWORD PTR [esi]
	mov	edi, eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+464
	mov	esi, eax
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 128  :     if (!chars_)

	mov	edx, OFFSET ??_C@_00CNPNBAHC@?$AA@
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 144  :       return !t_;

	mov	eax, DWORD PTR _player$1$[esp+392]
	mov	ecx, DWORD PTR [eax+20]
	test	ecx, ecx
	mov	eax, DWORD PTR [eax+4]
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 128  :     if (!chars_)

	cmovne	edx, ecx
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 144  :       return !t_;

	test	eax, eax
; File e:\nightfire_sdk\amx\amxmodx\format.cpp

; 740  : 					ke::SafeSprintf(buffer, sizeof(buffer), "%s<%d><%u><%s>", player->name.chars(), userid, auth, player->team.chars());

	push	edx
	push	edi
	push	esi
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 128  :     if (!chars_)

	mov	ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
	cmovne	ecx, eax
; File e:\nightfire_sdk\amx\amxmodx\format.cpp

; 740  : 					ke::SafeSprintf(buffer, sizeof(buffer), "%s<%d><%u><%s>", player->name.chars(), userid, auth, player->team.chars());

	lea	eax, DWORD PTR _buffer$2[esp+404]
	push	ecx
	push	OFFSET ??_C@_0P@JDPKEEME@?$CFs?$DM?$CFd?$DO?$DM?$CFu?$DO?$DM?$CFs?$DO?$AA@
	push	255					; 000000ffH
	push	eax
	call	?SafeSprintf@ke@@YAIPADIPBDZZ		; ke::SafeSprintf

; 741  : 				}
; 742  : 				else

	mov	esi, DWORD PTR _prec$1$[esp+420]
	add	esp, 36					; 00000024H
	mov	edi, DWORD PTR _width$1$[esp+384]
	jmp	SHORT $LN50@atcprintf
$LN49@atcprintf:

; 743  : 				{
; 744  : 					ke::SafeSprintf(buffer, sizeof(buffer), "Console<0><Console><Console>");

	push	OFFSET ??_C@_0BN@PONBEONJ@Console?$DM0?$DO?$DMConsole?$DO?$DMConsole?$DO?$AA@
	lea	eax, DWORD PTR _buffer$2[esp+388]
	push	255					; 000000ffH
	push	eax
	call	?SafeSprintf@ke@@YAIPADIPBDZZ		; ke::SafeSprintf
	add	esp, 12					; 0000000cH
$LN50@atcprintf:

; 745  : 				}
; 746  : 
; 747  : 				AddString(&buf_p, llen, buffer, width, prec);

	push	esi
	push	edi
	lea	eax, DWORD PTR _buffer$2[esp+392]
	push	eax
$LN145@atcprintf:
	lea	eax, DWORD PTR _llen$[esp+396]
	push	eax
	lea	eax, DWORD PTR _buf_p$[esp+400]
	push	eax
	call	??$AddString@HD@@YAXPAPAHAAIPBDHH@Z	; AddString<int,char>
	mov	edi, DWORD PTR _arg$1$[esp+404]
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _llen$[esp+384]
	inc	edi
	mov	esi, DWORD PTR _buf_p$[esp+384]
	jmp	$LN146@atcprintf
$LN54@atcprintf:

; 748  : 				arg++;
; 749  : 				break;
; 750  : 			}
; 751  : 		case 'n':
; 752  : 			{
; 753  : 				CHECK_ARGS(0);

	mov	eax, DWORD PTR _arg$1$[esp+384]
	mov	ecx, DWORD PTR _args$1$[esp+384]
	cmp	eax, ecx
	jg	$LN117@atcprintf

; 754  : 				cell *addr = get_amxaddr(amx, params[arg]);

	mov	ecx, DWORD PTR _params$GSCopy$1$[esp+384]
	push	DWORD PTR [ecx+eax*4]
	push	DWORD PTR _amx$GSCopy$1$[esp+388]
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	mov	edx, eax
	add	esp, 8
	mov	DWORD PTR _addr$1$[esp+384], edx

; 755  : 				const char *name = "Console";

	mov	ecx, OFFSET ??_C@_07PGLPGHFC@Console?$AA@

; 756  : 
; 757  : 				if (*addr)

	mov	edx, DWORD PTR [edx]
	test	edx, edx
	je	SHORT $LN89@atcprintf

; 758  : 				{
; 759  : 					CPlayer *player = NULL;
; 760  : 
; 761  : 					if (*addr >= 1 && *addr <= gpGlobals->maxClients)

	cmp	edx, 1
	jl	$LN120@atcprintf
	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	cmp	edx, DWORD PTR [ecx+148]
	jg	$LN120@atcprintf

; 762  : 					{
; 763  : 						player = GET_PLAYER_POINTER_I(*addr);

	imul	eax, edx, 564
	add	eax, OFFSET ?g_players@@3PAVCPlayer@@A	; g_players

; 764  : 					}
; 765  : 
; 766  : 					if (!player || !player->initialized)

	je	$LN120@atcprintf
	cmp	BYTE PTR [eax+28], 0
	je	$LN120@atcprintf
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 144  :       return !t_;

	mov	eax, DWORD PTR [eax+4]
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 128  :     if (!chars_)

	mov	ecx, OFFSET ??_C@_00CNPNBAHC@?$AA@
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 144  :       return !t_;

	test	eax, eax
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 128  :     if (!chars_)

	cmovne	ecx, eax
$LN89@atcprintf:
; File e:\nightfire_sdk\amx\amxmodx\format.cpp

; 775  : 				AddString(&buf_p, llen, name, width, prec);

	push	esi
	push	edi
	push	ecx

; 776  : 				arg++;
; 777  : 				break;

	jmp	$LN145@atcprintf
$LN60@atcprintf:

; 778  : 			}
; 779  : 		case '%':
; 780  : 			*buf_p++ = static_cast<D>(ch);

	mov	esi, DWORD PTR _buf_p$1$[esp+384]

; 794  : 			if (!llen)
; 795  : 				goto done;
; 796  : 			llen--;
; 797  : 			break;
; 798  : 		}
; 799  : 	}

	mov	edi, DWORD PTR _arg$1$[esp+384]
	mov	DWORD PTR [esi], 37			; 00000025H
	add	esi, 4
	dec	edx
	mov	DWORD PTR _buf_p$[esp+384], esi
	mov	DWORD PTR _llen$[esp+384], edx
	jmp	$LN148@atcprintf
$LN67@atcprintf:

; 790  : 			goto done;
; 791  : 			break;
; 792  : 		default:
; 793  : 			*buf_p++ = static_cast<D>(ch);

	mov	esi, DWORD PTR _buf_p$1$[esp+384]

; 794  : 			if (!llen)
; 795  : 				goto done;
; 796  : 			llen--;
; 797  : 			break;
; 798  : 		}
; 799  : 	}

	mov	edi, DWORD PTR _arg$1$[esp+384]
	mov	DWORD PTR [esi], ecx
	add	esi, 4
	dec	edx
	mov	DWORD PTR _buf_p$[esp+384], esi
	mov	DWORD PTR _llen$[esp+384], edx
	jmp	$LN148@atcprintf
$LN105@atcprintf:

; 622  : 		case 'c':
; 623  : 			CHECK_ARGS(0);

	push	eax
	push	edi
	push	OFFSET ??_C@_0DH@NEIDFOJI@String?5formatted?5incorrectly?5?9?5p@
	push	25					; 00000019H
	push	DWORD PTR _amx$GSCopy$1$[esp+400]
	call	_LogError
	add	esp, 20					; 00000014H
	xor	eax, eax

; 810  : 	}
; 811  : 
; 812  : 	return maxlen-llen;
; 813  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+372]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN106@atcprintf:

; 628  : 		case 'b':
; 629  : 			CHECK_ARGS(0);

	push	eax
$LN149@atcprintf:
	push	ecx
$LN150@atcprintf:
	push	OFFSET ??_C@_0DH@NEIDFOJI@String?5formatted?5incorrectly?5?9?5p@
	push	25					; 00000019H
	push	DWORD PTR _amx$GSCopy$1$[esp+400]
	call	_LogError
	add	esp, 20					; 00000014H
	xor	eax, eax

; 810  : 	}
; 811  : 
; 812  : 	return maxlen-llen;
; 813  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+372]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN113@atcprintf:

; 666  : 				{
; 667  : 					LogError(amx, AMX_ERR_NATIVE, "Invalid vector string handle provided (%d)", *get_amxaddr(amx, params[arg]));

	mov	ecx, DWORD PTR _arg$1$[esp+384]
	mov	eax, DWORD PTR _params$GSCopy$1$[esp+384]
	mov	ebx, DWORD PTR _amx$GSCopy$1$[esp+384]
	push	DWORD PTR [eax+ecx*4]
	push	ebx
	call	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z	; get_amxaddr
	push	DWORD PTR [eax]
	push	OFFSET ??_C@_0CL@GCKMCDNK@Invalid?5vector?5string?5handle?5pro@
	push	10					; 0000000aH
	push	ebx
	call	_LogError
	add	esp, 24					; 00000018H

; 668  : 					return 0;

	xor	eax, eax

; 810  : 	}
; 811  : 
; 812  : 	return maxlen-llen;
; 813  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+372]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN112@atcprintf:

; 660  : 		case 'a':
; 661  : 			{
; 662  : 				CHECK_ARGS(0);

	push	ecx
	push	eax
	push	OFFSET ??_C@_0DH@NEIDFOJI@String?5formatted?5incorrectly?5?9?5p@
	push	25					; 00000019H
	push	DWORD PTR _amx$GSCopy$1$[esp+400]
	call	_LogError
	add	esp, 20					; 00000014H
	xor	eax, eax

; 810  : 	}
; 811  : 
; 812  : 	return maxlen-llen;
; 813  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+372]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN115@atcprintf:

; 686  : 				{
; 687  : 					CHECK_ARGS(1);

	push	edx
	jmp	$LN149@atcprintf
$LN118@atcprintf:

; 726  : 					{
; 727  : 						LogError(amx, AMX_ERR_NATIVE, "Client index %d is invalid", *addr);

	push	edx
$LN152@atcprintf:
	push	OFFSET ??_C@_0BL@KOKBGDMJ@Client?5index?5?$CFd?5is?5invalid?$AA@
	push	10					; 0000000aH
	push	DWORD PTR _amx$GSCopy$1$[esp+396]
	call	_LogError
	add	esp, 16					; 00000010H
	xor	eax, eax

; 810  : 	}
; 811  : 
; 812  : 	return maxlen-llen;
; 813  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+372]
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN117@atcprintf:

; 710  : 			}
; 711  : 		case 'N':
; 712  : 			{
; 713  : 				CHECK_ARGS(0);

	push	ecx
	push	eax
	jmp	$LN150@atcprintf
$LN120@atcprintf:

; 767  : 					{
; 768  : 						LogError(amx, AMX_ERR_NATIVE, "Client index %d is invalid", *addr);

	mov	eax, DWORD PTR _addr$1$[esp+384]
	push	DWORD PTR [eax]

; 769  : 						return 0;

	jmp	SHORT $LN152@atcprintf
$LN63@atcprintf:

; 781  : 			if (!llen)
; 782  : 				goto done;
; 783  : 			llen--;
; 784  : 			break;
; 785  : 		case '\0':
; 786  : 			*buf_p++ = static_cast<D>('%');

	mov	esi, DWORD PTR _buf_p$1$[esp+384]
	mov	edi, DWORD PTR _arg$1$[esp+384]
	mov	DWORD PTR [esi], 37			; 00000025H
	add	esi, 4

; 787  : 			if (!llen)
; 788  : 				goto done;
; 789  : 			llen--;

	dec	edx
	mov	DWORD PTR _llen$1$[esp+384], edx
$done$155:

; 800  : 
; 801  : done:
; 802  : 	*buf_p = static_cast<D>(0);
; 803  : 	*param = arg;

	mov	eax, DWORD PTR _param$GSCopy$1$[esp+384]
	mov	DWORD PTR [esi], 0
	mov	DWORD PTR [eax], edi

; 804  : 
; 805  : 	/* if max buffer length consumed, make sure we don't truncate a multi-byte character */
; 806  : 	if (llen <= 0 && *(buf_p - 1) & 1 << 7)

	test	edx, edx
	jne	SHORT $LN70@atcprintf
	test	BYTE PTR [esi-4], 128			; 00000080H
	lea	eax, DWORD PTR [esi-4]
	je	SHORT $LN70@atcprintf

; 807  : 	{
; 808  : 		llen += UTIL_CheckValidChar(buf_p - 1);

	push	eax
	call	??$UTIL_CheckValidChar@H@@YAHPAH@Z	; UTIL_CheckValidChar<int>
	mov	edx, DWORD PTR _llen$1$[esp+388]
	add	esp, 4
	add	edx, eax

; 809  : 		*(buf_p - llen) = static_cast<D>(0);

	lea	ecx, DWORD PTR [edx*4]
	sub	esi, ecx
	mov	DWORD PTR [esi], 0
$LN70@atcprintf:

; 810  : 	}
; 811  : 
; 812  : 	return maxlen-llen;
; 813  : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+384]
	mov	eax, DWORD PTR _maxlen$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	sub	eax, edx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN154@atcprintf:
	DD	$LN63@atcprintf
	DD	$LN60@atcprintf
	DD	$LN17@atcprintf
	DD	$LN18@atcprintf
	DD	$LN19@atcprintf
	DD	$LN20@atcprintf
	DD	$LN40@atcprintf
	DD	$LN47@atcprintf
	DD	$LN31@atcprintf
	DD	$LN35@atcprintf
	DD	$LN23@atcprintf
	DD	$LN21@atcprintf
	DD	$LN25@atcprintf
	DD	$LN29@atcprintf
	DD	$LN54@atcprintf
	DD	$LN38@atcprintf
	DD	$LN27@atcprintf
	DD	$LN33@atcprintf
	DD	$LN67@atcprintf
$LN138@atcprintf:
	DB	0
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	1
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	2
	DB	3
	DB	18					; 00000012H
	DB	4
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	6
	DB	18					; 00000012H
	DB	7
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	8
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	18					; 00000012H
	DB	13					; 0000000dH
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	12					; 0000000cH
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	6
	DB	18					; 00000012H
	DB	14					; 0000000eH
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	15					; 0000000fH
	DB	18					; 00000012H
	DB	16					; 00000010H
	DB	18					; 00000012H
	DB	18					; 00000012H
	DB	17					; 00000011H
??$atcprintf@HH@@YAIPAHIPBHPAUtagAMX@@00@Z ENDP		; atcprintf<int,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
;	COMDAT ?translate@@YAPBDPAUtagAMX@@PBD1@Z
_TEXT	SEGMENT
_langName$2 = -32					; size = 8
_debug_status$3 = -24					; size = 4
_status$ = -20						; size = 4
_validlang$1$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_amx$ = 8						; size = 4
_lang$ = 12						; size = 4
_debug$1$ = 15						; size = 1
_key$ = 16						; size = 4
?translate@@YAPBDPAUtagAMX@@PBD1@Z PROC			; translate, COMDAT

; 95   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?translate@@YAPBDPAUtagAMX@@PBD1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 96   : 	auto pLangName = lang;

	mov	esi, DWORD PTR _lang$[ebp]

; 97   : 	int status;
; 98   : 
; 99   : 	if (!pLangName || !isalpha(pLangName[0]))

	test	esi, esi
	je	SHORT $LN3@translate
	movsx	eax, BYTE PTR [esi]
	push	eax
	call	_isalpha
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN2@translate
$LN3@translate:

; 100  : 	{
; 101  : 		pLangName = amxmodx_language->getValueString();

	mov	ecx, DWORD PTR ?amxmodx_language@@3PAVConsoleVariable@@A ; amxmodx_language
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+80]
	mov	esi, eax
$LN2@translate:

; 102  : 	}
; 103  : 
; 104  : 	auto def = g_langMngr.GetDef(pLangName, key, status);

	lea	eax, DWORD PTR _status$[ebp]
	mov	ecx, OFFSET ?g_langMngr@@3VCLangMngr@@A	; g_langMngr
	push	eax
	push	DWORD PTR _key$[ebp]
	push	esi
	call	?GetDef@CLangMngr@@QAEPBDPBD0AAH@Z	; CLangMngr::GetDef
	mov	ebx, eax

; 105  : 
; 106  : 	if (!amx_mldebug)

	mov	eax, DWORD PTR ?amx_mldebug@@3PAVConsoleVariable@@A
	test	eax, eax
	jne	SHORT $LN25@translate

; 107  : 	{
; 108  : 		amx_mldebug = CVAR_GET_POINTER("amx_mldebug");

	push	OFFSET ??_C@_0M@MIAOMHNK@amx_mldebug?$AA@
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	add	esp, 4
	mov	DWORD PTR ?amx_mldebug@@3PAVConsoleVariable@@A, eax

; 109  : 	}
; 110  : 
; 111  : 	auto debug = (amx_mldebug && amx_mldebug->getValueString() && (amx_mldebug->getValueString()[0] != '\0'));

	test	eax, eax
	je	$LN14@translate
$LN25@translate:
	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	call	DWORD PTR [edx+80]
	test	eax, eax
	je	$LN14@translate
	mov	ecx, DWORD PTR ?amx_mldebug@@3PAVConsoleVariable@@A
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+80]
	cmp	BYTE PTR [eax], 0
	je	$LN14@translate

; 112  : 
; 113  : 	if (debug)
; 114  : 	{
; 115  : 		int debug_status;
; 116  : 		auto validlang = true;
; 117  : 		auto testlang = amx_mldebug->getValueString();

	mov	ecx, DWORD PTR ?amx_mldebug@@3PAVConsoleVariable@@A
	mov	BYTE PTR _debug$1$[ebp], 1
	mov	BYTE PTR _validlang$1$[ebp], 1
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+80]
	mov	edi, eax

; 118  : 
; 119  : 		if (!g_langMngr.LangExists(testlang))

	mov	ecx, OFFSET ?g_langMngr@@3VCLangMngr@@A	; g_langMngr
	push	edi
	call	?LangExists@CLangMngr@@QAE_NPBD@Z	; CLangMngr::LangExists
	test	al, al
	jne	SHORT $LN6@translate

; 120  : 		{
; 121  : 			AMXXLOG_Error("[AMXX] \"%s\" is an invalid debug language", testlang);

	push	edi
	push	OFFSET ??_C@_0CJ@HNOIGG@?$FLAMXX?$FN?5?$CC?$CFs?$CC?5is?5an?5invalid?5debug?5@
	push	OFFSET ?g_log@@3VCLog@@A		; g_log
	call	?LogError@CLog@@QAAXPBDZZ		; CLog::LogError
	add	esp, 12					; 0000000cH

; 122  : 			validlang = false;

	mov	BYTE PTR _validlang$1$[ebp], 0
$LN6@translate:

; 123  : 		}
; 124  : 
; 125  : 		g_langMngr.GetDef(testlang, key, debug_status);

	lea	eax, DWORD PTR _debug_status$3[ebp]
	mov	ecx, OFFSET ?g_langMngr@@3VCLangMngr@@A	; g_langMngr
	push	eax
	push	DWORD PTR _key$[ebp]
	push	edi
	call	?GetDef@CLangMngr@@QAEPBDPBD0AAH@Z	; CLangMngr::GetDef

; 126  : 
; 127  : 		if (validlang && debug_status == ERR_BADKEY)

	cmp	BYTE PTR _validlang$1$[ebp], 0
	je	SHORT $LN45@translate
	cmp	DWORD PTR _debug_status$3[ebp], 1
	jne	SHORT $LN45@translate

; 128  : 		{
; 129  : 			AMXXLOG_Error("[AMXX] Language key \"%s\" not found for language \"%s\", check \"%s\"", key, testlang, GetFileName(amx));

	push	DWORD PTR _amx$[ebp]
	call	?GetFileName@@YAPBDPAUtagAMX@@@Z	; GetFileName
	push	eax
	push	edi
	push	DWORD PTR _key$[ebp]
	push	OFFSET ??_C@_0EB@MOLGOKDE@?$FLAMXX?$FN?5Language?5key?5?$CC?$CFs?$CC?5not?5fou@
	push	OFFSET ?g_log@@3VCLog@@A		; g_log
	call	?LogError@CLog@@QAAXPBDZZ		; CLog::LogError
	add	esp, 24					; 00000018H
$LN45@translate:
	mov	al, BYTE PTR _debug$1$[ebp]
$LN7@translate:

; 130  : 		}
; 131  : 	}
; 132  : 
; 133  : 	if (!def)

	test	ebx, ebx
	jne	$LN43@translate

; 134  : 	{
; 135  : 		if (debug && status == ERR_BADLANG)

	test	al, al
	je	SHORT $LN23@translate
	cmp	DWORD PTR _status$[ebp], 2
	jne	SHORT $LN23@translate

; 136  : 		{
; 137  : 			ke::AString langName(pLangName);

	push	esi
	lea	ecx, DWORD PTR _langName$2[ebp]
	call	??0AString@ke@@QAE@PBD@Z		; ke::AString::AString

; 138  : 
; 139  : 			auto &err = BadLang_Table.AltFindOrInsert(ke::Move(langName));

	lea	eax, DWORD PTR _langName$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], ebx
	push	eax
	mov	ecx, OFFSET ?BadLang_Table@@3V?$THash@VAString@ke@@Ulang_err@@@@A ; BadLang_Table
	call	??$AltFindOrInsert@VAString@ke@@@?$THash@VAString@ke@@Ulang_err@@@@QAEAAUlang_err@@ABVAString@ke@@@Z ; THash<ke::AString,lang_err>::AltFindOrInsert<ke::AString>

; 140  : 
; 141  : 			if (err.last + 120.0f < gpGlobals->time)

	mov	ecx, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	mov	edi, eax
	movss	xmm1, DWORD PTR [edi]
	addss	xmm1, DWORD PTR __real@42f00000
	movss	xmm0, DWORD PTR [ecx]
	comiss	xmm0, xmm1
	jbe	SHORT $LN10@translate

; 142  : 			{
; 143  : 				AMXXLOG_Error("[AMXX] Language \"%s\" not found", pLangName);

	push	esi
	push	OFFSET ??_C@_0BP@PJOGJHMO@?$FLAMXX?$FN?5Language?5?$CC?$CFs?$CC?5not?5found?$AA@
	push	OFFSET ?g_log@@3VCLog@@A		; g_log
	call	?LogError@CLog@@QAAXPBDZZ		; CLog::LogError

; 144  : 				err.last = gpGlobals->time;

	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edi], eax
$LN10@translate:
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 126  :       delete [] t_;

	push	DWORD PTR _langName$2[ebp]
; File e:\nightfire_sdk\amx\amxmodx\format.cpp

; 146  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 126  :       delete [] t_;

	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN23@translate:
; File e:\nightfire_sdk\amx\amxmodx\format.cpp

; 148  : 		if (strcmp(pLangName, amxmodx_language->getValueString()) != 0)

	mov	ecx, DWORD PTR ?amxmodx_language@@3PAVConsoleVariable@@A ; amxmodx_language
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+80]
	mov	ecx, esi
$LL28@translate:
	mov	dl, BYTE PTR [ecx]
	cmp	dl, BYTE PTR [eax]
	jne	SHORT $LN29@translate
	test	dl, dl
	je	SHORT $LN30@translate
	mov	dl, BYTE PTR [ecx+1]
	cmp	dl, BYTE PTR [eax+1]
	jne	SHORT $LN29@translate
	add	ecx, 2
	add	eax, 2
	test	dl, dl
	jne	SHORT $LL28@translate
$LN30@translate:
	xor	eax, eax
	jmp	SHORT $LN31@translate
$LN14@translate:

; 109  : 	}
; 110  : 
; 111  : 	auto debug = (amx_mldebug && amx_mldebug->getValueString() && (amx_mldebug->getValueString()[0] != '\0'));

	xor	al, al
	jmp	$LN7@translate
$LN29@translate:

; 148  : 		if (strcmp(pLangName, amxmodx_language->getValueString()) != 0)

	sbb	eax, eax
	or	eax, 1
$LN31@translate:

; 149  : 		{
; 150  : 			def = g_langMngr.GetDef(amxmodx_language->getValueString(), key, status);

	mov	edi, DWORD PTR _key$[ebp]
	test	eax, eax
	je	SHORT $LN27@translate
	mov	ecx, DWORD PTR ?amxmodx_language@@3PAVConsoleVariable@@A ; amxmodx_language
	lea	eax, DWORD PTR _status$[ebp]
	push	eax
	push	edi
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+80]
	push	eax
	mov	ecx, OFFSET ?g_langMngr@@3VCLangMngr@@A	; g_langMngr
	call	?GetDef@CLangMngr@@QAEPBDPBD0AAH@Z	; CLangMngr::GetDef
	mov	ebx, eax

; 151  : 		}
; 152  : 
; 153  : 		if (!def && (strcmp(pLangName, "en") != 0 && strcmp(amxmodx_language->getValueString(), "en") != 0))

	test	ebx, ebx
	jne	$LN43@translate
$LN27@translate:
	mov	eax, OFFSET ??_C@_02LFNMGJAP@en?$AA@
$LL32@translate:
	mov	cl, BYTE PTR [esi]
	cmp	cl, BYTE PTR [eax]
	jne	SHORT $LN33@translate
	test	cl, cl
	je	SHORT $LN34@translate
	mov	cl, BYTE PTR [esi+1]
	cmp	cl, BYTE PTR [eax+1]
	jne	SHORT $LN33@translate
	add	esi, 2
	add	eax, 2
	test	cl, cl
	jne	SHORT $LL32@translate
$LN34@translate:
	xor	eax, eax
	jmp	SHORT $LN35@translate
$LN33@translate:
	sbb	eax, eax
	or	eax, 1
$LN35@translate:
	test	eax, eax
	je	SHORT $LN43@translate
	mov	ecx, DWORD PTR ?amxmodx_language@@3PAVConsoleVariable@@A ; amxmodx_language
	mov	esi, OFFSET ??_C@_02LFNMGJAP@en?$AA@
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+80]
	npad	4
$LL36@translate:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN37@translate
	test	cl, cl
	je	SHORT $LN38@translate
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN37@translate
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $LL36@translate
$LN38@translate:
	xor	eax, eax
	jmp	SHORT $LN39@translate
$LN37@translate:
	sbb	eax, eax
	or	eax, 1
$LN39@translate:
	test	eax, eax
	je	SHORT $LN43@translate

; 154  : 		{
; 155  : 			def = g_langMngr.GetDef("en", key, status);

	lea	eax, DWORD PTR _status$[ebp]
	mov	ecx, OFFSET ?g_langMngr@@3VCLangMngr@@A	; g_langMngr
	push	eax
	push	edi
	push	OFFSET ??_C@_02LFNMGJAP@en?$AA@
	call	?GetDef@CLangMngr@@QAEPBDPBD0AAH@Z	; CLangMngr::GetDef

; 160  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN43@translate:

; 156  : 		}
; 157  : 	}
; 158  : 
; 159  : 	return def;

	mov	eax, ebx

; 160  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?translate@@YAPBDPAUtagAMX@@PBD1@Z$0:
	lea	ecx, DWORD PTR _langName$2[ebp]
	jmp	??1AString@ke@@QAE@XZ
__ehhandler$?translate@@YAPBDPAUtagAMX@@PBD1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?translate@@YAPBDPAUtagAMX@@PBD1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?translate@@YAPBDPAUtagAMX@@PBD1@Z ENDP			; translate
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
; File e:\f\metamod\metamod-hl1-master\metamod\sdk_util.h
; File e:\nightfire_sdk\amx\amxmodx\format.cpp
;	COMDAT ?playerlang@@YAPBDH@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?playerlang@@YAPBDH@Z PROC				; playerlang, COMDAT

; 51   : {

	push	esi

; 52   : 	const char *pLangName = nullptr;
; 53   : 
; 54   : 	if (index == LANG_PLAYER)

	mov	esi, DWORD PTR _index$[esp]
	cmp	esi, -1
	jne	SHORT $LN2@playerlang

; 55   : 	{
; 56   : 		if (!amx_cl_langs)

	mov	ecx, DWORD PTR ?amx_cl_langs@@3PAVConsoleVariable@@A
	test	ecx, ecx
	jne	SHORT $LN4@playerlang

; 57   : 		{
; 58   : 			amx_cl_langs = CVAR_GET_POINTER("amx_client_languages");

	push	OFFSET ??_C@_0BF@GKKDCIGK@amx_client_languages?$AA@
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR ?amx_cl_langs@@3PAVConsoleVariable@@A, ecx
$LN4@playerlang:

; 59   : 		}
; 60   : 
; 61   : 		if (static_cast<int>(amx_cl_langs->getValueInt()) == 0)

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+72]
	test	eax, eax
	jne	SHORT $LN5@playerlang

; 62   : 		{
; 63   : 			pLangName = amxmodx_language->getValueString();

	mov	ecx, DWORD PTR ?amxmodx_language@@3PAVConsoleVariable@@A ; amxmodx_language
	pop	esi
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+80]
$LN5@playerlang:

; 64   : 		}
; 65   : 		else
; 66   : 		{
; 67   : 			pLangName = ENTITY_KEYVALUE(GET_PLAYER_POINTER_I(g_langMngr.GetDefLang())->pEdict, "lang");

	imul	eax, DWORD PTR ?g_langMngr@@3VCLangMngr@@A+68, 564
$LN23@playerlang:
; File e:\f\metamod\metamod-hl1-master\metamod\sdk_util.h

; 72   : 	char *ifbuf=GET_INFOKEYBUFFER(entity);

	push	DWORD PTR ?g_players@@3PAVCPlayer@@A[eax]
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+440

; 73   : 	return(INFOKEY_VALUE(ifbuf, key));

	push	OFFSET ??_C@_04IOHABJIC@lang?$AA@
	push	eax
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+444
	add	esp, 12					; 0000000cH
	pop	esi
; File e:\nightfire_sdk\amx\amxmodx\format.cpp

; 92   : }

	ret	0
$LN2@playerlang:

; 68   : 		}
; 69   : 	}
; 70   : 	else if (index == LANG_SERVER)

	test	esi, esi
	jne	SHORT $LN7@playerlang

; 71   : 	{
; 72   : 		pLangName = amxmodx_language->getValueString();

	mov	ecx, DWORD PTR ?amxmodx_language@@3PAVConsoleVariable@@A ; amxmodx_language
	pop	esi
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+80]
$LN7@playerlang:

; 73   : 	}
; 74   : 	else if (index >= 1 && index <= gpGlobals->maxClients)

	cmp	esi, 1
	jl	SHORT $LN20@playerlang
	mov	eax, DWORD PTR ?gpGlobals@@3PAUglobalvars_t@@A ; gpGlobals
	cmp	esi, DWORD PTR [eax+148]
	jg	SHORT $LN20@playerlang

; 75   : 	{
; 76   : 		if (!amx_cl_langs)

	mov	ecx, DWORD PTR ?amx_cl_langs@@3PAVConsoleVariable@@A
	test	ecx, ecx
	jne	SHORT $LN10@playerlang

; 77   : 		{
; 78   : 			amx_cl_langs = CVAR_GET_POINTER("amx_client_languages");

	push	OFFSET ??_C@_0BF@GKKDCIGK@amx_client_languages?$AA@
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+8
	mov	ecx, eax
	add	esp, 4
	mov	DWORD PTR ?amx_cl_langs@@3PAVConsoleVariable@@A, ecx
$LN10@playerlang:

; 79   : 		}
; 80   : 
; 81   : 		if (static_cast<int>(amx_cl_langs->getValueInt()) == 0)

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+72]
	test	eax, eax
	jne	SHORT $LN11@playerlang

; 82   : 		{
; 83   : 			pLangName = amxmodx_language->getValueString();

	mov	ecx, DWORD PTR ?amxmodx_language@@3PAVConsoleVariable@@A ; amxmodx_language
	pop	esi
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+80]
$LN11@playerlang:

; 84   : 		}
; 85   : 		else
; 86   : 		{
; 87   : 			pLangName = ENTITY_KEYVALUE(GET_PLAYER_POINTER_I(index)->pEdict, "lang");

	imul	eax, esi, 564
	jmp	SHORT $LN23@playerlang
$LN20@playerlang:

; 88   : 		}
; 89   : 	}
; 90   : 
; 91   : 	return pLangName;

	xor	eax, eax
	pop	esi

; 92   : }

	ret	0
?playerlang@@YAPBDH@Z ENDP				; playerlang
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\clang.h
;	COMDAT ?GetDefLang@CLangMngr@@QBEHXZ
_TEXT	SEGMENT
?GetDefLang@CLangMngr@@QBEHXZ PROC			; CLangMngr::GetDefLang, COMDAT
; _this$ = ecx

; 160  : 	inline int GetDefLang() const { return m_CurGlobId; }

	mov	eax, DWORD PTR [ecx+68]
	ret	0
?GetDefLang@CLangMngr@@QBEHXZ ENDP			; CLangMngr::GetDefLang
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\clang.h
;	COMDAT ??0lang_err@@QAE@XZ
_TEXT	SEGMENT
??0lang_err@@QAE@XZ PROC				; lang_err::lang_err, COMDAT
; _this$ = ecx

; 31   : 	lang_err() : last(0.0f)

	mov	DWORD PTR [ecx], 0

; 33   : 	};

	mov	eax, ecx
	ret	0
??0lang_err@@QAE@XZ ENDP				; lang_err::lang_err
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const *>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

	ret	0
??$__vcrt_va_start_verify_argument_type@PBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
;	COMDAT ?SafeSprintf@ke@@YAIPADIPBDZZ
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_maxlength$ = 12					; size = 4
_fmt$ = 16						; size = 4
?SafeSprintf@ke@@YAIPADIPBDZZ PROC			; ke::SafeSprintf, COMDAT

; 172  : {

	push	esi

; 151  :   if (!maxlength)

	mov	esi, DWORD PTR _maxlength$[esp]
	test	esi, esi
	jne	SHORT $LN4@SafeSprint

; 173  :   va_list ap;
; 174  :   va_start(ap, fmt);
; 175  :   size_t len = SafeVsprintf(buffer, maxlength, fmt, ap);
; 176  :   va_end(ap);
; 177  :   return len;

	xor	eax, eax
	pop	esi

; 178  : }

	ret	0
$LN4@SafeSprint:
	push	edi
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h

; 1386 :     int const _Result = __stdio_common_vsprintf(

	mov	edi, DWORD PTR _buffer$[esp+4]
	lea	eax, DWORD PTR _fmt$[esp+8]
	push	eax
	push	0
	push	DWORD PTR _fmt$[esp+12]
	push	esi
	push	edi
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 162  :   if (len >= maxlength) {

	cmp	eax, esi
	jb	SHORT $LN11@SafeSprint

; 163  :     buffer[maxlength - 1] = '\0';

	mov	BYTE PTR [edi+esi-1], 0

; 164  :     return maxlength - 1;

	lea	eax, DWORD PTR [esi-1]
$LN11@SafeSprint:
	pop	edi
	pop	esi

; 178  : }

	ret	0
?SafeSprintf@ke@@YAIPADIPBDZZ ENDP			; ke::SafeSprintf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
;	COMDAT ?SafeVsprintf@ke@@YAIPADIPBD0@Z
_TEXT	SEGMENT
_buffer$ = 8						; size = 4
_maxlength$ = 12					; size = 4
_fmt$ = 16						; size = 4
_ap$ = 20						; size = 4
?SafeVsprintf@ke@@YAIPADIPBD0@Z PROC			; ke::SafeVsprintf, COMDAT

; 150  : {

	push	esi

; 151  :   if (!maxlength)

	mov	esi, DWORD PTR _maxlength$[esp]
	test	esi, esi
	jne	SHORT $LN2@SafeVsprin

; 152  :     return 0;

	xor	eax, eax
	pop	esi

; 165  :   }
; 166  : 
; 167  :   return len;
; 168  : }

	ret	0
$LN2@SafeVsprin:
	push	edi
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h

; 1386 :     int const _Result = __stdio_common_vsprintf(

	push	DWORD PTR _ap$[esp+4]
	mov	edi, DWORD PTR _buffer$[esp+8]
	push	0
	push	DWORD PTR _fmt$[esp+12]
	push	esi
	push	edi
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 162  :   if (len >= maxlength) {

	cmp	eax, esi
	jb	SHORT $LN9@SafeVsprin

; 163  :     buffer[maxlength - 1] = '\0';

	mov	BYTE PTR [edi+esi-1], 0

; 164  :     return maxlength - 1;

	lea	eax, DWORD PTR [esi-1]
$LN9@SafeVsprin:

; 165  :   }
; 166  : 
; 167  :   return len;
; 168  : }

	pop	edi
	pop	esi
	ret	0
?SafeVsprintf@ke@@YAIPADIPBD0@Z ENDP			; ke::SafeVsprintf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
;	COMDAT ??1AString@ke@@QAE@XZ
_TEXT	SEGMENT
??1AString@ke@@QAE@XZ PROC				; ke::AString::~AString, COMDAT
; _this$ = ecx

; 126  :       delete [] t_;

	push	DWORD PTR [ecx]
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
??1AString@ke@@QAE@XZ ENDP				; ke::AString::~AString
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
;	COMDAT ??4?$AutoArray@D@ke@@QAEAAV01@PAD@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
??4?$AutoArray@D@ke@@QAEAAV01@PAD@Z PROC		; ke::AutoArray<char>::operator=, COMDAT
; _this$ = ecx

; 150  :   AutoArray& operator =(T *t) {

	push	esi
	mov	esi, ecx

; 151  :       delete [] t_;

	push	DWORD PTR [esi]
	call	??_V@YAXPAX@Z				; operator delete[]

; 152  :       t_ = t;

	mov	eax, DWORD PTR _t$[esp+4]
	add	esp, 4
	mov	DWORD PTR [esi], eax

; 153  :       return *this;

	mov	eax, esi
	pop	esi

; 154  :   }

	ret	4
??4?$AutoArray@D@ke@@QAEAAV01@PAD@Z ENDP		; ke::AutoArray<char>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
;	COMDAT ??7?$AutoArray@D@ke@@QBE_NXZ
_TEXT	SEGMENT
??7?$AutoArray@D@ke@@QBE_NXZ PROC			; ke::AutoArray<char>::operator!, COMDAT
; _this$ = ecx

; 143  :   bool operator !() const {

	cmp	DWORD PTR [ecx], 0
	sete	al

; 144  :       return !t_;
; 145  :   }

	ret	0
??7?$AutoArray@D@ke@@QBE_NXZ ENDP			; ke::AutoArray<char>::operator!
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
;	COMDAT ??B?$AutoArray@D@ke@@QBEPADXZ
_TEXT	SEGMENT
??B?$AutoArray@D@ke@@QBEPADXZ PROC			; ke::AutoArray<char>::operator char *, COMDAT
; _this$ = ecx

; 141  :       return t_;

	mov	eax, DWORD PTR [ecx]

; 142  :   }

	ret	0
??B?$AutoArray@D@ke@@QBEPADXZ ENDP			; ke::AutoArray<char>::operator char *
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
;	COMDAT ??1?$AutoArray@D@ke@@QAE@XZ
_TEXT	SEGMENT
??1?$AutoArray@D@ke@@QAE@XZ PROC			; ke::AutoArray<char>::~AutoArray<char>, COMDAT
; _this$ = ecx

; 126  :       delete [] t_;

	push	DWORD PTR [ecx]
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx

; 127  :   }

	ret	0
??1?$AutoArray@D@ke@@QAE@XZ ENDP			; ke::AutoArray<char>::~AutoArray<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
;	COMDAT ??0?$AutoArray@D@ke@@QAE@XZ
_TEXT	SEGMENT
??0?$AutoArray@D@ke@@QAE@XZ PROC			; ke::AutoArray<char>::AutoArray<char>, COMDAT
; _this$ = ecx

; 113  :    : t_(nullptr)

	mov	DWORD PTR [ecx], 0

; 115  :   }

	mov	eax, ecx
	ret	0
??0?$AutoArray@D@ke@@QAE@XZ ENDP			; ke::AutoArray<char>::AutoArray<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
;	COMDAT ?set@AString@ke@@AAEXPBDI@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
_length$ = 12						; size = 4
?set@AString@ke@@AAEXPBDI@Z PROC			; ke::AString::set, COMDAT
; _this$ = ecx

; 136  :   void set(const char *str, size_t length) {

	push	ebx
	push	esi
	push	edi

; 137  :     chars_ = new char[length + 1];

	mov	edi, DWORD PTR _length$[esp+8]
	mov	ebx, ecx
	lea	eax, DWORD PTR [edi+1]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 151  :       delete [] t_;

	push	DWORD PTR [ebx]
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 137  :     chars_ = new char[length + 1];

	mov	esi, eax
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 151  :       delete [] t_;

	call	??_V@YAXPAX@Z				; operator delete[]
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 139  :     memcpy(chars_, str, length);

	push	edi
	push	DWORD PTR _str$[esp+20]
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 152  :       t_ = t;

	mov	DWORD PTR [ebx], esi
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 139  :     memcpy(chars_, str, length);

	push	DWORD PTR [ebx]
	mov	DWORD PTR [ebx+4], edi
	call	_memcpy

; 140  :     chars_[length] = '\0';

	mov	eax, DWORD PTR [ebx]
	add	esp, 20					; 00000014H
	mov	BYTE PTR [edi+eax], 0
	pop	edi
	pop	esi
	pop	ebx

; 141  :   }

	ret	8
?set@AString@ke@@AAEXPBDI@Z ENDP			; ke::AString::set
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
;	COMDAT ?chars@AString@ke@@QBEPBDXZ
_TEXT	SEGMENT
?chars@AString@ke@@QBEPBDXZ PROC			; ke::AString::chars, COMDAT
; _this$ = ecx
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 144  :       return !t_;

	mov	ecx, DWORD PTR [ecx]
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 128  :     if (!chars_)

	mov	eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 144  :       return !t_;

	test	ecx, ecx
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 128  :     if (!chars_)

	cmovne	eax, ecx

; 129  :       return "";
; 130  :     return chars_;
; 131  :   }

	ret	0
?chars@AString@ke@@QBEPBDXZ ENDP			; ke::AString::chars
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
;	COMDAT ??0AString@ke@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_length$1$ = 8						; size = 4
_other$ = 8						; size = 4
??0AString@ke@@QAE@ABV01@@Z PROC			; ke::AString::AString, COMDAT
; _this$ = ecx

; 69   :   AString(const AString &other) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0AString@ke@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	DWORD PTR _this$[ebp], ebx
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 113  :    : t_(nullptr)

	mov	DWORD PTR [ebx], 0
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 70   :     if (other.length_)

	mov	edi, DWORD PTR _other$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR _length$1$[ebp], eax
	test	eax, eax
	je	SHORT $LN2@AString
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 141  :       return t_;

	mov	edi, DWORD PTR [edi]
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 137  :     chars_ = new char[length + 1];

	inc	eax
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 151  :       delete [] t_;

	push	DWORD PTR [ebx]
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 137  :     chars_ = new char[length + 1];

	mov	esi, eax
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 151  :       delete [] t_;

	call	??_V@YAXPAX@Z				; operator delete[]

; 152  :       t_ = t;

	mov	DWORD PTR [ebx], esi
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 138  :     length_ = length;

	mov	esi, DWORD PTR _length$1$[ebp]

; 139  :     memcpy(chars_, str, length);

	push	esi
	push	edi
	push	DWORD PTR [ebx]
	mov	DWORD PTR [ebx+4], esi
	call	_memcpy

; 140  :     chars_[length] = '\0';

	mov	eax, DWORD PTR [ebx]
	add	esp, 20					; 00000014H
	mov	BYTE PTR [esi+eax], 0

; 71   :       set(other.chars_, other.length_);
; 72   :     else

	jmp	SHORT $LN19@AString
$LN2@AString:

; 73   :       length_ = 0;

	mov	DWORD PTR [ebx+4], 0
$LN19@AString:

; 74   :   }

	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0AString@ke@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$AutoArray@D@ke@@QAE@XZ		; ke::AutoArray<char>::~AutoArray<char>
__ehhandler$??0AString@ke@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0AString@ke@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0AString@ke@@QAE@ABV01@@Z ENDP			; ke::AString::AString
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h
; File e:\nightfire_sdk\amx\public\amtl\am-string.h
;	COMDAT ??0AString@ke@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_str$ = 8						; size = 4
??0AString@ke@@QAE@PBD@Z PROC				; ke::AString::AString, COMDAT
; _this$ = ecx

; 58   :   explicit AString(const char *str) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0AString@ke@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	DWORD PTR _this$[ebp], ebx
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 113  :    : t_(nullptr)

	mov	DWORD PTR [ebx], 0
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 59   :     if (str && str[0]) {

	mov	eax, DWORD PTR _str$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN2@AString
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN2@AString

; 60   :       set(str, strlen(str));

	mov	esi, eax
	lea	ecx, DWORD PTR [esi+1]
	npad	7
$LL18@AString:
	mov	al, BYTE PTR [esi]
	inc	esi
	test	al, al
	jne	SHORT $LL18@AString
	sub	esi, ecx

; 137  :     chars_ = new char[length + 1];

	lea	eax, DWORD PTR [esi+1]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 151  :       delete [] t_;

	push	DWORD PTR [ebx]
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 137  :     chars_ = new char[length + 1];

	mov	edi, eax
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 151  :       delete [] t_;

	call	??_V@YAXPAX@Z				; operator delete[]
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 139  :     memcpy(chars_, str, length);

	push	esi
	push	DWORD PTR _str$[ebp]
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 152  :       t_ = t;

	mov	DWORD PTR [ebx], edi
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 139  :     memcpy(chars_, str, length);

	push	DWORD PTR [ebx]
	mov	DWORD PTR [ebx+4], esi
	call	_memcpy

; 140  :     chars_[length] = '\0';

	mov	eax, DWORD PTR [ebx]
	add	esp, 20					; 00000014H
	mov	BYTE PTR [esi+eax], 0

; 61   :     } else {

	jmp	SHORT $LN20@AString
$LN2@AString:
; File e:\nightfire_sdk\amx\public\amtl\am-autoptr.h

; 151  :       delete [] t_;

	push	0
	call	??_V@YAXPAX@Z				; operator delete[]

; 152  :       t_ = t;

	mov	DWORD PTR [ebx], 0
	add	esp, 4
; File e:\nightfire_sdk\amx\public\amtl\am-string.h

; 63   :       length_ = 0;

	mov	DWORD PTR [ebx+4], 0
$LN20@AString:

; 64   :     }
; 65   :   }

	mov	eax, ebx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0AString@ke@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$AutoArray@D@ke@@QAE@XZ		; ke::AutoArray<char>::~AutoArray<char>
__ehhandler$??0AString@ke@@QAE@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0AString@ke@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0AString@ke@@QAE@PBD@Z ENDP				; ke::AString::AString
; Function compile flags: /Ogtpy
; File e:\f\metamod\metamod-hl1-master\metamod\sdk_util.h
;	COMDAT ?ENTITY_KEYVALUE@@YAPADPAUedict_s@@PBD@Z
_TEXT	SEGMENT
_entity$ = 8						; size = 4
_key$ = 12						; size = 4
?ENTITY_KEYVALUE@@YAPADPAUedict_s@@PBD@Z PROC		; ENTITY_KEYVALUE, COMDAT

; 72   : 	char *ifbuf=GET_INFOKEYBUFFER(entity);

	push	DWORD PTR _entity$[esp-4]
	call	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+440
	add	esp, 4

; 73   : 	return(INFOKEY_VALUE(ifbuf, key));

	mov	DWORD PTR _entity$[esp-4], eax
	jmp	DWORD PTR ?g_engfuncs@@3Uenginefuncs_s@@A+444
?ENTITY_KEYVALUE@@YAPADPAUedict_s@@PBD@Z ENDP		; ENTITY_KEYVALUE
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsnprintf PROC					; COMDAT

; 1386 :     int const _Result = __stdio_common_vsprintf(

	push	DWORD PTR __ArgList$[esp-4]
	push	0
	push	DWORD PTR __Format$[esp+4]
	push	DWORD PTR __BufferCount$[esp+8]
	push	DWORD PTR __Buffer$[esp+12]
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1406 :     #pragma warning(push)
; 1407 :     #pragma warning(disable: 4996) // Deprecation
; 1408 :     return _vsnprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1409 :     #pragma warning(pop)
; 1410 : }

	ret	0
__vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1386 :     int const _Result = __stdio_common_vsprintf(

	push	DWORD PTR __ArgList$[esp-4]
	push	DWORD PTR __Locale$[esp]
	push	DWORD PTR __Format$[esp+4]
	push	DWORD PTR __BufferCount$[esp+8]
	push	DWORD PTR __Buffer$[esp+12]
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1391 : }

	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
