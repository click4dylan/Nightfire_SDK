; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	E:\nightfire_sdk\amx\amxmodx\string.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CE@BPGCCENF@Invalid?5vararg?5parameter?5passed?3@ ; `string'
PUBLIC	??_C@_03BDGOHNNK@add?$AA@			; `string'
PUBLIC	??_C@_07LIAJLFAH@contain?$AA@			; `string'
PUBLIC	??_C@_08CKODEMPI@containi?$AA@			; `string'
PUBLIC	??_C@_04COAGEIMF@copy?$AA@			; `string'
PUBLIC	??_C@_05KFPAAIBD@copyc?$AA@			; `string'
PUBLIC	??_C@_05OAKNMNI@equal?$AA@			; `string'
PUBLIC	??_C@_06DMDJIANE@equali?$AA@			; `string'
PUBLIC	??_C@_03MLKKGMLN@fmt?$AA@			; `string'
PUBLIC	??_C@_06DLEPGFEF@format?$AA@			; `string'
PUBLIC	??_C@_08BJCMOPON@formatex?$AA@			; `string'
PUBLIC	??_C@_0M@KKJIOJF@format_args?$AA@		; `string'
PUBLIC	??_C@_07CFBKIKCH@isdigit?$AA@			; `string'
PUBLIC	??_C@_07EOADCIGC@isalnum?$AA@			; `string'
PUBLIC	??_C@_07CNBMLEON@isspace?$AA@			; `string'
PUBLIC	??_C@_07EGIOHHOB@isalpha?$AA@			; `string'
PUBLIC	??_C@_0O@KEPPMDBB@is_char_upper?$AA@		; `string'
PUBLIC	??_C@_0O@PPEBKIKI@is_char_lower?$AA@		; `string'
PUBLIC	??_C@_0L@CNFJNCLK@is_char_mb?$AA@		; `string'
PUBLIC	??_C@_0P@KJJEJCPJ@get_char_bytes?$AA@		; `string'
PUBLIC	??_C@_0L@MLCNPPEP@num_to_str?$AA@		; `string'
PUBLIC	??_C@_08DPCMHIHH@numtostr?$AA@			; `string'
PUBLIC	??_C@_05GOEGCMJM@parse?$AA@			; `string'
PUBLIC	??_C@_07CLEHDIEJ@replace?$AA@			; `string'
PUBLIC	??_C@_0P@MIKGGNGL@replace_string?$AA@		; `string'
PUBLIC	??_C@_0BB@BMPAJNBK@replace_stringex?$AA@	; `string'
PUBLIC	??_C@_04JGHPGNCE@setc?$AA@			; `string'
PUBLIC	??_C@_08IGPPEDJN@strbreak?$AA@			; `string'
PUBLIC	??_C@_08NCPBOIPA@argparse?$AA@			; `string'
PUBLIC	??_C@_0N@GFHAOFDI@split_string?$AA@		; `string'
PUBLIC	??_C@_0L@EGACLCBB@strtolower?$AA@		; `string'
PUBLIC	??_C@_0L@BNLMNJKI@strtoupper?$AA@		; `string'
PUBLIC	??_C@_0L@FMBPHLPG@str_to_num?$AA@		; `string'
PUBLIC	??_C@_08FBHENKAD@strtonum?$AA@			; `string'
PUBLIC	??_C@_06MCCMIJDC@strtol?$AA@			; `string'
PUBLIC	??_C@_06DIMDGBLI@strtof?$AA@			; `string'
PUBLIC	??_C@_04GDOMMDLP@trim?$AA@			; `string'
PUBLIC	??_C@_07FCGOBCIN@ucfirst?$AA@			; `string'
PUBLIC	??_C@_06INGNBPPF@strtok?$AA@			; `string'
PUBLIC	??_C@_07CACKDPPN@strtok2?$AA@			; `string'
PUBLIC	??_C@_06GICABBBG@strlen?$AA@			; `string'
PUBLIC	??_C@_06IHGHFDEH@strcat?$AA@			; `string'
PUBLIC	??_C@_07PFELJMPK@strfind?$AA@			; `string'
PUBLIC	??_C@_06OKBBGPCH@strcmp?$AA@			; `string'
PUBLIC	??_C@_07IGGOFOFD@strncmp?$AA@			; `string'
PUBLIC	??_C@_0N@KMNNBAGA@str_to_float?$AA@		; `string'
PUBLIC	??_C@_0N@MDDICGFD@float_to_str?$AA@		; `string'
PUBLIC	??_C@_07KJDOPNEF@vformat?$AA@			; `string'
PUBLIC	??_C@_0BM@KJALMONH@No?5search?5string?5specified?4?$AA@ ; `string'
PUBLIC	??_C@_0CJ@NFNJDNGL@replace?$CI?$CJ?5buffer?5not?5big?5enough?5@ ; `string'
PUBLIC	??_C@_0CK@IBLGDDPF@Cannot?5replace?5searches?5of?5empty@ ; `string'
PUBLIC	??_C@_02NJPGOMH@?$CFf?$AA@			; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	?string_Natives@@3PAUtagAMX_NATIVE_INFO@@A	; string_Natives
PUBLIC	??_C@_0CA@BOKAAEHK@Pos?5has?5to?5be?5a?5positive?5number?$AA@ ; `string'
;	COMDAT ?cpbuf@?1??vformat@@YAHPAUtagAMX@@PAH@Z@4PAHA
_BSS	SEGMENT
?cpbuf@?1??vformat@@YAHPAUtagAMX@@PAH@Z@4PAHA DD 01000H DUP (?) ; `vformat'::`2'::cpbuf
_BSS	ENDS
_BSS	SEGMENT
?g_cpbuf@@3PAHA DD 01000H DUP (?)			; g_cpbuf
_BSS	ENDS
;	COMDAT ??_C@_0CA@BOKAAEHK@Pos?5has?5to?5be?5a?5positive?5number?$AA@
CONST	SEGMENT
??_C@_0CA@BOKAAEHK@Pos?5has?5to?5be?5a?5positive?5number?$AA@ DB 'Pos has'
	DB	' to be a positive number', 00H		; `string'
CONST	ENDS
_DATA	SEGMENT
?string_Natives@@3PAUtagAMX_NATIVE_INFO@@A DD FLAT:??_C@_03BDGOHNNK@add?$AA@ ; string_Natives
	DD	FLAT:?add@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_07LIAJLFAH@contain?$AA@
	DD	FLAT:?contain@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_08CKODEMPI@containi?$AA@
	DD	FLAT:?containi@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_04COAGEIMF@copy?$AA@
	DD	FLAT:?copy@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_05KFPAAIBD@copyc?$AA@
	DD	FLAT:?copyc@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_05OAKNMNI@equal?$AA@
	DD	FLAT:?equal@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_06DMDJIANE@equali?$AA@
	DD	FLAT:?equali@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_03MLKKGMLN@fmt?$AA@
	DD	FLAT:?fmt@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_06DLEPGFEF@format?$AA@
	DD	FLAT:?format@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_08BJCMOPON@formatex?$AA@
	DD	FLAT:?formatex@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0M@KKJIOJF@format_args?$AA@
	DD	FLAT:?format_args@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_07CFBKIKCH@isdigit?$AA@
	DD	FLAT:?is_digit@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_07EOADCIGC@isalnum?$AA@
	DD	FLAT:?is_alnum@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_07CNBMLEON@isspace?$AA@
	DD	FLAT:?is_space@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_07EGIOHHOB@isalpha?$AA@
	DD	FLAT:?is_alpha@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0O@KEPPMDBB@is_char_upper?$AA@
	DD	FLAT:?is_char_upper@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0O@PPEBKIKI@is_char_lower?$AA@
	DD	FLAT:?is_char_lower@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0L@CNFJNCLK@is_char_mb?$AA@
	DD	FLAT:?is_char_mb@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0P@KJJEJCPJ@get_char_bytes?$AA@
	DD	FLAT:?get_char_bytes@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0L@MLCNPPEP@num_to_str?$AA@
	DD	FLAT:?numtostr@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_08DPCMHIHH@numtostr?$AA@
	DD	FLAT:?numtostr@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_05GOEGCMJM@parse?$AA@
	DD	FLAT:?parse@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_07CLEHDIEJ@replace?$AA@
	DD	FLAT:?replace@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0P@MIKGGNGL@replace_string?$AA@
	DD	FLAT:?replace_string@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0BB@BMPAJNBK@replace_stringex?$AA@
	DD	FLAT:?replace_stringex@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_04JGHPGNCE@setc?$AA@
	DD	FLAT:?setc@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_08IGPPEDJN@strbreak?$AA@
	DD	FLAT:?strbreak@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_08NCPBOIPA@argparse?$AA@
	DD	FLAT:?argparse@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0N@GFHAOFDI@split_string?$AA@
	DD	FLAT:?split_string@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0L@EGACLCBB@strtolower?$AA@
	DD	FLAT:?strtolower@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0L@BNLMNJKI@strtoupper?$AA@
	DD	FLAT:?strtoupper@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0L@FMBPHLPG@str_to_num?$AA@
	DD	FLAT:?strtonum@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_08FBHENKAD@strtonum?$AA@
	DD	FLAT:?strtonum@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_06MCCMIJDC@strtol?$AA@
	DD	FLAT:?amx_strtol@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_06DIMDGBLI@strtof?$AA@
	DD	FLAT:?amx_strtof@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_04GDOMMDLP@trim?$AA@
	DD	FLAT:?amx_trim@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_07FCGOBCIN@ucfirst?$AA@
	DD	FLAT:?amx_ucfirst@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_06INGNBPPF@strtok?$AA@
	DD	FLAT:?amx_strtok@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_07CACKDPPN@strtok2?$AA@
	DD	FLAT:?amx_strtok2@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_06GICABBBG@strlen?$AA@
	DD	FLAT:?amx_strlen@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_06IHGHFDEH@strcat?$AA@
	DD	FLAT:?n_strcat@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_07PFELJMPK@strfind?$AA@
	DD	FLAT:?n_strfind@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_06OKBBGPCH@strcmp?$AA@
	DD	FLAT:?n_strcmp@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_07IGGOFOFD@strncmp?$AA@
	DD	FLAT:?n_strncmp@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0N@KMNNBAGA@str_to_float?$AA@
	DD	FLAT:?str_to_float@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_0N@MDDICGFD@float_to_str?$AA@
	DD	FLAT:?float_to_str@@YAHPAUtagAMX@@PAH@Z
	DD	FLAT:??_C@_07KJDOPNEF@vformat?$AA@
	DD	FLAT:?vformat@@YAHPAUtagAMX@@PAH@Z
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJPGOMH@?$CFf?$AA@
CONST	SEGMENT
??_C@_02NJPGOMH@?$CFf?$AA@ DB '%f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@IBLGDDPF@Cannot?5replace?5searches?5of?5empty@
CONST	SEGMENT
??_C@_0CK@IBLGDDPF@Cannot?5replace?5searches?5of?5empty@ DB 'Cannot repla'
	DB	'ce searches of empty strings.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@NFNJDNGL@replace?$CI?$CJ?5buffer?5not?5big?5enough?5@
CONST	SEGMENT
??_C@_0CJ@NFNJDNGL@replace?$CI?$CJ?5buffer?5not?5big?5enough?5@ DB 'repla'
	DB	'ce() buffer not big enough (%d>=%d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KJALMONH@No?5search?5string?5specified?4?$AA@
CONST	SEGMENT
??_C@_0BM@KJALMONH@No?5search?5string?5specified?4?$AA@ DB 'No search str'
	DB	'ing specified.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07KJDOPNEF@vformat?$AA@
CONST	SEGMENT
??_C@_07KJDOPNEF@vformat?$AA@ DB 'vformat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MDDICGFD@float_to_str?$AA@
CONST	SEGMENT
??_C@_0N@MDDICGFD@float_to_str?$AA@ DB 'float_to_str', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KMNNBAGA@str_to_float?$AA@
CONST	SEGMENT
??_C@_0N@KMNNBAGA@str_to_float?$AA@ DB 'str_to_float', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IGGOFOFD@strncmp?$AA@
CONST	SEGMENT
??_C@_07IGGOFOFD@strncmp?$AA@ DB 'strncmp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06OKBBGPCH@strcmp?$AA@
CONST	SEGMENT
??_C@_06OKBBGPCH@strcmp?$AA@ DB 'strcmp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07PFELJMPK@strfind?$AA@
CONST	SEGMENT
??_C@_07PFELJMPK@strfind?$AA@ DB 'strfind', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06IHGHFDEH@strcat?$AA@
CONST	SEGMENT
??_C@_06IHGHFDEH@strcat?$AA@ DB 'strcat', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06GICABBBG@strlen?$AA@
CONST	SEGMENT
??_C@_06GICABBBG@strlen?$AA@ DB 'strlen', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CACKDPPN@strtok2?$AA@
CONST	SEGMENT
??_C@_07CACKDPPN@strtok2?$AA@ DB 'strtok2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06INGNBPPF@strtok?$AA@
CONST	SEGMENT
??_C@_06INGNBPPF@strtok?$AA@ DB 'strtok', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07FCGOBCIN@ucfirst?$AA@
CONST	SEGMENT
??_C@_07FCGOBCIN@ucfirst?$AA@ DB 'ucfirst', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GDOMMDLP@trim?$AA@
CONST	SEGMENT
??_C@_04GDOMMDLP@trim?$AA@ DB 'trim', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DIMDGBLI@strtof?$AA@
CONST	SEGMENT
??_C@_06DIMDGBLI@strtof?$AA@ DB 'strtof', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06MCCMIJDC@strtol?$AA@
CONST	SEGMENT
??_C@_06MCCMIJDC@strtol?$AA@ DB 'strtol', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08FBHENKAD@strtonum?$AA@
CONST	SEGMENT
??_C@_08FBHENKAD@strtonum?$AA@ DB 'strtonum', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FMBPHLPG@str_to_num?$AA@
CONST	SEGMENT
??_C@_0L@FMBPHLPG@str_to_num?$AA@ DB 'str_to_num', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BNLMNJKI@strtoupper?$AA@
CONST	SEGMENT
??_C@_0L@BNLMNJKI@strtoupper?$AA@ DB 'strtoupper', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@EGACLCBB@strtolower?$AA@
CONST	SEGMENT
??_C@_0L@EGACLCBB@strtolower?$AA@ DB 'strtolower', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GFHAOFDI@split_string?$AA@
CONST	SEGMENT
??_C@_0N@GFHAOFDI@split_string?$AA@ DB 'split_string', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08NCPBOIPA@argparse?$AA@
CONST	SEGMENT
??_C@_08NCPBOIPA@argparse?$AA@ DB 'argparse', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08IGPPEDJN@strbreak?$AA@
CONST	SEGMENT
??_C@_08IGPPEDJN@strbreak?$AA@ DB 'strbreak', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04JGHPGNCE@setc?$AA@
CONST	SEGMENT
??_C@_04JGHPGNCE@setc?$AA@ DB 'setc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BMPAJNBK@replace_stringex?$AA@
CONST	SEGMENT
??_C@_0BB@BMPAJNBK@replace_stringex?$AA@ DB 'replace_stringex', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MIKGGNGL@replace_string?$AA@
CONST	SEGMENT
??_C@_0P@MIKGGNGL@replace_string?$AA@ DB 'replace_string', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CLEHDIEJ@replace?$AA@
CONST	SEGMENT
??_C@_07CLEHDIEJ@replace?$AA@ DB 'replace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05GOEGCMJM@parse?$AA@
CONST	SEGMENT
??_C@_05GOEGCMJM@parse?$AA@ DB 'parse', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08DPCMHIHH@numtostr?$AA@
CONST	SEGMENT
??_C@_08DPCMHIHH@numtostr?$AA@ DB 'numtostr', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MLCNPPEP@num_to_str?$AA@
CONST	SEGMENT
??_C@_0L@MLCNPPEP@num_to_str?$AA@ DB 'num_to_str', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KJJEJCPJ@get_char_bytes?$AA@
CONST	SEGMENT
??_C@_0P@KJJEJCPJ@get_char_bytes?$AA@ DB 'get_char_bytes', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CNFJNCLK@is_char_mb?$AA@
CONST	SEGMENT
??_C@_0L@CNFJNCLK@is_char_mb?$AA@ DB 'is_char_mb', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@PPEBKIKI@is_char_lower?$AA@
CONST	SEGMENT
??_C@_0O@PPEBKIKI@is_char_lower?$AA@ DB 'is_char_lower', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KEPPMDBB@is_char_upper?$AA@
CONST	SEGMENT
??_C@_0O@KEPPMDBB@is_char_upper?$AA@ DB 'is_char_upper', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07EGIOHHOB@isalpha?$AA@
CONST	SEGMENT
??_C@_07EGIOHHOB@isalpha?$AA@ DB 'isalpha', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CNBMLEON@isspace?$AA@
CONST	SEGMENT
??_C@_07CNBMLEON@isspace?$AA@ DB 'isspace', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07EOADCIGC@isalnum?$AA@
CONST	SEGMENT
??_C@_07EOADCIGC@isalnum?$AA@ DB 'isalnum', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07CFBKIKCH@isdigit?$AA@
CONST	SEGMENT
??_C@_07CFBKIKCH@isdigit?$AA@ DB 'isdigit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KKJIOJF@format_args?$AA@
CONST	SEGMENT
??_C@_0M@KKJIOJF@format_args?$AA@ DB 'format_args', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BJCMOPON@formatex?$AA@
CONST	SEGMENT
??_C@_08BJCMOPON@formatex?$AA@ DB 'formatex', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06DLEPGFEF@format?$AA@
CONST	SEGMENT
??_C@_06DLEPGFEF@format?$AA@ DB 'format', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MLKKGMLN@fmt?$AA@
CONST	SEGMENT
??_C@_03MLKKGMLN@fmt?$AA@ DB 'fmt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06DMDJIANE@equali?$AA@
CONST	SEGMENT
??_C@_06DMDJIANE@equali?$AA@ DB 'equali', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05OAKNMNI@equal?$AA@
CONST	SEGMENT
??_C@_05OAKNMNI@equal?$AA@ DB 'equal', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KFPAAIBD@copyc?$AA@
CONST	SEGMENT
??_C@_05KFPAAIBD@copyc?$AA@ DB 'copyc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04COAGEIMF@copy?$AA@
CONST	SEGMENT
??_C@_04COAGEIMF@copy?$AA@ DB 'copy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08CKODEMPI@containi?$AA@
CONST	SEGMENT
??_C@_08CKODEMPI@containi?$AA@ DB 'containi', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LIAJLFAH@contain?$AA@
CONST	SEGMENT
??_C@_07LIAJLFAH@contain?$AA@ DB 'contain', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03BDGOHNNK@add?$AA@
CONST	SEGMENT
??_C@_03BDGOHNNK@add?$AA@ DB 'add', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@BPGCCENF@Invalid?5vararg?5parameter?5passed?3@
CONST	SEGMENT
??_C@_0CE@BPGCCENF@Invalid?5vararg?5parameter?5passed?3@ DB 'Invalid vara'
	DB	'rg parameter passed: %d', 00H		; `string'
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_sprintf
PUBLIC	?stristr@@YAPBDPBD0@Z				; stristr
PUBLIC	?get_amxaddr@@YAPAHPAUtagAMX@@H@Z		; get_amxaddr
PUBLIC	?format_amxstring@@YAPADPAUtagAMX@@PAHHAAH@Z	; format_amxstring
PUBLIC	?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z		; get_amxstring
PUBLIC	?get_amxstring_null@@YAPADPAUtagAMX@@HHAAH@Z	; get_amxstring_null
PUBLIC	?get_amxvector_null@@YAPAHPAUtagAMX@@H@Z	; get_amxvector_null
PUBLIC	_get_amxstring_r
PUBLIC	?amxstring_len@@YAHPAH@Z			; amxstring_len
PUBLIC	?set_amxstring@@YAHPAUtagAMX@@HPBDH@Z		; set_amxstring
PUBLIC	?set_amxstring_simple@@YAHPAHPBDH@Z		; set_amxstring_simple
PUBLIC	?set_amxstring_utf8_char@@YAHPAUtagAMX@@HPBDII@Z ; set_amxstring_utf8_char
PUBLIC	?set_amxstring_utf8_cell@@YAHPAUtagAMX@@HPBHII@Z ; set_amxstring_utf8_cell
PUBLIC	?copy_amxmemory@@YAXPAH0H@Z			; copy_amxmemory
PUBLIC	??$set_amxstring_utf8@H@@YAHPAUtagAMX@@HPBHII@Z	; set_amxstring_utf8<int>
PUBLIC	??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z	; set_amxstring_utf8<char>
PUBLIC	?parse_arg@@YAPADPAPADAAH@Z			; parse_arg
PUBLIC	?fastcellcmp@@YA_NPAH0H@Z			; fastcellcmp
PUBLIC	?fo_numargs@@YAHPAUtagAMX@@@Z			; fo_numargs
PUBLIC	?fo_getargnum@@YAHPAUtagAMX@@H@Z		; fo_getargnum
PUBLIC	?fo_getargfloat@@YAMPAUtagAMX@@H@Z		; fo_getargfloat
PUBLIC	?fo_getargstr@@YAPADPAUtagAMX@@HH@Z		; fo_getargstr
PUBLIC	?format_arguments@@YAPADPAUtagAMX@@HAAH@Z	; format_arguments
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_isalpha:PROC
EXTRN	_isupper:PROC
EXTRN	_islower:PROC
EXTRN	_isdigit:PROC
EXTRN	_isspace:PROC
EXTRN	_isalnum:PROC
EXTRN	_toupper:PROC
EXTRN	_tolower:PROC
EXTRN	_memmove:PROC
EXTRN	_strstr:PROC
EXTRN	__stricmp:PROC
EXTRN	_strncmp:PROC
EXTRN	__strnicmp:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_atoi:PROC
EXTRN	_strtod:PROC
EXTRN	_strtol:PROC
EXTRN	?FormatAmxString@CLangMngr@@QAEPADPAUtagAMX@@PAHHAAH@Z:PROC ; CLangMngr::FormatAmxString
EXTRN	?UTIL_GetUTF8CharBytes@@YAIPBD@Z:PROC		; UTIL_GetUTF8CharBytes
EXTRN	?UTIL_ReplaceAll@@YAIPADIPBD1_N@Z:PROC		; UTIL_ReplaceAll
EXTRN	?UTIL_ReplaceEx@@YAPADPADIPBDI1I_N@Z:PROC	; UTIL_ReplaceEx
EXTRN	?UTIL_TrimLeft@@YAXPAD@Z:PROC			; UTIL_TrimLeft
EXTRN	?UTIL_TrimRight@@YAXPAD@Z:PROC			; UTIL_TrimRight
EXTRN	_LogError:PROC
EXTRN	??$atcprintf@HH@@YAIPAHIPBHPAUtagAMX@@00@Z:PROC	; atcprintf<int,int>
EXTRN	??$UTIL_CheckValidChar@H@@YAHPAH@Z:PROC		; UTIL_CheckValidChar<int>
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memcpy:PROC
EXTRN	?g_langMngr@@3VCLangMngr@@A:BYTE		; g_langMngr
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?buffer@?1??get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z@4PAY0EAAA@DA
_BSS	SEGMENT
?buffer@?1??get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z@4PAY0EAAA@DA DB 010000H DUP (?) ; `get_amxstring'::`2'::buffer
_BSS	ENDS
;	COMDAT ?arg@?1??parse_arg@@YAPADPAPADAAH@Z@4PADA
_BSS	SEGMENT
?arg@?1??parse_arg@@YAPADPAPADAAH@Z@4PADA DB 0c00H DUP (?) ; `parse_arg'::`2'::arg
_BSS	ENDS
;	COMDAT ?buffer@?1??fo_getargstr@@YAPADPAUtagAMX@@HH@Z@4PAY0MAA@DA
_BSS	SEGMENT
?buffer@?1??fo_getargstr@@YAPADPAUtagAMX@@HH@Z@4PAY0MAA@DA DB 01800H DUP (?) ; `fo_getargstr'::`2'::buffer
_BSS	ENDS
;	COMDAT ?buffer@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PAY0MAA@DA
_BSS	SEGMENT
?buffer@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PAY0MAA@DA DB 01800H DUP (?) ; `format_arguments'::`2'::buffer
_BSS	ENDS
;	COMDAT ?format@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PADA
_BSS	SEGMENT
?format@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PADA DB 010H DUP (?) ; `format_arguments'::`2'::format
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?fmt@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_length$ = -4						; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?fmt@@YAHPAUtagAMX@@PAH@Z PROC				; fmt, COMDAT

; 1416 : {

  00000	51		 push	 ecx
  00001	56		 push	 esi

; 1417 : 	int length;
; 1418 : 	const char *string = format_amxstring(amx, params, 1, length);

  00002	8b 74 24 10	 mov	 esi, DWORD PTR _params$[esp+4]
  00006	8d 44 24 04	 lea	 eax, DWORD PTR _length$[esp+8]
  0000a	50		 push	 eax
  0000b	6a 01		 push	 1
  0000d	56		 push	 esi
  0000e	ff 74 24 18	 push	 DWORD PTR _amx$[esp+16]
  00012	e8 00 00 00 00	 call	 ?format_amxstring@@YAPADPAUtagAMX@@PAHHAAH@Z ; format_amxstring

; 1419 : 
; 1420 : 	size_t num_params = *params / sizeof(cell);
; 1421 : 
; 1422 : 	set_amxstring_utf8_char(amx, params[num_params + 1], string, length, MAX_FMT_LENGTH - 1);

  00017	68 ff 00 00 00	 push	 255			; 000000ffH
  0001c	ff 74 24 18	 push	 DWORD PTR _length$[esp+28]
  00020	50		 push	 eax
  00021	8b 06		 mov	 eax, DWORD PTR [esi]
  00023	c1 e8 02	 shr	 eax, 2
  00026	ff 74 86 04	 push	 DWORD PTR [esi+eax*4+4]
  0002a	ff 74 24 2c	 push	 DWORD PTR _amx$[esp+36]
  0002e	e8 00 00 00 00	 call	 ?set_amxstring_utf8_char@@YAHPAUtagAMX@@HPBDII@Z ; set_amxstring_utf8_char
  00033	83 c4 24	 add	 esp, 36			; 00000024H

; 1423 : 
; 1424 : 	return 1;

  00036	b8 01 00 00 00	 mov	 eax, 1
  0003b	5e		 pop	 esi

; 1425 : };

  0003c	59		 pop	 ecx
  0003d	c3		 ret	 0
?fmt@@YAHPAUtagAMX@@PAH@Z ENDP				; fmt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?vformat@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_vargPos$ = -8						; size = 4
_maxlen$1$ = -4						; size = 4
_copy$1$ = 8						; size = 1
_amx$ = 8						; size = 4
_dest$1$ = 12						; size = 4
_params$ = 12						; size = 4
?vformat@@YAHPAUtagAMX@@PAH@Z PROC			; vformat, COMDAT

; 1354 : {

  00000	83 ec 08	 sub	 esp, 8
  00003	55		 push	 ebp

; 1355 : 	int vargPos = static_cast<int>(params[4]);
; 1356 : 
; 1357 : 	/** get the parent parameter array */
; 1358 : 	AMX_HEADER *hdr = (AMX_HEADER *)amx->base;
; 1359 : 	cell *local_params = (cell *)(
; 1360 : 		(char *)amx->base + (cell)hdr->dat +
; 1361 : 		(cell)amx->frm + (2 * sizeof(cell))

  00004	8b 6c 24 10	 mov	 ebp, DWORD PTR _amx$[esp+8]
  00008	56		 push	 esi
  00009	8b 74 24 18	 mov	 esi, DWORD PTR _params$[esp+12]
  0000d	57		 push	 edi
  0000e	8b 55 00	 mov	 edx, DWORD PTR [ebp]
  00011	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00014	89 44 24 0c	 mov	 DWORD PTR _vargPos$[esp+20], eax
  00018	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  0001b	8d 7a 08	 lea	 edi, DWORD PTR [edx+8]
  0001e	03 4d 14	 add	 ecx, DWORD PTR [ebp+20]
  00021	03 f9		 add	 edi, ecx

; 1362 : 		);
; 1363 : 
; 1364 : 	cell max = local_params[0] / sizeof(cell);

  00023	8b 17		 mov	 edx, DWORD PTR [edi]
  00025	c1 ea 02	 shr	 edx, 2

; 1365 : 	if (vargPos > (int)max + 1)

  00028	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
  0002b	3b c1		 cmp	 eax, ecx
  0002d	7e 1a		 jle	 SHORT $LN5@vformat

; 1366 : 	{
; 1367 : 		LogError(amx, AMX_ERR_NATIVE, "Invalid vararg parameter passed: %d", vargPos);

  0002f	50		 push	 eax
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@BPGCCENF@Invalid?5vararg?5parameter?5passed?3@
  00035	6a 0a		 push	 10			; 0000000aH
  00037	55		 push	 ebp
  00038	e8 00 00 00 00	 call	 _LogError
  0003d	83 c4 10	 add	 esp, 16			; 00000010H

; 1368 : 		return 0;

  00040	33 c0		 xor	 eax, eax
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5d		 pop	 ebp

; 1409 : }

  00045	83 c4 08	 add	 esp, 8
  00048	c3		 ret	 0
$LN5@vformat:

; 1369 : 	}
; 1370 : 	
; 1371 : 	/**
; 1372 : 	 * check for bounds clipping
; 1373 : 	 */
; 1374 : 	cell addr_start = params[1];
; 1375 : 	cell addr_end = addr_start + params[2];

  00049	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0004c	89 4c 24 10	 mov	 DWORD PTR _maxlen$1$[esp+20], ecx

; 1376 : 	bool copy = false;

  00050	c6 44 24 18 00	 mov	 BYTE PTR _copy$1$[esp+16], 0
  00055	53		 push	 ebx
  00056	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00059	8d 34 19	 lea	 esi, DWORD PTR [ecx+ebx]

; 1377 : 	for (int i = vargPos; i <= max; i++)

  0005c	3b c2		 cmp	 eax, edx
  0005e	7f 17		 jg	 SHORT $LN15@vformat
$LL4@vformat:

; 1378 : 	{
; 1379 : 		//does this clip the bounds?
; 1380 : 		if ( (local_params[i] >= addr_start)
; 1381 : 			&& (local_params[i] <= addr_end) )

  00060	8b 0c 87	 mov	 ecx, DWORD PTR [edi+eax*4]
  00063	3b cb		 cmp	 ecx, ebx
  00065	7c 04		 jl	 SHORT $LN2@vformat
  00067	3b ce		 cmp	 ecx, esi
  00069	7e 07		 jle	 SHORT $LN11@vformat
$LN2@vformat:

; 1377 : 	for (int i = vargPos; i <= max; i++)

  0006b	40		 inc	 eax
  0006c	3b c2		 cmp	 eax, edx
  0006e	7e f0		 jle	 SHORT $LL4@vformat
  00070	eb 05		 jmp	 SHORT $LN15@vformat
$LN11@vformat:

; 1382 : 		{
; 1383 : 			copy = true;

  00072	c6 44 24 1c 01	 mov	 BYTE PTR _copy$1$[esp+20], 1
$LN15@vformat:

; 1384 : 			break;
; 1385 : 		}
; 1386 : 	}
; 1387 : 
; 1388 : 	/* get destination info */
; 1389 : 	cell *fmt = get_amxaddr(amx, params[3]);

  00077	8b 44 24 20	 mov	 eax, DWORD PTR _params$[esp+20]
  0007b	ff 70 0c	 push	 DWORD PTR [eax+12]
  0007e	55		 push	 ebp
  0007f	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 1390 : 	cell *realdest = get_amxaddr(amx, params[1]);

  00084	53		 push	 ebx
  00085	55		 push	 ebp
  00086	8b f0		 mov	 esi, eax
  00088	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 1391 : 	size_t maxlen = static_cast<size_t>(params[2]);
; 1392 : 	cell *dest = realdest;
; 1393 : 
; 1394 : 	/* if this is necessary... */
; 1395 : 	static cell cpbuf[4096];
; 1396 : 	if (copy)

  0008d	80 7c 24 2c 00	 cmp	 BYTE PTR _copy$1$[esp+36], 0
  00092	bb 00 00 00 00	 mov	 ebx, OFFSET ?cpbuf@?1??vformat@@YAHPAUtagAMX@@PAH@Z@4PAHA
  00097	89 44 24 30	 mov	 DWORD PTR _dest$1$[esp+36], eax
  0009b	0f 44 d8	 cmove	 ebx, eax

; 1397 : 		dest = cpbuf;
; 1398 : 
; 1399 : 	/* perform format */
; 1400 : 	size_t total = atcprintf(dest, maxlen, fmt, amx, local_params, &vargPos);

  0009e	8d 44 24 20	 lea	 eax, DWORD PTR _vargPos$[esp+40]
  000a2	50		 push	 eax
  000a3	57		 push	 edi
  000a4	55		 push	 ebp
  000a5	56		 push	 esi
  000a6	ff 74 24 34	 push	 DWORD PTR _maxlen$1$[esp+56]
  000aa	53		 push	 ebx
  000ab	e8 00 00 00 00	 call	 ??$atcprintf@HH@@YAIPAHIPBHPAUtagAMX@@00@Z ; atcprintf<int,int>
  000b0	83 c4 28	 add	 esp, 40			; 00000028H
  000b3	8b f0		 mov	 esi, eax

; 1401 : 
; 1402 : 	/* copy back */
; 1403 : 	if (copy)

  000b5	80 7c 24 1c 00	 cmp	 BYTE PTR _copy$1$[esp+20], 0
  000ba	74 15		 je	 SHORT $LN8@vformat

; 1404 : 	{
; 1405 : 		memcpy(realdest, dest, (total+1) * sizeof(cell));

  000bc	8d 0c b5 04 00
	00 00		 lea	 ecx, DWORD PTR [esi*4+4]
  000c3	51		 push	 ecx
  000c4	53		 push	 ebx
  000c5	ff 74 24 28	 push	 DWORD PTR _dest$1$[esp+28]
  000c9	e8 00 00 00 00	 call	 _memcpy
  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@vformat:

; 1406 : 	}
; 1407 : 
; 1408 : 	return total;

  000d1	5b		 pop	 ebx
  000d2	5f		 pop	 edi
  000d3	8b c6		 mov	 eax, esi
  000d5	5e		 pop	 esi
  000d6	5d		 pop	 ebp

; 1409 : }

  000d7	83 c4 08	 add	 esp, 8
  000da	c3		 ret	 0
?vformat@@YAHPAUtagAMX@@PAH@Z ENDP			; vformat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?n_strfind@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_len$ = -4						; size = 4
_amx$ = 8						; size = 4
_sublen$ = 12						; size = 4
_params$ = 12						; size = 4
?n_strfind@@YAHPAUtagAMX@@PAH@Z PROC			; n_strfind, COMDAT

; 1320 : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx

; 1321 : 	int len;
; 1322 : 	char *str = get_amxstring(amx, params[1], 0, len);

  00002	8b 5c 24 10	 mov	 ebx, DWORD PTR _params$[esp+4]
  00006	8d 44 24 04	 lea	 eax, DWORD PTR _len$[esp+8]
  0000a	55		 push	 ebp
  0000b	56		 push	 esi
  0000c	8b 74 24 14	 mov	 esi, DWORD PTR _amx$[esp+12]
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	6a 00		 push	 0
  00014	ff 73 04	 push	 DWORD PTR [ebx+4]
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  0001d	8b f8		 mov	 edi, eax

; 1323 : 	int sublen;
; 1324 : 	char *sub = get_amxstring(amx, params[2], 1, sublen);

  0001f	8d 44 24 2c	 lea	 eax, DWORD PTR _sublen$[esp+32]
  00023	50		 push	 eax
  00024	6a 01		 push	 1
  00026	ff 73 08	 push	 DWORD PTR [ebx+8]
  00029	56		 push	 esi
  0002a	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring

; 1325 : 
; 1326 : 	bool igcase = params[3] ? true : false;
; 1327 : 	
; 1328 : 	if (igcase)

  0002f	8b 74 24 30	 mov	 esi, DWORD PTR _len$[esp+52]
  00033	83 c4 20	 add	 esp, 32			; 00000020H
  00036	83 7b 0c 00	 cmp	 DWORD PTR [ebx+12], 0
  0003a	8b e8		 mov	 ebp, eax
  0003c	74 35		 je	 SHORT $LN6@n_strfind

; 1329 : 	{
; 1330 : 		for (int i = 0; i < len; i++)

  0003e	33 c9		 xor	 ecx, ecx
  00040	85 f6		 test	 esi, esi
  00042	7e 11		 jle	 SHORT $LN3@n_strfind
$LL20@n_strfind:

; 1331 : 		{
; 1332 : 			if (str[i] & (1<<5))

  00044	8a 04 39	 mov	 al, BYTE PTR [ecx+edi]
  00047	a8 20		 test	 al, 32			; 00000020H
  00049	74 05		 je	 SHORT $LN21@n_strfind

; 1333 : 				str[i] &= ~(1<<5);

  0004b	24 df		 and	 al, -33			; ffffffdfH
  0004d	88 04 39	 mov	 BYTE PTR [ecx+edi], al
$LN21@n_strfind:

; 1329 : 	{
; 1330 : 		for (int i = 0; i < len; i++)

  00050	41		 inc	 ecx
  00051	3b ce		 cmp	 ecx, esi
  00053	7c ef		 jl	 SHORT $LL20@n_strfind
$LN3@n_strfind:

; 1334 : 		}
; 1335 : 		for (int i = 0; i < sublen; i++)

  00055	8b 54 24 1c	 mov	 edx, DWORD PTR _sublen$[esp+16]
  00059	33 c0		 xor	 eax, eax
  0005b	85 d2		 test	 edx, edx
  0005d	7e 14		 jle	 SHORT $LN6@n_strfind
  0005f	90		 npad	 1
$LL23@n_strfind:

; 1336 : 		{
; 1337 : 			if (str[i] & (1<<5))

  00060	8a 0c 38	 mov	 cl, BYTE PTR [eax+edi]
  00063	f6 c1 20	 test	 cl, 32			; 00000020H
  00066	74 06		 je	 SHORT $LN24@n_strfind

; 1338 : 				str[i] &= ~(1<<5);			

  00068	80 e1 df	 and	 cl, -33			; ffffffdfH
  0006b	88 0c 38	 mov	 BYTE PTR [eax+edi], cl
$LN24@n_strfind:

; 1334 : 		}
; 1335 : 		for (int i = 0; i < sublen; i++)

  0006e	40		 inc	 eax
  0006f	3b c2		 cmp	 eax, edx
  00071	7c ed		 jl	 SHORT $LL23@n_strfind
$LN6@n_strfind:

; 1339 : 		}
; 1340 : 	}
; 1341 : 
; 1342 : 	if (params[4] > len)

  00073	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00076	3b c6		 cmp	 eax, esi
  00078	7e 09		 jle	 SHORT $LN11@n_strfind
$LN30@n_strfind:
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5d		 pop	 ebp

; 1343 : 		return -1;

  0007d	83 c8 ff	 or	 eax, -1
  00080	5b		 pop	 ebx

; 1351 : }

  00081	59		 pop	 ecx
  00082	c3		 ret	 0
$LN11@n_strfind:

; 1344 : 
; 1345 : 	char *find = strstr(str + params[4], sub);

  00083	03 c7		 add	 eax, edi
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h

; 537  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  00085	55		 push	 ebp
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 _strstr
  0008c	83 c4 08	 add	 esp, 8
; File e:\nightfire_sdk\amx\amxmodx\string.cpp

; 1347 : 	if (!find)

  0008f	85 c0		 test	 eax, eax
  00091	74 e7		 je	 SHORT $LN30@n_strfind

; 1348 : 		return -1;
; 1349 : 
; 1350 : 	return (find - str);

  00093	2b c7		 sub	 eax, edi
  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5d		 pop	 ebp
  00098	5b		 pop	 ebx

; 1351 : }

  00099	59		 pop	 ecx
  0009a	c3		 ret	 0
?n_strfind@@YAHPAUtagAMX@@PAH@Z ENDP			; n_strfind
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?n_strncmp@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_len$ = -4						; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?n_strncmp@@YAHPAUtagAMX@@PAH@Z PROC			; n_strncmp, COMDAT

; 1308 : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	57		 push	 edi

; 1309 : 	int len;
; 1310 : 	char *str1 = get_amxstring(amx, params[1], 0, len);

  00003	8b 7c 24 14	 mov	 edi, DWORD PTR _params$[esp+8]
  00007	8d 44 24 08	 lea	 eax, DWORD PTR _len$[esp+12]
  0000b	50		 push	 eax
  0000c	6a 00		 push	 0
  0000e	ff 77 04	 push	 DWORD PTR [edi+4]
  00011	ff 74 24 1c	 push	 DWORD PTR _amx$[esp+20]
  00015	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  0001a	8b d8		 mov	 ebx, eax

; 1311 : 	char *str2 = get_amxstring(amx, params[2], 1, len);

  0001c	8d 44 24 18	 lea	 eax, DWORD PTR _len$[esp+28]
  00020	50		 push	 eax
  00021	6a 01		 push	 1
  00023	ff 77 08	 push	 DWORD PTR [edi+8]
  00026	ff 74 24 2c	 push	 DWORD PTR _amx$[esp+36]
  0002a	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  0002f	83 c4 20	 add	 esp, 32			; 00000020H

; 1312 : 
; 1313 : 	if (params[4])

  00032	83 7f 10 00	 cmp	 DWORD PTR [edi+16], 0

; 1314 : 		return strncasecmp(str1, str2, (size_t)params[3]);

  00036	ff 77 0c	 push	 DWORD PTR [edi+12]
  00039	50		 push	 eax
  0003a	53		 push	 ebx
  0003b	74 0c		 je	 SHORT $LN2@n_strncmp
  0003d	e8 00 00 00 00	 call	 __strnicmp

; 1315 : 	else
; 1316 : 		return strncmp(str1, str2, (size_t)params[3]);

  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
  00045	5f		 pop	 edi
  00046	5b		 pop	 ebx

; 1317 : }

  00047	59		 pop	 ecx
  00048	c3		 ret	 0
$LN2@n_strncmp:

; 1315 : 	else
; 1316 : 		return strncmp(str1, str2, (size_t)params[3]);

  00049	e8 00 00 00 00	 call	 _strncmp
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	5f		 pop	 edi
  00052	5b		 pop	 ebx

; 1317 : }

  00053	59		 pop	 ecx
  00054	c3		 ret	 0
?n_strncmp@@YAHPAUtagAMX@@PAH@Z ENDP			; n_strncmp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?n_strcmp@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_len$ = -4						; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?n_strcmp@@YAHPAUtagAMX@@PAH@Z PROC			; n_strcmp, COMDAT

; 1296 : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	57		 push	 edi

; 1297 : 	int len;
; 1298 : 	char *str1 = get_amxstring(amx, params[1], 0, len);

  00003	8b 7c 24 14	 mov	 edi, DWORD PTR _params$[esp+8]
  00007	8d 44 24 08	 lea	 eax, DWORD PTR _len$[esp+12]
  0000b	50		 push	 eax
  0000c	6a 00		 push	 0
  0000e	ff 77 04	 push	 DWORD PTR [edi+4]
  00011	ff 74 24 1c	 push	 DWORD PTR _amx$[esp+20]
  00015	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  0001a	8b d8		 mov	 ebx, eax

; 1299 : 	char *str2 = get_amxstring(amx, params[2], 1, len);

  0001c	8d 44 24 18	 lea	 eax, DWORD PTR _len$[esp+28]
  00020	50		 push	 eax
  00021	6a 01		 push	 1
  00023	ff 77 08	 push	 DWORD PTR [edi+8]
  00026	ff 74 24 2c	 push	 DWORD PTR _amx$[esp+36]
  0002a	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  0002f	83 c4 20	 add	 esp, 32			; 00000020H

; 1300 : 
; 1301 : 	if (params[3])

  00032	83 7f 0c 00	 cmp	 DWORD PTR [edi+12], 0
  00036	74 0e		 je	 SHORT $LL2@n_strcmp

; 1302 : 		return stricmp(str1, str2);

  00038	50		 push	 eax
  00039	53		 push	 ebx
  0003a	e8 00 00 00 00	 call	 __stricmp
  0003f	83 c4 08	 add	 esp, 8
  00042	5f		 pop	 edi
  00043	5b		 pop	 ebx

; 1305 : }

  00044	59		 pop	 ecx
  00045	c3		 ret	 0
$LL2@n_strcmp:

; 1303 : 	else
; 1304 : 		return strcmp(str1, str2);

  00046	8a 0b		 mov	 cl, BYTE PTR [ebx]
  00048	3a 08		 cmp	 cl, BYTE PTR [eax]
  0004a	75 1c		 jne	 SHORT $LN6@n_strcmp
  0004c	84 c9		 test	 cl, cl
  0004e	74 12		 je	 SHORT $LN7@n_strcmp
  00050	8a 4b 01	 mov	 cl, BYTE PTR [ebx+1]
  00053	3a 48 01	 cmp	 cl, BYTE PTR [eax+1]
  00056	75 10		 jne	 SHORT $LN6@n_strcmp
  00058	83 c3 02	 add	 ebx, 2
  0005b	83 c0 02	 add	 eax, 2
  0005e	84 c9		 test	 cl, cl
  00060	75 e4		 jne	 SHORT $LL2@n_strcmp
$LN7@n_strcmp:
  00062	5f		 pop	 edi
  00063	33 c0		 xor	 eax, eax
  00065	5b		 pop	 ebx

; 1305 : }

  00066	59		 pop	 ecx
  00067	c3		 ret	 0
$LN6@n_strcmp:

; 1303 : 	else
; 1304 : 		return strcmp(str1, str2);

  00068	1b c0		 sbb	 eax, eax
  0006a	5f		 pop	 edi
  0006b	83 c8 01	 or	 eax, 1
  0006e	5b		 pop	 ebx

; 1305 : }

  0006f	59		 pop	 ecx
  00070	c3		 ret	 0
?n_strcmp@@YAHPAUtagAMX@@PAH@Z ENDP			; n_strcmp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?n_strcat@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?n_strcat@@YAHPAUtagAMX@@PAH@Z PROC			; n_strcat, COMDAT

; 1269 : {

  00000	53		 push	 ebx

; 1270 : 	cell *cdest, *csrc;
; 1271 : 
; 1272 : 	cdest = get_amxaddr(amx, params[1]);

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _params$[esp]
  00005	56		 push	 esi
  00006	ff 73 04	 push	 DWORD PTR [ebx+4]
  00009	ff 74 24 10	 push	 DWORD PTR _amx$[esp+8]
  0000d	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 1273 : 	csrc = get_amxaddr(amx, params[2]);

  00012	ff 73 08	 push	 DWORD PTR [ebx+8]
  00015	8b f0		 mov	 esi, eax
  00017	ff 74 24 18	 push	 DWORD PTR _amx$[esp+16]
  0001b	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 1274 : 	int num = params[3];

  00020	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00023	83 c4 10	 add	 esp, 16			; 00000010H

; 1275 : 	
; 1276 : 	while (*cdest && num)

  00026	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00029	8b d0		 mov	 edx, eax
  0002b	74 10		 je	 SHORT $LN3@n_strcat
  0002d	0f 1f 00	 npad	 3
$LL2@n_strcat:
  00030	85 c9		 test	 ecx, ecx
  00032	74 0d		 je	 SHORT $LN16@n_strcat

; 1277 : 	{
; 1278 : 		cdest++;

  00034	83 c6 04	 add	 esi, 4

; 1279 : 		num--;

  00037	49		 dec	 ecx
  00038	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0003b	75 f3		 jne	 SHORT $LL2@n_strcat
$LN3@n_strcat:

; 1280 : 	}
; 1281 : 	
; 1282 : 	if (!num)

  0003d	85 c9		 test	 ecx, ecx
  0003f	75 05		 jne	 SHORT $LN9@n_strcat
$LN16@n_strcat:
  00041	5e		 pop	 esi

; 1283 : 		return 0;

  00042	33 c0		 xor	 eax, eax
  00044	5b		 pop	 ebx

; 1293 : }

  00045	c3		 ret	 0
$LN9@n_strcat:

; 1284 : 	
; 1285 : 	while (*csrc && num)

  00046	8b 02		 mov	 eax, DWORD PTR [edx]
  00048	85 c0		 test	 eax, eax
  0004a	74 16		 je	 SHORT $LN17@n_strcat
  0004c	2b d6		 sub	 edx, esi
  0004e	66 90		 npad	 2
$LL4@n_strcat:
  00050	85 c9		 test	 ecx, ecx
  00052	74 0e		 je	 SHORT $LN17@n_strcat

; 1286 : 	{
; 1287 : 		*cdest++ = *csrc++;

  00054	89 06		 mov	 DWORD PTR [esi], eax

; 1288 : 		num--;

  00056	49		 dec	 ecx
  00057	8b 44 32 04	 mov	 eax, DWORD PTR [edx+esi+4]
  0005b	83 c6 04	 add	 esi, 4
  0005e	85 c0		 test	 eax, eax
  00060	75 ee		 jne	 SHORT $LL4@n_strcat
$LN17@n_strcat:

; 1289 : 	}
; 1290 : 	*cdest = 0;

  00062	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1291 : 
; 1292 : 	return params[3] - num;

  00068	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0006b	5e		 pop	 esi
  0006c	2b c1		 sub	 eax, ecx
  0006e	5b		 pop	 ebx

; 1293 : }

  0006f	c3		 ret	 0
?n_strcat@@YAHPAUtagAMX@@PAH@Z ENDP			; n_strcat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?amx_trim@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_len$ = 12						; size = 4
_params$ = 12						; size = 4
?amx_trim@@YAHPAUtagAMX@@PAH@Z PROC			; amx_trim, COMDAT

; 1253 : {

  00000	53		 push	 ebx

; 1254 : 	int len, newlen;
; 1255 : 	char *str = get_amxstring(amx, params[1], 0, len);

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _params$[esp]
  00005	8d 44 24 0c	 lea	 eax, DWORD PTR _len$[esp]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	50		 push	 eax
  0000c	6a 00		 push	 0
  0000e	ff 73 04	 push	 DWORD PTR [ebx+4]
  00011	ff 74 24 1c	 push	 DWORD PTR _amx$[esp+20]
  00015	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  0001a	8b f8		 mov	 edi, eax

; 1256 : 
; 1257 : 	UTIL_TrimLeft(str);

  0001c	57		 push	 edi
  0001d	e8 00 00 00 00	 call	 ?UTIL_TrimLeft@@YAXPAD@Z ; UTIL_TrimLeft

; 1258 : 	UTIL_TrimRight(str);

  00022	57		 push	 edi
  00023	e8 00 00 00 00	 call	 ?UTIL_TrimRight@@YAXPAD@Z ; UTIL_TrimRight

; 1259 : 
; 1260 : 	newlen = strlen(str);

  00028	8b cf		 mov	 ecx, edi
  0002a	83 c4 18	 add	 esp, 24			; 00000018H
  0002d	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL3@amx_trim:
  00030	8a 01		 mov	 al, BYTE PTR [ecx]
  00032	41		 inc	 ecx
  00033	84 c0		 test	 al, al
  00035	75 f9		 jne	 SHORT $LL3@amx_trim

; 1261 : 	len -= newlen;

  00037	8b 74 24 14	 mov	 esi, DWORD PTR _len$[esp+8]
  0003b	2b ca		 sub	 ecx, edx

; 1262 : 
; 1263 : 	set_amxstring(amx, params[1], str, newlen);

  0003d	51		 push	 ecx
  0003e	57		 push	 edi
  0003f	ff 73 04	 push	 DWORD PTR [ebx+4]
  00042	2b f1		 sub	 esi, ecx
  00044	ff 74 24 1c	 push	 DWORD PTR _amx$[esp+20]
  00048	e8 00 00 00 00	 call	 ?set_amxstring@@YAHPAUtagAMX@@HPBDH@Z ; set_amxstring
  0004d	83 c4 10	 add	 esp, 16			; 00000010H

; 1264 : 
; 1265 : 	return len;

  00050	8b c6		 mov	 eax, esi
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx

; 1266 : }

  00055	c3		 ret	 0
?amx_trim@@YAHPAUtagAMX@@PAH@Z ENDP			; amx_trim
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?amx_strlen@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_len$ = -4						; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?amx_strlen@@YAHPAUtagAMX@@PAH@Z PROC			; amx_strlen, COMDAT

; 1245 : {

  00000	51		 push	 ecx

; 1246 : 	int len;
; 1247 : 	char *str = get_amxstring(amx, params[1], 0, len);

  00001	8d 04 24	 lea	 eax, DWORD PTR _len$[esp+4]
  00004	50		 push	 eax
  00005	8b 44 24 10	 mov	 eax, DWORD PTR _params$[esp+4]
  00009	6a 00		 push	 0
  0000b	ff 70 04	 push	 DWORD PTR [eax+4]
  0000e	ff 74 24 14	 push	 DWORD PTR _amx$[esp+12]
  00012	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  00017	83 c4 10	 add	 esp, 16			; 00000010H

; 1248 : 
; 1249 : 	return strlen(str);

  0001a	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  0001d	0f 1f 00	 npad	 3
$LL3@amx_strlen:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $LL3@amx_strlen
  00027	2b c2		 sub	 eax, edx

; 1250 : }

  00029	59		 pop	 ecx
  0002a	c3		 ret	 0
?amx_strlen@@YAHPAUtagAMX@@PAH@Z ENDP			; amx_strlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?amx_ucfirst@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?amx_ucfirst@@YAHPAUtagAMX@@PAH@Z PROC			; amx_ucfirst, COMDAT

; 1235 : 	cell *str = get_amxaddr(amx, params[1]);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _params$[esp-4]
  00004	56		 push	 esi
  00005	ff 70 04	 push	 DWORD PTR [eax+4]
  00008	ff 74 24 0c	 push	 DWORD PTR _amx$[esp+4]
  0000c	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr
  00011	8b f0		 mov	 esi, eax

; 1236 : 	
; 1237 : 	if (!isalpha((char)str[0]) || !(str[0] & (1<<5)))

  00013	0f be 0e	 movsx	 ecx, BYTE PTR [esi]
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 _isalpha
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001f	85 c0		 test	 eax, eax
  00021	74 13		 je	 SHORT $LN3@amx_ucfirs
  00023	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00025	f6 c1 20	 test	 cl, 32			; 00000020H
  00028	74 0c		 je	 SHORT $LN3@amx_ucfirs

; 1239 : 	str[0] &= ~(1<<5);

  0002a	83 e1 df	 and	 ecx, -33		; ffffffdfH

; 1240 : 	
; 1241 : 	return 1;

  0002d	b8 01 00 00 00	 mov	 eax, 1
  00032	89 0e		 mov	 DWORD PTR [esi], ecx
  00034	5e		 pop	 esi

; 1242 : }

  00035	c3		 ret	 0
$LN3@amx_ucfirs:

; 1238 : 		return 0;

  00036	33 c0		 xor	 eax, eax
  00038	5e		 pop	 esi

; 1242 : }

  00039	c3		 ret	 0
?amx_ucfirst@@YAHPAUtagAMX@@PAH@Z ENDP			; amx_ucfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?get_char_bytes@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_len$ = -4						; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?get_char_bytes@@YAHPAUtagAMX@@PAH@Z PROC		; get_char_bytes, COMDAT

; 1226 : {

  00000	51		 push	 ecx

; 1227 : 	int len;
; 1228 : 	char *str = get_amxstring(amx, params[1], 0, len);

  00001	8d 04 24	 lea	 eax, DWORD PTR _len$[esp+4]
  00004	50		 push	 eax
  00005	8b 44 24 10	 mov	 eax, DWORD PTR _params$[esp+4]
  00009	6a 00		 push	 0
  0000b	ff 70 04	 push	 DWORD PTR [eax+4]
  0000e	ff 74 24 14	 push	 DWORD PTR _amx$[esp+12]
  00012	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring

; 1229 : 
; 1230 : 	return UTIL_GetUTF8CharBytes(str);

  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ?UTIL_GetUTF8CharBytes@@YAIPBD@Z ; UTIL_GetUTF8CharBytes

; 1231 : };

  0001d	83 c4 18	 add	 esp, 24			; 00000018H
  00020	c3		 ret	 0
?get_char_bytes@@YAHPAUtagAMX@@PAH@Z ENDP		; get_char_bytes
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?is_char_mb@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_chr$ = 12						; size = 1
_params$ = 12						; size = 4
?is_char_mb@@YAHPAUtagAMX@@PAH@Z PROC			; is_char_mb, COMDAT

; 1214 : 	char chr = params[1];

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _params$[esp-4]
  00004	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  00007	88 44 24 08	 mov	 BYTE PTR _chr$[esp-4], al

; 1215 : 
; 1216 : 	unsigned int bytes = UTIL_GetUTF8CharBytes(&chr);

  0000b	8d 44 24 08	 lea	 eax, DWORD PTR _chr$[esp-4]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?UTIL_GetUTF8CharBytes@@YAIPBD@Z ; UTIL_GetUTF8CharBytes

; 1217 : 	if (bytes == 1)

  00015	33 c9		 xor	 ecx, ecx
  00017	83 c4 04	 add	 esp, 4
  0001a	83 f8 01	 cmp	 eax, 1
  0001d	0f 44 c1	 cmove	 eax, ecx

; 1218 : 	{
; 1219 : 		return 0;
; 1220 : 	}
; 1221 : 
; 1222 : 	return bytes;
; 1223 : }

  00020	c3		 ret	 0
?is_char_mb@@YAHPAUtagAMX@@PAH@Z ENDP			; is_char_mb
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?is_char_lower@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_chr$ = 12						; size = 1
_params$ = 12						; size = 4
?is_char_lower@@YAHPAUtagAMX@@PAH@Z PROC		; is_char_lower, COMDAT

; 1202 : 	char chr = params[1];

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _params$[esp-4]
  00004	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  00007	88 44 24 08	 mov	 BYTE PTR _chr$[esp-4], al

; 1203 : 
; 1204 : 	if (UTIL_GetUTF8CharBytes(&chr) != 1)

  0000b	8d 44 24 08	 lea	 eax, DWORD PTR _chr$[esp-4]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?UTIL_GetUTF8CharBytes@@YAIPBD@Z ; UTIL_GetUTF8CharBytes
  00015	83 c4 04	 add	 esp, 4
  00018	83 f8 01	 cmp	 eax, 1
  0001b	74 03		 je	 SHORT $LN2@is_char_lo

; 1205 : 	{
; 1206 : 		return 0;

  0001d	33 c0		 xor	 eax, eax

; 1210 : }

  0001f	c3		 ret	 0
$LN2@is_char_lo:

; 1207 : 	}
; 1208 : 
; 1209 : 	return islower(chr);

  00020	0f be 44 24 08	 movsx	 eax, BYTE PTR _chr$[esp-4]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _islower
  0002b	83 c4 04	 add	 esp, 4

; 1210 : }

  0002e	c3		 ret	 0
?is_char_lower@@YAHPAUtagAMX@@PAH@Z ENDP		; is_char_lower
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?is_char_upper@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_chr$ = 12						; size = 1
_params$ = 12						; size = 4
?is_char_upper@@YAHPAUtagAMX@@PAH@Z PROC		; is_char_upper, COMDAT

; 1190 : 	char chr = params[1];

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _params$[esp-4]
  00004	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  00007	88 44 24 08	 mov	 BYTE PTR _chr$[esp-4], al

; 1191 : 
; 1192 : 	if (UTIL_GetUTF8CharBytes(&chr) != 1)

  0000b	8d 44 24 08	 lea	 eax, DWORD PTR _chr$[esp-4]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?UTIL_GetUTF8CharBytes@@YAIPBD@Z ; UTIL_GetUTF8CharBytes
  00015	83 c4 04	 add	 esp, 4
  00018	83 f8 01	 cmp	 eax, 1
  0001b	74 03		 je	 SHORT $LN2@is_char_up

; 1193 : 	{
; 1194 : 		return 0;

  0001d	33 c0		 xor	 eax, eax

; 1198 : }

  0001f	c3		 ret	 0
$LN2@is_char_up:

; 1195 : 	}
; 1196 : 
; 1197 : 	return isupper(chr);

  00020	0f be 44 24 08	 movsx	 eax, BYTE PTR _chr$[esp-4]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _isupper
  0002b	83 c4 04	 add	 esp, 4

; 1198 : }

  0002e	c3		 ret	 0
?is_char_upper@@YAHPAUtagAMX@@PAH@Z ENDP		; is_char_upper
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?is_alpha@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_chr$ = 12						; size = 1
_params$ = 12						; size = 4
?is_alpha@@YAHPAUtagAMX@@PAH@Z PROC			; is_alpha, COMDAT

; 1178 : 	char chr = params[1];

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _params$[esp-4]
  00004	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  00007	88 44 24 08	 mov	 BYTE PTR _chr$[esp-4], al

; 1179 : 
; 1180 : 	if (UTIL_GetUTF8CharBytes(&chr) != 1)

  0000b	8d 44 24 08	 lea	 eax, DWORD PTR _chr$[esp-4]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?UTIL_GetUTF8CharBytes@@YAIPBD@Z ; UTIL_GetUTF8CharBytes
  00015	83 c4 04	 add	 esp, 4
  00018	83 f8 01	 cmp	 eax, 1
  0001b	74 03		 je	 SHORT $LN2@is_alpha

; 1181 : 	{
; 1182 : 		return 0;

  0001d	33 c0		 xor	 eax, eax

; 1186 : }

  0001f	c3		 ret	 0
$LN2@is_alpha:

; 1183 : 	}
; 1184 : 
; 1185 : 	return isalpha(chr);

  00020	0f be 44 24 08	 movsx	 eax, BYTE PTR _chr$[esp-4]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _isalpha
  0002b	83 c4 04	 add	 esp, 4

; 1186 : }

  0002e	c3		 ret	 0
?is_alpha@@YAHPAUtagAMX@@PAH@Z ENDP			; is_alpha
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?is_space@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_chr$ = 12						; size = 1
_params$ = 12						; size = 4
?is_space@@YAHPAUtagAMX@@PAH@Z PROC			; is_space, COMDAT

; 1166 : 	char chr = params[1];

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _params$[esp-4]
  00004	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  00007	88 44 24 08	 mov	 BYTE PTR _chr$[esp-4], al

; 1167 : 
; 1168 : 	if (UTIL_GetUTF8CharBytes(&chr) != 1)

  0000b	8d 44 24 08	 lea	 eax, DWORD PTR _chr$[esp-4]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?UTIL_GetUTF8CharBytes@@YAIPBD@Z ; UTIL_GetUTF8CharBytes
  00015	83 c4 04	 add	 esp, 4
  00018	83 f8 01	 cmp	 eax, 1
  0001b	74 03		 je	 SHORT $LN2@is_space

; 1169 : 	{
; 1170 : 		return 0;

  0001d	33 c0		 xor	 eax, eax

; 1174 : }

  0001f	c3		 ret	 0
$LN2@is_space:

; 1171 : 	}
; 1172 : 
; 1173 : 	return isspace(chr);

  00020	0f be 44 24 08	 movsx	 eax, BYTE PTR _chr$[esp-4]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _isspace
  0002b	83 c4 04	 add	 esp, 4

; 1174 : }

  0002e	c3		 ret	 0
?is_space@@YAHPAUtagAMX@@PAH@Z ENDP			; is_space
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?is_alnum@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_chr$ = 12						; size = 1
_params$ = 12						; size = 4
?is_alnum@@YAHPAUtagAMX@@PAH@Z PROC			; is_alnum, COMDAT

; 1154 : 	char chr = params[1];

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _params$[esp-4]
  00004	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  00007	88 44 24 08	 mov	 BYTE PTR _chr$[esp-4], al

; 1155 : 
; 1156 : 	if (UTIL_GetUTF8CharBytes(&chr) != 1)

  0000b	8d 44 24 08	 lea	 eax, DWORD PTR _chr$[esp-4]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?UTIL_GetUTF8CharBytes@@YAIPBD@Z ; UTIL_GetUTF8CharBytes
  00015	83 c4 04	 add	 esp, 4
  00018	83 f8 01	 cmp	 eax, 1
  0001b	74 03		 je	 SHORT $LN2@is_alnum

; 1157 : 	{
; 1158 : 		return 0;

  0001d	33 c0		 xor	 eax, eax

; 1162 : }

  0001f	c3		 ret	 0
$LN2@is_alnum:

; 1159 : 	}
; 1160 : 
; 1161 : 	return isalnum(chr);

  00020	0f be 44 24 08	 movsx	 eax, BYTE PTR _chr$[esp-4]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _isalnum
  0002b	83 c4 04	 add	 esp, 4

; 1162 : }

  0002e	c3		 ret	 0
?is_alnum@@YAHPAUtagAMX@@PAH@Z ENDP			; is_alnum
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?is_digit@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_chr$ = 12						; size = 1
_params$ = 12						; size = 4
?is_digit@@YAHPAUtagAMX@@PAH@Z PROC			; is_digit, COMDAT

; 1142 : 	char chr = params[1];

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _params$[esp-4]
  00004	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  00007	88 44 24 08	 mov	 BYTE PTR _chr$[esp-4], al

; 1143 : 
; 1144 : 	if (UTIL_GetUTF8CharBytes(&chr) != 1)

  0000b	8d 44 24 08	 lea	 eax, DWORD PTR _chr$[esp-4]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?UTIL_GetUTF8CharBytes@@YAIPBD@Z ; UTIL_GetUTF8CharBytes
  00015	83 c4 04	 add	 esp, 4
  00018	83 f8 01	 cmp	 eax, 1
  0001b	74 03		 je	 SHORT $LN2@is_digit

; 1145 : 	{
; 1146 : 		return 0;

  0001d	33 c0		 xor	 eax, eax

; 1150 : }

  0001f	c3		 ret	 0
$LN2@is_digit:

; 1147 : 	}
; 1148 : 
; 1149 : 	return isdigit(chr);

  00020	0f be 44 24 08	 movsx	 eax, BYTE PTR _chr$[esp-4]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _isdigit
  0002b	83 c4 04	 add	 esp, 4

; 1150 : }

  0002e	c3		 ret	 0
?is_digit@@YAHPAUtagAMX@@PAH@Z ENDP			; is_digit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?format_args@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_len$ = 12						; size = 4
_params$ = 12						; size = 4
?format_args@@YAHPAUtagAMX@@PAH@Z PROC			; format_args, COMDAT

; 1125 : {

  00000	57		 push	 edi

; 1126 : 	int len;
; 1127 : 	int pos = params[3];

  00001	8b 7c 24 0c	 mov	 edi, DWORD PTR _params$[esp]
  00005	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]

; 1128 : 	
; 1129 : 	if (pos < 0)

  00008	85 c0		 test	 eax, eax
  0000a	79 17		 jns	 SHORT $LN2@format_arg

; 1130 : 	{
; 1131 : 		LogError(amx, AMX_ERR_NATIVE, "Pos has to be a positive number");

  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@BOKAAEHK@Pos?5has?5to?5be?5a?5positive?5number?$AA@
  00011	6a 0a		 push	 10			; 0000000aH
  00013	ff 74 24 10	 push	 DWORD PTR _amx$[esp+8]
  00017	e8 00 00 00 00	 call	 _LogError
  0001c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1132 : 		return 0;

  0001f	33 c0		 xor	 eax, eax
  00021	5f		 pop	 edi

; 1138 : }

  00022	c3		 ret	 0
$LN2@format_arg:

; 1133 : 	}
; 1134 : 
; 1135 : 	char* string = format_arguments(amx, pos, len); // indexed from 0

  00023	8d 4c 24 0c	 lea	 ecx, DWORD PTR _len$[esp]
  00027	51		 push	 ecx
  00028	50		 push	 eax
  00029	ff 74 24 10	 push	 DWORD PTR _amx$[esp+8]
  0002d	e8 00 00 00 00	 call	 ?format_arguments@@YAPADPAUtagAMX@@HAAH@Z ; format_arguments

; 1136 : 	
; 1137 : 	return set_amxstring_utf8(amx, params[1], string, len, params[2]);

  00032	ff 77 08	 push	 DWORD PTR [edi+8]
  00035	ff 74 24 1c	 push	 DWORD PTR _len$[esp+16]
  00039	50		 push	 eax
  0003a	ff 77 04	 push	 DWORD PTR [edi+4]
  0003d	ff 74 24 24	 push	 DWORD PTR _amx$[esp+28]
  00041	e8 00 00 00 00	 call	 ??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z ; set_amxstring_utf8<char>
  00046	83 c4 20	 add	 esp, 32			; 00000020H
  00049	5f		 pop	 edi

; 1138 : }

  0004a	c3		 ret	 0
?format_args@@YAHPAUtagAMX@@PAH@Z ENDP			; format_args
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?split_string@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_textLen$ = -12						; size = 4
_maxLen$1$ = -8						; size = 4
_splitLen$ = -8						; size = 4
_split$1$ = -4						; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?split_string@@YAHPAUtagAMX@@PAH@Z PROC			; split_string, COMDAT

; 1088 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx

; 1089 : 	int textLen, splitLen;
; 1090 : 	char *text = get_amxstring(amx, params[1], 0, textLen);

  00004	8b 5c 24 14	 mov	 ebx, DWORD PTR _amx$[esp+12]
  00008	8d 44 24 04	 lea	 eax, DWORD PTR _textLen$[esp+16]
  0000c	55		 push	 ebp
  0000d	56		 push	 esi
  0000e	8b 74 24 20	 mov	 esi, DWORD PTR _params$[esp+20]
  00012	50		 push	 eax
  00013	6a 00		 push	 0
  00015	ff 76 04	 push	 DWORD PTR [esi+4]
  00018	53		 push	 ebx
  00019	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  0001e	8b e8		 mov	 ebp, eax

; 1091 : 	const char *split = get_amxstring(amx, params[2], 1, splitLen);

  00020	8d 44 24 20	 lea	 eax, DWORD PTR _splitLen$[esp+40]
  00024	50		 push	 eax
  00025	6a 01		 push	 1
  00027	ff 76 08	 push	 DWORD PTR [esi+8]
  0002a	53		 push	 ebx
  0002b	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring

; 1092 : 
; 1093 : 	if (splitLen > textLen)

  00030	8b 5c 24 30	 mov	 ebx, DWORD PTR _splitLen$[esp+56]
  00034	8b c8		 mov	 ecx, eax
  00036	8b 44 24 2c	 mov	 eax, DWORD PTR _textLen$[esp+56]
  0003a	83 c4 20	 add	 esp, 32			; 00000020H
  0003d	89 4c 24 14	 mov	 DWORD PTR _split$1$[esp+24], ecx
  00041	3b d8		 cmp	 ebx, eax
  00043	7e 0a		 jle	 SHORT $LN5@split_stri

; 1094 : 	{
; 1095 : 		return -1;

  00045	5e		 pop	 esi
  00046	5d		 pop	 ebp
  00047	83 c8 ff	 or	 eax, -1
  0004a	5b		 pop	 ebx

; 1122 : }

  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	c3		 ret	 0
$LN5@split_stri:

; 1096 : 	}
; 1097 : 
; 1098 : 	int maxLen = params[4];

  0004f	8b 56 10	 mov	 edx, DWORD PTR [esi+16]

; 1099 : 
; 1100 : 	/**
; 1101 : 	* Note that it's <= ... you could also just add 1,
; 1102 : 	* but this is a bit nicer
; 1103 : 	*/
; 1104 : 	for (int i = 0; i <= textLen - splitLen; i++)

  00052	33 f6		 xor	 esi, esi
  00054	57		 push	 edi
  00055	8b f8		 mov	 edi, eax
  00057	89 54 24 14	 mov	 DWORD PTR _maxLen$1$[esp+28], edx
  0005b	2b fb		 sub	 edi, ebx
  0005d	78 1c		 js	 SHORT $LN3@split_stri
  0005f	90		 npad	 1
$LL4@split_stri:

; 1105 : 	{
; 1106 : 		if (strncmp(&text[i], split, splitLen) == 0)

  00060	53		 push	 ebx
  00061	51		 push	 ecx
  00062	8d 04 2e	 lea	 eax, DWORD PTR [esi+ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 _strncmp
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006e	85 c0		 test	 eax, eax
  00070	74 14		 je	 SHORT $LN11@split_stri

; 1099 : 
; 1100 : 	/**
; 1101 : 	* Note that it's <= ... you could also just add 1,
; 1102 : 	* but this is a bit nicer
; 1103 : 	*/
; 1104 : 	for (int i = 0; i <= textLen - splitLen; i++)

  00072	8b 4c 24 18	 mov	 ecx, DWORD PTR _split$1$[esp+28]
  00076	46		 inc	 esi
  00077	3b f7		 cmp	 esi, edi
  00079	7e e5		 jle	 SHORT $LL4@split_stri
$LN3@split_stri:
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	5d		 pop	 ebp

; 1118 : 		}
; 1119 : 	}
; 1120 : 
; 1121 : 	return -1;

  0007e	83 c8 ff	 or	 eax, -1
  00081	5b		 pop	 ebx

; 1122 : }

  00082	83 c4 0c	 add	 esp, 12			; 0000000cH
  00085	c3		 ret	 0
$LN11@split_stri:

; 1107 : 		{
; 1108 : 			/* Split hereeeee */
; 1109 : 			if (i > maxLen)

  00086	8b 44 24 14	 mov	 eax, DWORD PTR _maxLen$1$[esp+28]
  0008a	3b f0		 cmp	 esi, eax
  0008c	7e 03		 jle	 SHORT $LN7@split_stri

; 1110 : 			{
; 1111 : 				set_amxstring_utf8(amx, params[3], text, textLen, maxLen);

  0008e	50		 push	 eax

; 1112 : 			}
; 1113 : 			else

  0008f	eb 01		 jmp	 SHORT $LN16@split_stri
$LN7@split_stri:

; 1114 : 			{
; 1115 : 				set_amxstring_utf8(amx, params[3], text, textLen, i);

  00091	56		 push	 esi
$LN16@split_stri:
  00092	8b 44 24 14	 mov	 eax, DWORD PTR _textLen$[esp+32]
  00096	50		 push	 eax
  00097	8b 44 24 2c	 mov	 eax, DWORD PTR _params$[esp+32]
  0009b	55		 push	 ebp
  0009c	ff 70 0c	 push	 DWORD PTR [eax+12]
  0009f	8b 44 24 30	 mov	 eax, DWORD PTR _amx$[esp+40]
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 ??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z ; set_amxstring_utf8<char>
  000a9	83 c4 14	 add	 esp, 20			; 00000014H

; 1116 : 			}
; 1117 : 			return i + splitLen;

  000ac	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
  000af	5f		 pop	 edi
  000b0	5e		 pop	 esi
  000b1	5d		 pop	 ebp
  000b2	5b		 pop	 ebx

; 1122 : }

  000b3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b6	c3		 ret	 0
?split_string@@YAHPAUtagAMX@@PAH@Z ENDP			; split_string
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?strbreak@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_had_quotes$1$ = -17					; size = 1
__len$ = -16						; size = 4
_right$1$ = -12						; size = 4
_beg$1$ = -12						; size = 4
tv417 = -8						; size = 4
_LeftMax$1$ = -8					; size = 4
_RightMax$1$ = -4					; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?strbreak@@YAHPAUtagAMX@@PAH@Z PROC			; strbreak, COMDAT

; 1020 : {

  00000	83 ec 14	 sub	 esp, 20			; 00000014H
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi

; 1021 : 	int _len;
; 1022 : 	bool in_quote = false;
; 1023 : 	bool had_quotes = false;

  00006	32 c0		 xor	 al, al

; 1024 : 	size_t i = 0;

  00008	33 f6		 xor	 esi, esi
  0000a	57		 push	 edi

; 1025 : 	size_t beg = 0;
; 1026 : 
; 1027 : 	char *string = get_amxstring(amx, params[1], 0, _len);

  0000b	8b 7c 24 2c	 mov	 edi, DWORD PTR _params$[esp+32]
  0000f	32 db		 xor	 bl, bl
  00011	88 44 24 13	 mov	 BYTE PTR _had_quotes$1$[esp+36], al
  00015	8d 44 24 14	 lea	 eax, DWORD PTR __len$[esp+36]
  00019	50		 push	 eax
  0001a	56		 push	 esi
  0001b	ff 77 04	 push	 DWORD PTR [edi+4]
  0001e	ff 74 24 34	 push	 DWORD PTR _amx$[esp+44]
  00022	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring

; 1028 : 	cell *right = get_amxaddr(amx, params[4]);

  00027	ff 77 10	 push	 DWORD PTR [edi+16]
  0002a	8b e8		 mov	 ebp, eax
  0002c	ff 74 24 3c	 push	 DWORD PTR _amx$[esp+52]
  00030	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 1029 : 	int LeftMax = params[3];

  00035	8b 4c 24 44	 mov	 ecx, DWORD PTR _params$[esp+56]
  00039	8b f8		 mov	 edi, eax
  0003b	89 7c 24 30	 mov	 DWORD PTR _right$1$[esp+60], edi
  0003f	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00042	89 44 24 34	 mov	 DWORD PTR _LeftMax$1$[esp+60], eax

; 1030 : 	int RightMax = params[5];

  00046	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 1031 : 
; 1032 : 	size_t len = (size_t)_len;
; 1033 : 
; 1034 : 	while (isspace(string[i]) && i<len)

  00049	0f be 4d 00	 movsx	 ecx, BYTE PTR [ebp]
  0004d	51		 push	 ecx
  0004e	89 44 24 3c	 mov	 DWORD PTR _RightMax$1$[esp+64], eax
  00052	e8 00 00 00 00	 call	 _isspace
  00057	83 c4 1c	 add	 esp, 28			; 0000001cH
  0005a	85 c0		 test	 eax, eax
  0005c	8b 44 24 14	 mov	 eax, DWORD PTR __len$[esp+36]
  00060	74 21		 je	 SHORT $LN3@strbreak
  00062	8b f8		 mov	 edi, eax
$LL2@strbreak:
  00064	3b f7		 cmp	 esi, edi
  00066	73 13		 jae	 SHORT $LN55@strbreak
  00068	0f be 44 2e 01	 movsx	 eax, BYTE PTR [esi+ebp+1]

; 1035 : 		i++;

  0006d	46		 inc	 esi
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _isspace
  00074	83 c4 04	 add	 esp, 4
  00077	85 c0		 test	 eax, eax
  00079	75 e9		 jne	 SHORT $LL2@strbreak
$LN55@strbreak:
  0007b	8b 7c 24 18	 mov	 edi, DWORD PTR _right$1$[esp+36]
  0007f	8b 44 24 14	 mov	 eax, DWORD PTR __len$[esp+36]
$LN3@strbreak:

; 1036 : 	beg = i;

  00083	8b ce		 mov	 ecx, esi
  00085	89 4c 24 18	 mov	 DWORD PTR _beg$1$[esp+36], ecx

; 1037 : 	for (; i<len; i++)

  00089	3b f0		 cmp	 esi, eax
  0008b	73 49		 jae	 SHORT $LN52@strbreak
  0008d	0f 1f 00	 npad	 3
$LL6@strbreak:

; 1038 : 	{
; 1039 : 		if (string[i] == '"' && !in_quote)

  00090	8a 04 2e	 mov	 al, BYTE PTR [esi+ebp]
  00093	3c 22		 cmp	 al, 34			; 00000022H
  00095	75 20		 jne	 SHORT $LN13@strbreak
  00097	84 db		 test	 bl, bl
  00099	75 09		 jne	 SHORT $LN11@strbreak

; 1040 : 		{
; 1041 : 			in_quote = (had_quotes = true);

  0009b	c6 44 24 13 01	 mov	 BYTE PTR _had_quotes$1$[esp+36], 1
  000a0	b3 01		 mov	 bl, 1
  000a2	eb 27		 jmp	 SHORT $LN4@strbreak
$LN11@strbreak:

; 1042 : 		} else if (string[i] == '"' && in_quote) {

  000a4	3c 22		 cmp	 al, 34			; 00000022H
  000a6	75 0f		 jne	 SHORT $LN13@strbreak
  000a8	84 db		 test	 bl, bl
  000aa	74 0b		 je	 SHORT $LN13@strbreak

; 1043 : 			in_quote = false;
; 1044 : 			if (i == len-1)

  000ac	8b 44 24 14	 mov	 eax, DWORD PTR __len$[esp+36]
  000b0	32 db		 xor	 bl, bl
  000b2	48		 dec	 eax
  000b3	3b f0		 cmp	 esi, eax

; 1045 : 				goto do_copy;
; 1046 : 		} else {

  000b5	eb 12		 jmp	 SHORT $LN58@strbreak
$LN13@strbreak:

; 1047 : 			if (isspace(string[i]) && !in_quote)

  000b7	0f be c0	 movsx	 eax, al
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _isspace
  000c0	83 c4 04	 add	 esp, 4
  000c3	85 c0		 test	 eax, eax
  000c5	74 04		 je	 SHORT $LN4@strbreak
  000c7	84 db		 test	 bl, bl
$LN58@strbreak:
  000c9	74 51		 je	 SHORT $do_copy$60
$LN4@strbreak:

; 1037 : 	for (; i<len; i++)

  000cb	46		 inc	 esi
  000cc	3b 74 24 14	 cmp	 esi, DWORD PTR __len$[esp+36]
  000d0	72 be		 jb	 SHORT $LL6@strbreak
  000d2	8b 4c 24 18	 mov	 ecx, DWORD PTR _beg$1$[esp+36]
$LN52@strbreak:

; 1072 : 				}
; 1073 : 				*right = '\0';
; 1074 : 				return 1;
; 1075 : 			}
; 1076 : 		}
; 1077 : 	}
; 1078 : 
; 1079 : 	//if we got here, there was nothing to break
; 1080 : 	set_amxstring_utf8(amx, params[2], &(string[beg]), strlen(&(string[beg])), LeftMax);

  000d6	8d 14 29	 lea	 edx, DWORD PTR [ecx+ebp]
  000d9	8b ca		 mov	 ecx, edx
  000db	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  000de	66 90		 npad	 2
$LL54@strbreak:
  000e0	8a 01		 mov	 al, BYTE PTR [ecx]
  000e2	41		 inc	 ecx
  000e3	84 c0		 test	 al, al
  000e5	75 f9		 jne	 SHORT $LL54@strbreak
  000e7	ff 74 24 1c	 push	 DWORD PTR _LeftMax$1$[esp+36]
  000eb	8b 44 24 30	 mov	 eax, DWORD PTR _params$[esp+36]
  000ef	2b ce		 sub	 ecx, esi
  000f1	51		 push	 ecx
  000f2	52		 push	 edx
  000f3	ff 70 08	 push	 DWORD PTR [eax+8]
  000f6	ff 74 24 38	 push	 DWORD PTR _amx$[esp+48]
  000fa	e8 00 00 00 00	 call	 ??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z ; set_amxstring_utf8<char>
  000ff	83 c4 14	 add	 esp, 20			; 00000014H

; 1081 : 	if (RightMax)

  00102	83 7c 24 20 00	 cmp	 DWORD PTR _RightMax$1$[esp+36], 0
  00107	74 06		 je	 SHORT $LN19@strbreak
$LN42@strbreak:

; 1082 : 		*right = '\0';

  00109	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN19@strbreak:
  0010f	5f		 pop	 edi
  00110	5e		 pop	 esi
  00111	5d		 pop	 ebp

; 1083 : 
; 1084 : 	return 1;

  00112	b8 01 00 00 00	 mov	 eax, 1
  00117	5b		 pop	 ebx

; 1085 : }

  00118	83 c4 14	 add	 esp, 20			; 00000014H
  0011b	c3		 ret	 0
$do_copy$60:

; 1048 : 			{
; 1049 : do_copy:
; 1050 : 				size_t pos = i;
; 1051 : 				while (isspace(string[i]))

  0011c	0f be 04 2e	 movsx	 eax, BYTE PTR [esi+ebp]
  00120	8b de		 mov	 ebx, esi
  00122	50		 push	 eax
  00123	e8 00 00 00 00	 call	 _isspace
  00128	83 c4 04	 add	 esp, 4
  0012b	85 c0		 test	 eax, eax
  0012d	74 14		 je	 SHORT $LN8@strbreak
  0012f	90		 npad	 1
$LL7@strbreak:
  00130	0f be 44 2e 01	 movsx	 eax, BYTE PTR [esi+ebp+1]

; 1052 : 					i++;

  00135	46		 inc	 esi
  00136	50		 push	 eax
  00137	e8 00 00 00 00	 call	 _isspace
  0013c	83 c4 04	 add	 esp, 4
  0013f	85 c0		 test	 eax, eax
  00141	75 ed		 jne	 SHORT $LL7@strbreak
$LN8@strbreak:

; 1053 : 				const char *start = had_quotes ? &(string[beg+1]) : &(string[beg]);

  00143	8a 44 24 13	 mov	 al, BYTE PTR _had_quotes$1$[esp+36]

; 1054 : 				size_t _end = had_quotes ? (i==len-1 ? 1 : 2) : 0;

  00147	33 c9		 xor	 ecx, ecx
  00149	84 c0		 test	 al, al
  0014b	74 18		 je	 SHORT $LN21@strbreak
  0014d	8b 54 24 18	 mov	 edx, DWORD PTR _beg$1$[esp+36]
  00151	8b 44 24 14	 mov	 eax, DWORD PTR __len$[esp+36]
  00155	42		 inc	 edx
  00156	48		 dec	 eax
  00157	03 d5		 add	 edx, ebp
  00159	3b f0		 cmp	 esi, eax
  0015b	8b 44 24 18	 mov	 eax, DWORD PTR _beg$1$[esp+36]
  0015f	0f 95 c1	 setne	 cl
  00162	41		 inc	 ecx
  00163	eb 07		 jmp	 SHORT $LN24@strbreak
$LN21@strbreak:

; 1053 : 				const char *start = had_quotes ? &(string[beg+1]) : &(string[beg]);

  00165	8b 44 24 18	 mov	 eax, DWORD PTR _beg$1$[esp+36]
  00169	8d 14 28	 lea	 edx, DWORD PTR [eax+ebp]
$LN24@strbreak:

; 1055 : 				size_t end = (pos - _end > (size_t)LeftMax) ? (size_t)LeftMax : pos - _end;

  0016c	2b d9		 sub	 ebx, ecx
  0016e	8b 4c 24 1c	 mov	 ecx, DWORD PTR _LeftMax$1$[esp+36]
  00172	3b d9		 cmp	 ebx, ecx
  00174	0f 47 d9	 cmova	 ebx, ecx

; 1056 : 				
; 1057 : 				// If there is anything to copy, make sure we copy min(maxlen, slicelen).
; 1058 : 				size_t copylen = end >= beg

  00177	3b d8		 cmp	 ebx, eax
  00179	72 09		 jb	 SHORT $LN29@strbreak
  0017b	2b d8		 sub	 ebx, eax
  0017d	3b d9		 cmp	 ebx, ecx
  0017f	0f 47 d9	 cmova	 ebx, ecx
  00182	eb 02		 jmp	 SHORT $LN30@strbreak
$LN29@strbreak:
  00184	33 db		 xor	 ebx, ebx
$LN30@strbreak:

; 1059 : 				                 ? ((end - beg > size_t(LeftMax))
; 1060 : 				                    ? size_t(LeftMax)
; 1061 : 				                    : end - beg
; 1062 : 				                   )
; 1063 : 				                 : 0;
; 1064 : 				set_amxstring_utf8(amx, params[2], start, strlen(start), copylen);

  00186	8b ca		 mov	 ecx, edx
  00188	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0018b	89 44 24 1c	 mov	 DWORD PTR tv417[esp+36], eax
  0018f	90		 npad	 1
$LL53@strbreak:
  00190	8a 01		 mov	 al, BYTE PTR [ecx]
  00192	41		 inc	 ecx
  00193	84 c0		 test	 al, al
  00195	75 f9		 jne	 SHORT $LL53@strbreak
  00197	2b 4c 24 1c	 sub	 ecx, DWORD PTR tv417[esp+36]
  0019b	8b 44 24 2c	 mov	 eax, DWORD PTR _params$[esp+32]
  0019f	53		 push	 ebx
  001a0	51		 push	 ecx
  001a1	52		 push	 edx
  001a2	ff 70 08	 push	 DWORD PTR [eax+8]
  001a5	ff 74 24 38	 push	 DWORD PTR _amx$[esp+48]
  001a9	e8 00 00 00 00	 call	 ??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z ; set_amxstring_utf8<char>

; 1065 : 
; 1066 : 				end = (len-i+1 > (size_t)RightMax) ? (size_t)RightMax : len-i+1;

  001ae	8b 4c 24 28	 mov	 ecx, DWORD PTR __len$[esp+56]
  001b2	83 c4 14	 add	 esp, 20			; 00000014H
  001b5	2b ce		 sub	 ecx, esi
  001b7	41		 inc	 ecx
  001b8	3b 4c 24 20	 cmp	 ecx, DWORD PTR _RightMax$1$[esp+36]
  001bc	0f 47 4c 24 20	 cmova	 ecx, DWORD PTR _RightMax$1$[esp+36]

; 1067 : 				if (end)

  001c1	85 c9		 test	 ecx, ecx
  001c3	0f 84 40 ff ff
	ff		 je	 $LN42@strbreak

; 1068 : 				{
; 1069 : 					start = &(string[i]);

  001c9	8d 14 2e	 lea	 edx, DWORD PTR [esi+ebp]
  001cc	0f 1f 40 00	 npad	 4
$LL9@strbreak:

; 1070 : 					while (end--)
; 1071 : 						*right++ = (cell)*start++;

  001d0	0f be 02	 movsx	 eax, BYTE PTR [edx]
  001d3	8d 52 01	 lea	 edx, DWORD PTR [edx+1]
  001d6	89 07		 mov	 DWORD PTR [edi], eax
  001d8	83 c7 04	 add	 edi, 4
  001db	83 e9 01	 sub	 ecx, 1
  001de	75 f0		 jne	 SHORT $LL9@strbreak

; 1082 : 		*right = '\0';

  001e0	89 0f		 mov	 DWORD PTR [edi], ecx

; 1083 : 
; 1084 : 	return 1;

  001e2	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  001e5	5f		 pop	 edi
  001e6	5e		 pop	 esi
  001e7	5d		 pop	 ebp
  001e8	5b		 pop	 ebx

; 1085 : }

  001e9	83 c4 14	 add	 esp, 20			; 00000014H
  001ec	c3		 ret	 0
?strbreak@@YAHPAUtagAMX@@PAH@Z ENDP			; strbreak
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?argparse@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_input$1$ = -12						; size = 4
_temp$ = -8						; size = 4
_buflen$1$ = -4						; size = 4
_amx$ = 8						; size = 4
_in_quote$1$ = 12					; size = 1
_params$ = 12						; size = 4
?argparse@@YAHPAUtagAMX@@PAH@Z PROC			; argparse, COMDAT

; 974  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi

; 975  : 	int temp;
; 976  : 	const char *input = get_amxstring(amx, params[1], 0, temp);

  00006	8b 74 24 1c	 mov	 esi, DWORD PTR _amx$[esp+20]
  0000a	8d 44 24 10	 lea	 eax, DWORD PTR _temp$[esp+24]
  0000e	57		 push	 edi
  0000f	8b 7c 24 24	 mov	 edi, DWORD PTR _params$[esp+24]
  00013	50		 push	 eax
  00014	6a 00		 push	 0
  00016	ff 77 04	 push	 DWORD PTR [edi+4]
  00019	56		 push	 esi
  0001a	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring

; 977  : 	size_t input_len = size_t(temp);
; 978  : 	size_t start_pos = size_t(params[2]);
; 979  : 
; 980  : 	cell *buffer = get_amxaddr(amx, params[3]);

  0001f	ff 77 0c	 push	 DWORD PTR [edi+12]
  00022	89 44 24 24	 mov	 DWORD PTR _input$1$[esp+48], eax
  00026	56		 push	 esi
  00027	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 981  : 	size_t buflen = size_t(params[4]);
; 982  : 
; 983  : 	// Strip all left-hand whitespace.
; 984  : 	size_t i = start_pos;

  0002c	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  0002f	83 c4 18	 add	 esp, 24			; 00000018H

; 985  : 	while (i < input_len && isspace(input[i]))

  00032	8b 6c 24 14	 mov	 ebp, DWORD PTR _temp$[esp+28]
  00036	8b d8		 mov	 ebx, eax
  00038	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0003b	89 44 24 18	 mov	 DWORD PTR _buflen$1$[esp+28], eax
  0003f	3b f5		 cmp	 esi, ebp
  00041	73 23		 jae	 SHORT $LN21@argparse
  00043	8b 7c 24 10	 mov	 edi, DWORD PTR _input$1$[esp+28]
  00047	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL2@argparse:
  00050	0f be 0c 3e	 movsx	 ecx, BYTE PTR [esi+edi]
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 _isspace
  0005a	83 c4 04	 add	 esp, 4
  0005d	85 c0		 test	 eax, eax
  0005f	74 16		 je	 SHORT $LN3@argparse

; 986  : 		i++;

  00061	46		 inc	 esi
  00062	3b f5		 cmp	 esi, ebp
  00064	72 ea		 jb	 SHORT $LL2@argparse
$LN21@argparse:
  00066	5f		 pop	 edi
  00067	5e		 pop	 esi
  00068	5d		 pop	 ebp

; 989  : 		*buffer = '\0';

  00069	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0

; 990  : 		return -1;

  0006f	83 c8 ff	 or	 eax, -1
  00072	5b		 pop	 ebx

; 1014 : }

  00073	83 c4 0c	 add	 esp, 12			; 0000000cH
  00076	c3		 ret	 0
$LN3@argparse:

; 987  : 
; 988  : 	if (i >= input_len) {

  00077	3b f5		 cmp	 esi, ebp
  00079	73 eb		 jae	 SHORT $LN21@argparse

; 991  : 	}
; 992  : 
; 993  : 	cell *bufpos = buffer;
; 994  : 
; 995  : 	bool in_quote = false;

  0007b	32 c9		 xor	 cl, cl
  0007d	33 ff		 xor	 edi, edi
  0007f	88 4c 24 24	 mov	 BYTE PTR _in_quote$1$[esp+24], cl
$LL6@argparse:

; 997  : 		// Ignore quotes, except as an indicator as to whether to stop
; 998  : 		// at a space.
; 999  : 		if (input[i] == '"') {

  00083	8b 44 24 10	 mov	 eax, DWORD PTR _input$1$[esp+28]
  00087	8a 04 06	 mov	 al, BYTE PTR [esi+eax]
  0008a	3c 22		 cmp	 al, 34			; 00000022H
  0008c	75 0b		 jne	 SHORT $LN8@argparse

; 1000 : 			in_quote = !in_quote;

  0008e	84 c9		 test	 cl, cl
  00090	0f 94 c1	 sete	 cl
  00093	88 4c 24 24	 mov	 BYTE PTR _in_quote$1$[esp+24], cl

; 1001 : 			continue;

  00097	eb 33		 jmp	 SHORT $LN4@argparse
$LN8@argparse:

; 1002 : 		}
; 1003 : 
; 1004 : 		// If not in quotes, and we see a space, stop.
; 1005 : 		if (isspace(input[i]) && !in_quote)

  00099	0f be c0	 movsx	 eax, al
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 _isspace
  000a2	8a 4c 24 28	 mov	 cl, BYTE PTR _in_quote$1$[esp+28]
  000a6	83 c4 04	 add	 esp, 4
  000a9	85 c0		 test	 eax, eax
  000ab	74 04		 je	 SHORT $LN9@argparse
  000ad	84 c9		 test	 cl, cl
  000af	74 20		 je	 SHORT $LN14@argparse
$LN9@argparse:

; 1006 : 			break;
; 1007 : 
; 1008 : 		if (size_t(bufpos - buffer) < buflen)

  000b1	8b c7		 mov	 eax, edi
  000b3	c1 f8 02	 sar	 eax, 2
  000b6	3b 44 24 18	 cmp	 eax, DWORD PTR _buflen$1$[esp+28]
  000ba	73 10		 jae	 SHORT $LN4@argparse

; 1009 : 			*bufpos++ = input[i];

  000bc	8b 44 24 10	 mov	 eax, DWORD PTR _input$1$[esp+28]
  000c0	0f be 04 06	 movsx	 eax, BYTE PTR [esi+eax]
  000c4	89 03		 mov	 DWORD PTR [ebx], eax
  000c6	83 c3 04	 add	 ebx, 4
  000c9	83 c7 04	 add	 edi, 4
$LN4@argparse:

; 996  : 	for (; i < input_len; i++) {

  000cc	46		 inc	 esi
  000cd	3b f5		 cmp	 esi, ebp
  000cf	72 b2		 jb	 SHORT $LL6@argparse
$LN14@argparse:
  000d1	5f		 pop	 edi

; 1010 : 	}
; 1011 : 
; 1012 : 	*bufpos = '\0';
; 1013 : 	return i;

  000d2	8b c6		 mov	 eax, esi
  000d4	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
  000da	5e		 pop	 esi
  000db	5d		 pop	 ebp
  000dc	5b		 pop	 ebx

; 1014 : }

  000dd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e0	c3		 ret	 0
?argparse@@YAHPAUtagAMX@@PAH@Z ENDP			; argparse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?amx_strtok2@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_token$1$ = -37						; size = 1
_trim$1$ = -36						; size = 4
_right$1$ = -32						; size = 4
_left$1$ = -28						; size = 4
_string$1$ = -24					; size = 4
_len$ = -20						; size = 4
_pos$1$ = -16						; size = 4
tv512 = -12						; size = 4
_left_max$1$ = -8					; size = 4
_right_max$1$ = -4					; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?amx_strtok2@@YAHPAUtagAMX@@PAH@Z PROC			; amx_strtok2, COMDAT

; 898  : {

  00000	83 ec 28	 sub	 esp, 40			; 00000028H
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	57		 push	 edi

; 899  : 	int left_pos = 0, right_pos = 0, len, pos = -1;
; 900  : 	unsigned int i = 0;
; 901  : 
; 902  : 	char *string = get_amxstring(amx, params[1], 0, len);

  00007	8d 44 24 24	 lea	 eax, DWORD PTR _len$[esp+56]
  0000b	c7 44 24 28 ff
	ff ff ff	 mov	 DWORD PTR _pos$1$[esp+56], -1
  00013	50		 push	 eax
  00014	8b 44 24 44	 mov	 eax, DWORD PTR _params$[esp+56]
  00018	33 f6		 xor	 esi, esi
  0001a	56		 push	 esi
  0001b	33 ed		 xor	 ebp, ebp
  0001d	33 db		 xor	 ebx, ebx
  0001f	ff 70 04	 push	 DWORD PTR [eax+4]
  00022	ff 74 24 48	 push	 DWORD PTR _amx$[esp+64]
  00026	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring

; 903  : 	char *left = new char[len + 1], *right = new char[len + 1];

  0002b	8b 7c 24 34	 mov	 edi, DWORD PTR _len$[esp+72]
  0002f	47		 inc	 edi
  00030	89 44 24 30	 mov	 DWORD PTR _string$1$[esp+72], eax
  00034	57		 push	 edi
  00035	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0003a	57		 push	 edi
  0003b	89 44 24 34	 mov	 DWORD PTR _left$1$[esp+80], eax
  0003f	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 904  : 	int left_max = params[3], right_max = params[5];

  00044	8b 4c 24 58	 mov	 ecx, DWORD PTR _params$[esp+76]
  00048	83 c4 18	 add	 esp, 24			; 00000018H

; 905  : 	char token = static_cast<char>(params[6]);
; 906  : 	
; 907  : 	/*	Trim flags:
; 908  : 			1 - ltrim left
; 909  : 			2 - rtrim left
; 910  : 			4 - ltrim right
; 911  : 			8 - rtrim right
; 912  : 	*/
; 913  : 	int trim = params[7];
; 914  : 
; 915  : 	// ltrim left
; 916  : 	if (trim & 1 && isspace(string[i]))

  0004b	8b 7c 24 20	 mov	 edi, DWORD PTR _string$1$[esp+56]
  0004f	89 44 24 18	 mov	 DWORD PTR _right$1$[esp+56], eax
  00053	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00056	89 44 24 30	 mov	 DWORD PTR _left_max$1$[esp+56], eax
  0005a	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0005d	89 44 24 34	 mov	 DWORD PTR _right_max$1$[esp+56], eax
  00061	8a 61 18	 mov	 ah, BYTE PTR [ecx+24]
  00064	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00067	88 64 24 13	 mov	 BYTE PTR _token$1$[esp+56], ah
  0006b	89 4c 24 14	 mov	 DWORD PTR _trim$1$[esp+56], ecx
  0006f	f6 c1 01	 test	 cl, 1
  00072	74 27		 je	 SHORT $LN3@amx_strtok
  00074	0f be 07	 movsx	 eax, BYTE PTR [edi]
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 _isspace
  0007d	83 c4 04	 add	 esp, 4
  00080	85 c0		 test	 eax, eax
  00082	74 13		 je	 SHORT $LN46@amx_strtok
$LL2@amx_strtok:

; 917  : 	{
; 918  : 		while (isspace(string[++i]));

  00084	0f be 44 37 01	 movsx	 eax, BYTE PTR [edi+esi+1]
  00089	46		 inc	 esi
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 _isspace
  00090	83 c4 04	 add	 esp, 4
  00093	85 c0		 test	 eax, eax
  00095	75 ed		 jne	 SHORT $LL2@amx_strtok
$LN46@amx_strtok:
  00097	8a 64 24 13	 mov	 ah, BYTE PTR _token$1$[esp+56]
$LN3@amx_strtok:

; 919  : 	}
; 920  : 
; 921  : 	for (; i < (unsigned int) len; ++i)

  0009b	8b 54 24 24	 mov	 edx, DWORD PTR _len$[esp+56]
  0009f	3b f2		 cmp	 esi, edx
  000a1	73 24		 jae	 SHORT $LN5@amx_strtok
  000a3	8b 4c 24 1c	 mov	 ecx, DWORD PTR _left$1$[esp+56]
  000a7	2b ce		 sub	 ecx, esi
  000a9	0f 1f 80 00 00
	00 00		 npad	 7
$LL6@amx_strtok:

; 922  : 	{
; 923  : 		if (string[i] == token)

  000b0	8a 04 37	 mov	 al, BYTE PTR [edi+esi]
  000b3	3a c4		 cmp	 al, ah
  000b5	74 0b		 je	 SHORT $LN28@amx_strtok

; 927  : 			break;
; 928  : 		}
; 929  : 
; 930  : 		left[left_pos++] = string[i];

  000b7	88 04 31	 mov	 BYTE PTR [ecx+esi], al
  000ba	45		 inc	 ebp
  000bb	46		 inc	 esi
  000bc	3b f2		 cmp	 esi, edx
  000be	72 f0		 jb	 SHORT $LL6@amx_strtok

; 922  : 	{
; 923  : 		if (string[i] == token)

  000c0	eb 05		 jmp	 SHORT $LN5@amx_strtok
$LN28@amx_strtok:

; 924  : 		{
; 925  : 			pos = i;

  000c2	89 74 24 28	 mov	 DWORD PTR _pos$1$[esp+56], esi

; 926  : 			++i;

  000c6	46		 inc	 esi
$LN5@amx_strtok:

; 931  : 	}
; 932  : 
; 933  : 	// rtrim left
; 934  : 	if (trim & 2 && left_pos && isspace(left[left_pos - 1]))

  000c7	8b 44 24 14	 mov	 eax, DWORD PTR _trim$1$[esp+56]
  000cb	a8 02		 test	 al, 2
  000cd	74 4b		 je	 SHORT $LN18@amx_strtok
  000cf	85 ed		 test	 ebp, ebp
  000d1	74 47		 je	 SHORT $LN18@amx_strtok
  000d3	8b 44 24 1c	 mov	 eax, DWORD PTR _left$1$[esp+56]
  000d7	0f be 44 28 ff	 movsx	 eax, BYTE PTR [eax+ebp-1]
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 _isspace
  000e2	83 c4 04	 add	 esp, 4
  000e5	85 c0		 test	 eax, eax
  000e7	74 2d		 je	 SHORT $LN49@amx_strtok
  000e9	8b 7c 24 1c	 mov	 edi, DWORD PTR _left$1$[esp+56]
  000ed	0f 1f 00	 npad	 3
$LL7@amx_strtok:
  000f0	8b c5		 mov	 eax, ebp

; 935  : 	{
; 936  : 		while (--left_pos >= 0 && isspace(left[left_pos]));

  000f2	83 ed 01	 sub	 ebp, 1
  000f5	89 44 24 2c	 mov	 DWORD PTR tv512[esp+56], eax
  000f9	78 15		 js	 SHORT $LN8@amx_strtok
  000fb	0f be 04 2f	 movsx	 eax, BYTE PTR [edi+ebp]
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 _isspace
  00105	83 c4 04	 add	 esp, 4
  00108	85 c0		 test	 eax, eax
  0010a	75 e4		 jne	 SHORT $LL7@amx_strtok
  0010c	8b 44 24 2c	 mov	 eax, DWORD PTR tv512[esp+56]
$LN8@amx_strtok:
  00110	8b 7c 24 20	 mov	 edi, DWORD PTR _string$1$[esp+56]

; 937  : 		
; 938  : 		++left_pos;

  00114	8b e8		 mov	 ebp, eax
$LN49@amx_strtok:
  00116	8b 44 24 14	 mov	 eax, DWORD PTR _trim$1$[esp+56]
$LN18@amx_strtok:

; 939  : 	}
; 940  : 
; 941  : 	// ltrim right
; 942  : 	if (trim & 4 && isspace(string[i]))

  0011a	a8 04		 test	 al, 4
  0011c	74 25		 je	 SHORT $LN10@amx_strtok
  0011e	0f be 04 37	 movsx	 eax, BYTE PTR [edi+esi]
  00122	50		 push	 eax
  00123	e8 00 00 00 00	 call	 _isspace
  00128	83 c4 04	 add	 esp, 4
  0012b	85 c0		 test	 eax, eax
  0012d	74 14		 je	 SHORT $LN10@amx_strtok
  0012f	90		 npad	 1
$LL9@amx_strtok:

; 943  : 	{
; 944  : 		while (isspace(string[++i]));

  00130	0f be 44 37 01	 movsx	 eax, BYTE PTR [edi+esi+1]
  00135	46		 inc	 esi
  00136	50		 push	 eax
  00137	e8 00 00 00 00	 call	 _isspace
  0013c	83 c4 04	 add	 esp, 4
  0013f	85 c0		 test	 eax, eax
  00141	75 ed		 jne	 SHORT $LL9@amx_strtok
$LN10@amx_strtok:

; 945  : 	}
; 946  : 
; 947  : 	for (; i < (unsigned int) len; ++i)

  00143	8b 54 24 24	 mov	 edx, DWORD PTR _len$[esp+56]
  00147	3b f2		 cmp	 esi, edx
  00149	73 15		 jae	 SHORT $LN12@amx_strtok
  0014b	8b 4c 24 18	 mov	 ecx, DWORD PTR _right$1$[esp+56]
  0014f	8b da		 mov	 ebx, edx
  00151	2b ce		 sub	 ecx, esi
  00153	2b de		 sub	 ebx, esi
$LL13@amx_strtok:

; 948  : 	{
; 949  : 		right[right_pos++] = string[i];	

  00155	8a 04 37	 mov	 al, BYTE PTR [edi+esi]
  00158	88 04 31	 mov	 BYTE PTR [ecx+esi], al
  0015b	46		 inc	 esi
  0015c	3b f2		 cmp	 esi, edx
  0015e	72 f5		 jb	 SHORT $LL13@amx_strtok
$LN12@amx_strtok:

; 950  : 	}
; 951  : 
; 952  : 	// rtrim right
; 953  : 	if (trim & 8 && right_pos && isspace(right[right_pos - 1]))

  00160	f6 44 24 14 08	 test	 BYTE PTR _trim$1$[esp+56], 8
  00165	8b 7c 24 18	 mov	 edi, DWORD PTR _right$1$[esp+56]
  00169	74 30		 je	 SHORT $LN20@amx_strtok
  0016b	85 db		 test	 ebx, ebx
  0016d	74 2c		 je	 SHORT $LN20@amx_strtok
  0016f	0f be 44 1f ff	 movsx	 eax, BYTE PTR [edi+ebx-1]
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 _isspace
  0017a	83 c4 04	 add	 esp, 4
  0017d	85 c0		 test	 eax, eax
  0017f	74 1a		 je	 SHORT $LN20@amx_strtok
$LL14@amx_strtok:
  00181	8b f3		 mov	 esi, ebx

; 954  : 	{
; 955  : 		while (--right_pos >= 0 && isspace(right[right_pos]));

  00183	83 eb 01	 sub	 ebx, 1
  00186	78 11		 js	 SHORT $LN15@amx_strtok
  00188	0f be 04 1f	 movsx	 eax, BYTE PTR [edi+ebx]
  0018c	50		 push	 eax
  0018d	e8 00 00 00 00	 call	 _isspace
  00192	83 c4 04	 add	 esp, 4
  00195	85 c0		 test	 eax, eax
  00197	75 e8		 jne	 SHORT $LL14@amx_strtok
$LN15@amx_strtok:

; 956  : 
; 957  : 		++right_pos;

  00199	8b de		 mov	 ebx, esi
$LN20@amx_strtok:

; 958  : 	}
; 959  : 
; 960  : 	right[right_pos] = 0;

  0019b	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 961  : 	left[left_pos] = 0;

  0019f	8b 5c 24 1c	 mov	 ebx, DWORD PTR _left$1$[esp+56]

; 962  : 
; 963  : 	set_amxstring_utf8(amx, params[2], left, strlen(left), left_max);

  001a3	8b cb		 mov	 ecx, ebx
  001a5	c6 04 2b 00	 mov	 BYTE PTR [ebx+ebp], 0
  001a9	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  001ac	0f 1f 40 00	 npad	 4
$LL43@amx_strtok:
  001b0	8a 01		 mov	 al, BYTE PTR [ecx]
  001b2	41		 inc	 ecx
  001b3	84 c0		 test	 al, al
  001b5	75 f9		 jne	 SHORT $LL43@amx_strtok
  001b7	ff 74 24 30	 push	 DWORD PTR _left_max$1$[esp+56]
  001bb	8b 6c 24 44	 mov	 ebp, DWORD PTR _params$[esp+56]
  001bf	2b ca		 sub	 ecx, edx
  001c1	8b 74 24 40	 mov	 esi, DWORD PTR _amx$[esp+56]
  001c5	51		 push	 ecx
  001c6	53		 push	 ebx
  001c7	ff 75 08	 push	 DWORD PTR [ebp+8]
  001ca	56		 push	 esi
  001cb	e8 00 00 00 00	 call	 ??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z ; set_amxstring_utf8<char>

; 964  : 	set_amxstring_utf8(amx, params[4], right, strlen(right), right_max);

  001d0	8b cf		 mov	 ecx, edi
  001d2	83 c4 14	 add	 esp, 20			; 00000014H
  001d5	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL44@amx_strtok:
  001d8	8a 01		 mov	 al, BYTE PTR [ecx]
  001da	41		 inc	 ecx
  001db	84 c0		 test	 al, al
  001dd	75 f9		 jne	 SHORT $LL44@amx_strtok
  001df	ff 74 24 34	 push	 DWORD PTR _right_max$1$[esp+56]
  001e3	2b ca		 sub	 ecx, edx
  001e5	51		 push	 ecx
  001e6	57		 push	 edi
  001e7	ff 75 10	 push	 DWORD PTR [ebp+16]
  001ea	56		 push	 esi
  001eb	e8 00 00 00 00	 call	 ??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z ; set_amxstring_utf8<char>

; 965  : 
; 966  : 	delete [] left;

  001f0	53		 push	 ebx
  001f1	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 967  : 	delete [] right;

  001f6	57		 push	 edi
  001f7	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 968  : 
; 969  : 	return pos;

  001fc	8b 44 24 44	 mov	 eax, DWORD PTR _pos$1$[esp+84]
  00200	83 c4 1c	 add	 esp, 28			; 0000001cH
  00203	5f		 pop	 edi
  00204	5e		 pop	 esi
  00205	5d		 pop	 ebp
  00206	5b		 pop	 ebx

; 970  : }

  00207	83 c4 28	 add	 esp, 40			; 00000028H
  0020a	c3		 ret	 0
?amx_strtok2@@YAHPAUtagAMX@@PAH@Z ENDP			; amx_strtok2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?amx_strtok@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_len$ = -28						; size = 4
_right_pos$1$ = -24					; size = 4
_right$1$ = -20						; size = 4
_left$1$ = -16						; size = 4
_trim$1$ = -12						; size = 4
_leftMax$1$ = -8					; size = 4
_rightMax$1$ = -4					; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?amx_strtok@@YAHPAUtagAMX@@PAH@Z PROC			; amx_strtok, COMDAT

; 841  : {

  00000	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	57		 push	 edi

; 842  : 	int left_pos = 0;
; 843  : 	int right_pos = 0;
; 844  : 	unsigned int i = 0;
; 845  : 	bool done_flag = false;
; 846  : 	int len = 0;
; 847  : 
; 848  : 	//string[]
; 849  : 	char *string = get_amxstring(amx, params[1], 0, len);

  00007	8b 7c 24 34	 mov	 edi, DWORD PTR _params$[esp+40]
  0000b	8d 44 24 10	 lea	 eax, DWORD PTR _len$[esp+44]
  0000f	50		 push	 eax
  00010	33 ed		 xor	 ebp, ebp
  00012	32 db		 xor	 bl, bl
  00014	55		 push	 ebp
  00015	ff 77 04	 push	 DWORD PTR [edi+4]
  00018	89 6c 24 20	 mov	 DWORD PTR _right_pos$1$[esp+56], ebp
  0001c	ff 74 24 3c	 push	 DWORD PTR _amx$[esp+52]
  00020	89 6c 24 20	 mov	 DWORD PTR _len$[esp+60], ebp
  00024	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring

; 850  : 	//left[]
; 851  : 	char *left = new char[len + 1];

  00029	8b 74 24 20	 mov	 esi, DWORD PTR _len$[esp+60]
  0002d	8b f8		 mov	 edi, eax
  0002f	46		 inc	 esi
  00030	56		 push	 esi
  00031	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]

; 852  : 	//right[]
; 853  : 	char *right = new char[len + 1];

  00036	56		 push	 esi
  00037	89 44 24 34	 mov	 DWORD PTR _left$1$[esp+68], eax
  0003b	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00040	89 44 24 30	 mov	 DWORD PTR _right$1$[esp+68], eax

; 854  : 	int leftMax = params[3];
; 855  : 	int rightMax = params[5];
; 856  : 	//token
; 857  : 	char token = static_cast<char>(params[6]);
; 858  : 	//trim
; 859  : 	int trim = params[7];
; 860  : 	
; 861  : 	for (i = 0; i < (unsigned int)len; i++)

  00044	33 f6		 xor	 esi, esi
  00046	8b 44 24 4c	 mov	 eax, DWORD PTR _params$[esp+64]
  0004a	83 c4 18	 add	 esp, 24			; 00000018H
  0004d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00050	8a 78 18	 mov	 bh, BYTE PTR [eax+24]
  00053	89 4c 24 24	 mov	 DWORD PTR _leftMax$1$[esp+44], ecx
  00057	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0005a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0005d	89 4c 24 28	 mov	 DWORD PTR _rightMax$1$[esp+44], ecx
  00061	89 44 24 20	 mov	 DWORD PTR _trim$1$[esp+44], eax
  00065	39 74 24 10	 cmp	 DWORD PTR _len$[esp+44], esi
  00069	76 59		 jbe	 SHORT $LN3@amx_strtok
  0006b	0f 1f 44 00 00	 npad	 5
$LL4@amx_strtok:

; 862  : 	{
; 863  : 		if (trim && !done_flag)

  00070	85 c0		 test	 eax, eax
  00072	0f 84 c4 00 00
	00		 je	 $LN8@amx_strtok
  00078	84 db		 test	 bl, bl
  0007a	75 2a		 jne	 SHORT $LN20@amx_strtok

; 864  : 		{
; 865  : 			if (isspace(string[i]))

  0007c	0f be 04 37	 movsx	 eax, BYTE PTR [edi+esi]
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 _isspace
  00086	83 c4 04	 add	 esp, 4
  00089	85 c0		 test	 eax, eax
  0008b	0f 84 b3 00 00
	00		 je	 $LN21@amx_strtok
$LL5@amx_strtok:

; 866  : 			{
; 867  : 				while (isspace(string[++i]));

  00091	0f be 44 37 01	 movsx	 eax, BYTE PTR [edi+esi+1]
  00096	46		 inc	 esi
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 _isspace
  0009d	83 c4 04	 add	 esp, 4
  000a0	85 c0		 test	 eax, eax
  000a2	75 ed		 jne	 SHORT $LL5@amx_strtok

; 868  : 				done_flag = true;

  000a4	b3 01		 mov	 bl, 1
$LN20@amx_strtok:

; 876  : 		}
; 877  : 
; 878  : 		if (done_flag)
; 879  : 		{
; 880  : 			right[right_pos++] = string[i];

  000a6	8b 4c 24 14	 mov	 ecx, DWORD PTR _right_pos$1$[esp+44]
  000aa	8b 54 24 18	 mov	 edx, DWORD PTR _right$1$[esp+44]
  000ae	8a 04 37	 mov	 al, BYTE PTR [edi+esi]
  000b1	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  000b4	41		 inc	 ecx
  000b5	89 4c 24 14	 mov	 DWORD PTR _right_pos$1$[esp+44], ecx
$LN2@amx_strtok:

; 854  : 	int leftMax = params[3];
; 855  : 	int rightMax = params[5];
; 856  : 	//token
; 857  : 	char token = static_cast<char>(params[6]);
; 858  : 	//trim
; 859  : 	int trim = params[7];
; 860  : 	
; 861  : 	for (i = 0; i < (unsigned int)len; i++)

  000b9	8b 44 24 20	 mov	 eax, DWORD PTR _trim$1$[esp+44]
  000bd	46		 inc	 esi
  000be	3b 74 24 10	 cmp	 esi, DWORD PTR _len$[esp+44]
  000c2	72 ac		 jb	 SHORT $LL4@amx_strtok
$LN3@amx_strtok:

; 883  : 		}
; 884  : 	}
; 885  : 
; 886  : 	right[right_pos] = 0;
; 887  : 	left[left_pos] = 0;

  000c4	8b 74 24 1c	 mov	 esi, DWORD PTR _left$1$[esp+44]

; 888  : 	set_amxstring_utf8(amx, params[2], left, strlen(left), leftMax);

  000c8	8b ce		 mov	 ecx, esi
  000ca	8b 44 24 14	 mov	 eax, DWORD PTR _right_pos$1$[esp+44]
  000ce	8b 5c 24 18	 mov	 ebx, DWORD PTR _right$1$[esp+44]
  000d2	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  000d5	c6 04 03 00	 mov	 BYTE PTR [ebx+eax], 0
  000d9	c6 04 2e 00	 mov	 BYTE PTR [esi+ebp], 0
  000dd	0f 1f 00	 npad	 3
$LL22@amx_strtok:
  000e0	8a 01		 mov	 al, BYTE PTR [ecx]
  000e2	41		 inc	 ecx
  000e3	84 c0		 test	 al, al
  000e5	75 f9		 jne	 SHORT $LL22@amx_strtok
  000e7	ff 74 24 24	 push	 DWORD PTR _leftMax$1$[esp+44]
  000eb	8b 7c 24 38	 mov	 edi, DWORD PTR _params$[esp+44]
  000ef	2b ca		 sub	 ecx, edx
  000f1	8b 6c 24 34	 mov	 ebp, DWORD PTR _amx$[esp+44]
  000f5	51		 push	 ecx
  000f6	56		 push	 esi
  000f7	ff 77 08	 push	 DWORD PTR [edi+8]
  000fa	55		 push	 ebp
  000fb	e8 00 00 00 00	 call	 ??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z ; set_amxstring_utf8<char>

; 889  : 	set_amxstring_utf8(amx, params[4], right, strlen(right), rightMax);

  00100	8b cb		 mov	 ecx, ebx
  00102	83 c4 14	 add	 esp, 20			; 00000014H
  00105	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL23@amx_strtok:
  00108	8a 01		 mov	 al, BYTE PTR [ecx]
  0010a	41		 inc	 ecx
  0010b	84 c0		 test	 al, al
  0010d	75 f9		 jne	 SHORT $LL23@amx_strtok
  0010f	ff 74 24 28	 push	 DWORD PTR _rightMax$1$[esp+44]
  00113	2b ca		 sub	 ecx, edx
  00115	51		 push	 ecx
  00116	53		 push	 ebx
  00117	ff 77 10	 push	 DWORD PTR [edi+16]
  0011a	55		 push	 ebp
  0011b	e8 00 00 00 00	 call	 ??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z ; set_amxstring_utf8<char>

; 890  : 	delete [] left;

  00120	56		 push	 esi
  00121	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]

; 891  : 	delete [] right;

  00126	53		 push	 ebx
  00127	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0012c	83 c4 1c	 add	 esp, 28			; 0000001cH

; 892  : 	
; 893  : 	return 1;

  0012f	b8 01 00 00 00	 mov	 eax, 1
  00134	5f		 pop	 edi
  00135	5e		 pop	 esi
  00136	5d		 pop	 ebp
  00137	5b		 pop	 ebx

; 894  : }

  00138	83 c4 1c	 add	 esp, 28			; 0000001cH
  0013b	c3		 ret	 0
$LN8@amx_strtok:

; 869  : 			}
; 870  : 		}
; 871  : 
; 872  : 		if (!done_flag && string[i] == token)

  0013c	84 db		 test	 bl, bl
  0013e	0f 85 62 ff ff
	ff		 jne	 $LN20@amx_strtok
$LN21@amx_strtok:
  00144	8a 04 37	 mov	 al, BYTE PTR [edi+esi]
  00147	3a c7		 cmp	 al, bh
  00149	75 08		 jne	 SHORT $LN10@amx_strtok

; 873  : 		{
; 874  : 			done_flag = true;

  0014b	b3 01		 mov	 bl, 1

; 875  : 			i++;

  0014d	46		 inc	 esi
  0014e	e9 53 ff ff ff	 jmp	 $LN20@amx_strtok
$LN10@amx_strtok:

; 881  : 		} else {
; 882  : 			left[left_pos++] = string[i];

  00153	8b 4c 24 1c	 mov	 ecx, DWORD PTR _left$1$[esp+44]
  00157	88 04 29	 mov	 BYTE PTR [ecx+ebp], al
  0015a	45		 inc	 ebp
  0015b	e9 59 ff ff ff	 jmp	 $LN2@amx_strtok
?amx_strtok@@YAHPAUtagAMX@@PAH@Z ENDP			; amx_strtok
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?format_arguments@@YAPADPAUtagAMX@@HAAH@Z
_TEXT	SEGMENT
_numparam$1$ = -4					; size = 4
_amx$ = 8						; size = 4
_parm$ = 12						; size = 4
_len$ = 16						; size = 4
?format_arguments@@YAPADPAUtagAMX@@HAAH@Z PROC		; format_arguments, COMDAT

; 792  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 c0	 and	 esp, -64		; ffffffc0H
  00006	83 ec 34	 sub	 esp, 52			; 00000034H
  00009	53		 push	 ebx

; 793  : 	static char buffer[2][3072];
; 794  : 	static char format[16];
; 795  : 	char *ptr, *arg, *dest = *buffer;
; 796  : 	char *src = fo_getargstr(amx, 0, parm++);

  0000a	8b 5d 0c	 mov	 ebx, DWORD PTR _parm$[ebp]
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	53		 push	 ebx
  00010	6a 00		 push	 0
  00012	ff 75 08	 push	 DWORD PTR _amx$[ebp]
  00015	be 00 00 00 00	 mov	 esi, OFFSET ?buffer@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PAY0MAA@DA
  0001a	e8 00 00 00 00	 call	 ?fo_getargstr@@YAPADPAUtagAMX@@HH@Z ; fo_getargstr

; 797  : 	int numparam = fo_numargs(amx);

  0001f	ff 75 08	 push	 DWORD PTR _amx$[ebp]
  00022	43		 inc	 ebx
  00023	8b f8		 mov	 edi, eax
  00025	89 5d 0c	 mov	 DWORD PTR _parm$[ebp], ebx
  00028	e8 00 00 00 00	 call	 ?fo_numargs@@YAHPAUtagAMX@@@Z ; fo_numargs

; 798  : 
; 799  : 	while (*src)

  0002d	8a 0f		 mov	 cl, BYTE PTR [edi]
  0002f	83 c4 10	 add	 esp, 16			; 00000010H
  00032	89 44 24 3c	 mov	 DWORD PTR _numparam$1$[esp+64], eax
  00036	84 c9		 test	 cl, cl
  00038	0f 84 f5 00 00
	00		 je	 $LN3@format_arg
  0003e	66 90		 npad	 2
$LL2@format_arg:

; 800  : 	{
; 801  : 		if (*src == '%' && *(src + 1))

  00040	80 f9 25	 cmp	 cl, 37			; 00000025H
  00043	0f 85 dc 00 00
	00		 jne	 $LN10@format_arg
  00049	80 7f 01 00	 cmp	 BYTE PTR [edi+1], 0
  0004d	0f 84 d2 00 00
	00		 je	 $LN10@format_arg

; 802  : 		{
; 803  : 			ptr = format;
; 804  : 			*ptr++ = *src++;

  00053	47		 inc	 edi
  00054	88 0d 00 00 00
	00		 mov	 BYTE PTR ?format@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PADA, cl
  0005a	bb 01 00 00 00	 mov	 ebx, OFFSET ?format@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PADA+1

; 805  : 			
; 806  : 			if (*src == '%')

  0005f	38 0f		 cmp	 BYTE PTR [edi], cl
  00061	75 0d		 jne	 SHORT $LL4@format_arg

; 807  : 			{
; 808  : 				*dest++ = *src++;

  00063	88 0e		 mov	 BYTE PTR [esi], cl

; 809  : 				continue;

  00065	e9 bd 00 00 00	 jmp	 $LN45@format_arg
  0006a	66 0f 1f 44 00
	00		 npad	 6
$LL4@format_arg:

; 810  : 			}
; 811  : 			
; 812  : 			while (!isalpha(*ptr++ = *src++));

  00070	8a 07		 mov	 al, BYTE PTR [edi]
  00072	88 03		 mov	 BYTE PTR [ebx], al
  00074	0f be c0	 movsx	 eax, al
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 _isalpha
  0007d	83 c4 04	 add	 esp, 4
  00080	8d 5b 01	 lea	 ebx, DWORD PTR [ebx+1]
  00083	47		 inc	 edi
  00084	85 c0		 test	 eax, eax
  00086	74 e8		 je	 SHORT $LL4@format_arg

; 813  : 			
; 814  : 			*ptr='\0';
; 815  : 			if (numparam < parm) continue;

  00088	8b 55 0c	 mov	 edx, DWORD PTR _parm$[ebp]
  0008b	c6 03 00	 mov	 BYTE PTR [ebx], 0
  0008e	39 54 24 3c	 cmp	 DWORD PTR _numparam$1$[esp+64], edx
  00092	0f 8c 91 00 00
	00		 jl	 $LN24@format_arg

; 816  : 			arg = buffer[1];
; 817  : 			
; 818  : 			switch (*(ptr - 1))

  00098	8a 43 ff	 mov	 al, BYTE PTR [ebx-1]
  0009b	3c 66		 cmp	 al, 102			; 00000066H
  0009d	7c 48		 jl	 SHORT $LN15@format_arg
  0009f	3c 67		 cmp	 al, 103			; 00000067H
  000a1	7e 24		 jle	 SHORT $LN14@format_arg
  000a3	3c 73		 cmp	 al, 115			; 00000073H
  000a5	75 40		 jne	 SHORT $LN15@format_arg

; 819  : 			{
; 820  : 				case 's': sprintf(arg, format, fo_getargstr(amx, 1, parm++)); break;

  000a7	52		 push	 edx
  000a8	6a 01		 push	 1
  000aa	ff 75 08	 push	 DWORD PTR _amx$[ebp]
  000ad	e8 00 00 00 00	 call	 ?fo_getargstr@@YAPADPAUtagAMX@@HH@Z ; fo_getargstr
  000b2	50		 push	 eax
  000b3	68 00 00 00 00	 push	 OFFSET ?format@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PADA
  000b8	68 00 0c 00 00	 push	 OFFSET ?buffer@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PAY0MAA@DA+3072
  000bd	e8 00 00 00 00	 call	 _sprintf
  000c2	83 c4 18	 add	 esp, 24			; 00000018H
  000c5	eb 3c		 jmp	 SHORT $LN22@format_arg
$LN14@format_arg:

; 821  : 				case 'f': case 'g': sprintf(arg, format, fo_getargfloat(amx, parm++)); break;

  000c7	52		 push	 edx
  000c8	ff 75 08	 push	 DWORD PTR _amx$[ebp]
  000cb	e8 00 00 00 00	 call	 ?fo_getargfloat@@YAMPAUtagAMX@@H@Z ; fo_getargfloat
  000d0	dd 1c 24	 fstp	 QWORD PTR [esp]
  000d3	68 00 00 00 00	 push	 OFFSET ?format@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PADA
  000d8	68 00 0c 00 00	 push	 OFFSET ?buffer@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PAY0MAA@DA+3072
  000dd	e8 00 00 00 00	 call	 _sprintf
  000e2	83 c4 10	 add	 esp, 16			; 00000010H
  000e5	eb 1c		 jmp	 SHORT $LN22@format_arg
$LN15@format_arg:

; 822  : 				default: sprintf(arg, format, fo_getargnum(amx, parm++));

  000e7	52		 push	 edx
  000e8	ff 75 08	 push	 DWORD PTR _amx$[ebp]
  000eb	e8 00 00 00 00	 call	 ?fo_getargnum@@YAHPAUtagAMX@@H@Z ; fo_getargnum
  000f0	50		 push	 eax
  000f1	68 00 00 00 00	 push	 OFFSET ?format@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PADA
  000f6	68 00 0c 00 00	 push	 OFFSET ?buffer@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PAY0MAA@DA+3072
  000fb	e8 00 00 00 00	 call	 _sprintf
  00100	83 c4 14	 add	 esp, 20			; 00000014H
$LN22@format_arg:

; 823  : 			}
; 824  : 			
; 825  : 			while (*arg) *dest++ = *arg++;

  00103	8a 0d 00 0c 00
	00		 mov	 cl, BYTE PTR ?buffer@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PAY0MAA@DA+3072
  00109	ff 45 0c	 inc	 DWORD PTR _parm$[ebp]
  0010c	84 c9		 test	 cl, cl
  0010e	74 19		 je	 SHORT $LN24@format_arg
  00110	ba 00 0c 00 00	 mov	 edx, OFFSET ?buffer@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PAY0MAA@DA+3072
  00115	2b d6		 sub	 edx, esi
$LL8@format_arg:
  00117	88 0e		 mov	 BYTE PTR [esi], cl
  00119	46		 inc	 esi
  0011a	8a 04 32	 mov	 al, BYTE PTR [edx+esi]
  0011d	8a c8		 mov	 cl, al
  0011f	84 c0		 test	 al, al
  00121	75 f4		 jne	 SHORT $LL8@format_arg

; 826  : 			continue;

  00123	eb 04		 jmp	 SHORT $LN24@format_arg
$LN10@format_arg:

; 827  : 		}
; 828  : 		*dest++ = *src++;

  00125	88 0e		 mov	 BYTE PTR [esi], cl
$LN45@format_arg:
  00127	46		 inc	 esi
  00128	47		 inc	 edi
$LN24@format_arg:

; 798  : 
; 799  : 	while (*src)

  00129	8a 0f		 mov	 cl, BYTE PTR [edi]
  0012b	84 c9		 test	 cl, cl
  0012d	0f 85 0d ff ff
	ff		 jne	 $LL2@format_arg
$LN3@format_arg:

; 829  : 	}
; 830  : 
; 831  : 	*dest = '\0';
; 832  : 	len = dest - *buffer;

  00133	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  00136	c6 06 00	 mov	 BYTE PTR [esi], 0
  00139	81 ee 00 00 00
	00		 sub	 esi, OFFSET ?buffer@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PAY0MAA@DA

; 833  : 	
; 834  : 	return *buffer;
; 835  : }

  0013f	5f		 pop	 edi
  00140	89 30		 mov	 DWORD PTR [eax], esi
  00142	b8 00 00 00 00	 mov	 eax, OFFSET ?buffer@?1??format_arguments@@YAPADPAUtagAMX@@HAAH@Z@4PAY0MAA@DA
  00147	5e		 pop	 esi
  00148	5b		 pop	 ebx
  00149	8b e5		 mov	 esp, ebp
  0014b	5d		 pop	 ebp
  0014c	c3		 ret	 0
?format_arguments@@YAPADPAUtagAMX@@HAAH@Z ENDP		; format_arguments
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?fo_getargstr@@YAPADPAUtagAMX@@HH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_swap$ = 12						; size = 4
_pos$ = 16						; size = 4
?fo_getargstr@@YAPADPAUtagAMX@@HH@Z PROC		; fo_getargstr, COMDAT

; 774  : 	unsigned char *data = amx->base + (int)((AMX_HEADER *)amx->base)->dat;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _amx$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b 01		 mov	 eax, DWORD PTR [ecx]

; 775  : 	cell src_value= *(cell *)(data + (int)amx->frm + (pos + 3) * sizeof(cell));

  00008	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0000b	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  0000e	03 f8		 add	 edi, eax
  00010	8b 44 24 14	 mov	 eax, DWORD PTR _pos$[esp+4]
  00014	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00017	8b 74 38 0c	 mov	 esi, DWORD PTR [eax+edi+12]

; 776  : 	cell value;
; 777  : 	static char buffer[2][3072];
; 778  : 	char* b = buffer[swap];

  0001b	69 44 24 10 00
	0c 00 00	 imul	 eax, DWORD PTR _swap$[esp+4], 3072
  00023	8d 80 00 00 00
	00		 lea	 eax, DWORD PTR ?buffer@?1??fo_getargstr@@YAPADPAUtagAMX@@HH@Z@4PAY0MAA@DA[eax]
  00029	8b c8		 mov	 ecx, eax
  0002b	0f 1f 44 00 00	 npad	 5
$LL4@fo_getargs:

; 779  : 	int a = 0;
; 780  : 	
; 781  : 	do
; 782  : 	{
; 783  : 		value = src_value + a++ * sizeof(cell);
; 784  : 		value = *(cell *)(data + (int)value);

  00030	8b 14 3e	 mov	 edx, DWORD PTR [esi+edi]
  00033	8d 76 04	 lea	 esi, DWORD PTR [esi+4]

; 785  : 		*b++ = static_cast<char>(value);

  00036	88 11		 mov	 BYTE PTR [ecx], dl
  00038	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]

; 786  : 	} while (value);

  0003b	85 d2		 test	 edx, edx
  0003d	75 f1		 jne	 SHORT $LL4@fo_getargs

; 787  : 
; 788  : 	return buffer[swap];
; 789  : }

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	c3		 ret	 0
?fo_getargstr@@YAPADPAUtagAMX@@HH@Z ENDP		; fo_getargstr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?fo_getargfloat@@YAMPAUtagAMX@@H@Z
_TEXT	SEGMENT
_number$ = 8						; size = 4
_amx$ = 8						; size = 4
_pos$ = 12						; size = 4
?fo_getargfloat@@YAMPAUtagAMX@@H@Z PROC			; fo_getargfloat, COMDAT

; 765  : 	unsigned char *data = amx->base + (int)((AMX_HEADER *)amx->base)->dat;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _amx$[esp-4]
  00004	8b 01		 mov	 eax, DWORD PTR [ecx]

; 766  : 	cell value = *(cell *)(data + (int)amx->frm + (pos + 3) * sizeof(cell));

  00006	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00009	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  0000c	03 d0		 add	 edx, eax
  0000e	8b 44 24 08	 mov	 eax, DWORD PTR _pos$[esp-4]
  00012	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 767  : 	cell number = *(cell *)(data + (int)value);

  00015	8b 44 10 0c	 mov	 eax, DWORD PTR [eax+edx+12]
  00019	8b 04 02	 mov	 eax, DWORD PTR [edx+eax]
  0001c	89 44 24 04	 mov	 DWORD PTR _number$[esp-4], eax

; 768  : 	
; 769  : 	return *(REAL *)((void *)&number);

  00020	d9 44 24 04	 fld	 DWORD PTR _number$[esp-4]

; 770  : }

  00024	c3		 ret	 0
?fo_getargfloat@@YAMPAUtagAMX@@H@Z ENDP			; fo_getargfloat
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?fo_getargnum@@YAHPAUtagAMX@@H@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_pos$ = 12						; size = 4
?fo_getargnum@@YAHPAUtagAMX@@H@Z PROC			; fo_getargnum, COMDAT

; 757  : 	unsigned char *data = amx->base + (int)((AMX_HEADER *)amx->base)->dat;

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _amx$[esp-4]
  00004	56		 push	 esi
  00005	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 758  : 	cell value = *(cell *)(data + (int)amx->frm + (pos + 3) * sizeof(cell));

  00007	8b 52 14	 mov	 edx, DWORD PTR [edx+20]
  0000a	8b 71 10	 mov	 esi, DWORD PTR [ecx+16]
  0000d	03 f1		 add	 esi, ecx
  0000f	8b 4c 24 0c	 mov	 ecx, DWORD PTR _pos$[esp]
  00013	8d 0c 8a	 lea	 ecx, DWORD PTR [edx+ecx*4]

; 759  : 	
; 760  : 	return *(cell *)(data + (int)value);

  00016	8b 44 31 0c	 mov	 eax, DWORD PTR [ecx+esi+12]
  0001a	8b 04 06	 mov	 eax, DWORD PTR [esi+eax]
  0001d	5e		 pop	 esi

; 761  : }

  0001e	c3		 ret	 0
?fo_getargnum@@YAHPAUtagAMX@@H@Z ENDP			; fo_getargnum
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?fo_numargs@@YAHPAUtagAMX@@@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
?fo_numargs@@YAHPAUtagAMX@@@Z PROC			; fo_numargs, COMDAT

; 749  : 	unsigned char *data = amx->base + (int)((AMX_HEADER *)amx->base)->dat;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _amx$[esp-4]
  00004	8b 11		 mov	 edx, DWORD PTR [ecx]

; 750  : 	cell bytes= *(cell *)(data + (int)amx->frm + 2 * sizeof(cell));

  00006	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00009	03 41 14	 add	 eax, DWORD PTR [ecx+20]

; 751  : 	
; 752  : 	return (int)(bytes / sizeof(cell));

  0000c	8b 44 10 08	 mov	 eax, DWORD PTR [eax+edx+8]
  00010	c1 e8 02	 shr	 eax, 2

; 753  : }

  00013	c3		 ret	 0
?fo_numargs@@YAHPAUtagAMX@@@Z ENDP			; fo_numargs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?strtoupper@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?strtoupper@@YAHPAUtagAMX@@PAH@Z PROC			; strtoupper, COMDAT

; 735  : 	cell *cptr = get_amxaddr(amx, params[1]);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _params$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	ff 70 04	 push	 DWORD PTR [eax+4]
  00009	ff 74 24 10	 push	 DWORD PTR _amx$[esp+8]
  0000d	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr
  00012	8b f0		 mov	 esi, eax
  00014	83 c4 08	 add	 esp, 8

; 736  : 	cell *begin = cptr;

  00017	8b fe		 mov	 edi, esi

; 737  : 	
; 738  : 	while (*cptr)

  00019	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0001c	74 16		 je	 SHORT $LN3@strtoupper
  0001e	66 90		 npad	 2
$LL2@strtoupper:

; 739  : 	{
; 740  : 		*cptr = toupper(*cptr);

  00020	ff 36		 push	 DWORD PTR [esi]
  00022	e8 00 00 00 00	 call	 _toupper
  00027	89 06		 mov	 DWORD PTR [esi], eax
  00029	83 c4 04	 add	 esp, 4

; 741  : 		cptr++;

  0002c	83 c6 04	 add	 esi, 4
  0002f	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00032	75 ec		 jne	 SHORT $LL2@strtoupper
$LN3@strtoupper:

; 742  : 	}
; 743  : 	
; 744  : 	return cptr - begin;

  00034	2b f7		 sub	 esi, edi
  00036	c1 fe 02	 sar	 esi, 2
  00039	5f		 pop	 edi
  0003a	8b c6		 mov	 eax, esi
  0003c	5e		 pop	 esi

; 745  : }

  0003d	c3		 ret	 0
?strtoupper@@YAHPAUtagAMX@@PAH@Z ENDP			; strtoupper
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?strtolower@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?strtolower@@YAHPAUtagAMX@@PAH@Z PROC			; strtolower, COMDAT

; 721  : 	cell *cptr = get_amxaddr(amx, params[1]);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _params$[esp-4]
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	ff 70 04	 push	 DWORD PTR [eax+4]
  00009	ff 74 24 10	 push	 DWORD PTR _amx$[esp+8]
  0000d	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr
  00012	8b f0		 mov	 esi, eax
  00014	83 c4 08	 add	 esp, 8

; 722  : 	cell *begin = cptr;

  00017	8b fe		 mov	 edi, esi

; 723  : 	
; 724  : 	while (*cptr)

  00019	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0001c	74 16		 je	 SHORT $LN3@strtolower
  0001e	66 90		 npad	 2
$LL2@strtolower:

; 725  : 	{
; 726  : 		*cptr = tolower(*cptr);

  00020	ff 36		 push	 DWORD PTR [esi]
  00022	e8 00 00 00 00	 call	 _tolower
  00027	89 06		 mov	 DWORD PTR [esi], eax
  00029	83 c4 04	 add	 esp, 4

; 727  : 		cptr++;

  0002c	83 c6 04	 add	 esi, 4
  0002f	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00032	75 ec		 jne	 SHORT $LL2@strtolower
$LN3@strtolower:

; 728  : 	}
; 729  : 
; 730  : 	return cptr - begin;

  00034	2b f7		 sub	 esi, edi
  00036	c1 fe 02	 sar	 esi, 2
  00039	5f		 pop	 edi
  0003a	8b c6		 mov	 eax, esi
  0003c	5e		 pop	 esi

; 731  : }

  0003d	c3		 ret	 0
?strtolower@@YAHPAUtagAMX@@PAH@Z ENDP			; strtolower
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?parse@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_parse$ = -8						; size = 4
_state$ = -4						; size = 4
_c$ = -4						; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?parse@@YAHPAUtagAMX@@PAH@Z PROC			; parse, COMDAT

; 692  : {

  00000	83 ec 08	 sub	 esp, 8
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi

; 693  : 	int inum = *params / sizeof(cell), iarg = 2, c;

  00006	8b 74 24 1c	 mov	 esi, DWORD PTR _params$[esp+16]

; 694  : 	char* arg, *parse = get_amxstring(amx, params[1], 0, c);

  0000a	8d 44 24 10	 lea	 eax, DWORD PTR _c$[esp+20]
  0000e	57		 push	 edi
  0000f	50		 push	 eax
  00010	6a 00		 push	 0
  00012	ff 76 04	 push	 DWORD PTR [esi+4]
  00015	8b 2e		 mov	 ebp, DWORD PTR [esi]
  00017	bb 02 00 00 00	 mov	 ebx, 2
  0001c	ff 74 24 28	 push	 DWORD PTR _amx$[esp+32]
  00020	c1 ed 02	 shr	 ebp, 2
  00023	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  00028	83 c4 10	 add	 esp, 16			; 00000010H
  0002b	89 44 24 10	 mov	 DWORD PTR _parse$[esp+24], eax

; 695  : 	cell *cptr;
; 696  : 	int state;
; 697  : 	
; 698  : 	while (*parse)

  0002f	80 38 00	 cmp	 BYTE PTR [eax], 0
  00032	74 73		 je	 SHORT $LN18@parse
$LL2@parse:

; 699  : 	{
; 700  : 		arg = parse_arg(&parse,state);

  00034	8d 44 24 14	 lea	 eax, DWORD PTR _state$[esp+24]
  00038	50		 push	 eax
  00039	8d 44 24 14	 lea	 eax, DWORD PTR _parse$[esp+28]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?parse_arg@@YAPADPAPADAAH@Z ; parse_arg
  00043	83 c4 08	 add	 esp, 8
  00046	8b f8		 mov	 edi, eax

; 701  : 		
; 702  : 		if (state)

  00048	83 7c 24 14 00	 cmp	 DWORD PTR _state$[esp+24], 0
  0004d	74 4f		 je	 SHORT $LN6@parse

; 703  : 		{
; 704  : 			if (inum <= iarg)

  0004f	3b eb		 cmp	 ebp, ebx
  00051	7e 54		 jle	 SHORT $LN18@parse

; 705  : 				return ((iarg - 2)>>1);
; 706  : 			
; 707  : 			cptr = get_amxaddr(amx, params[iarg++]);

  00053	ff 34 9e	 push	 DWORD PTR [esi+ebx*4]
  00056	ff 74 24 20	 push	 DWORD PTR _amx$[esp+24]
  0005a	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr
  0005f	8b f0		 mov	 esi, eax

; 708  : 			c = *get_amxaddr(amx, params[iarg++]);

  00061	8b 44 24 28	 mov	 eax, DWORD PTR _params$[esp+28]
  00065	ff 74 98 04	 push	 DWORD PTR [eax+ebx*4+4]
  00069	ff 74 24 28	 push	 DWORD PTR _amx$[esp+32]
  0006d	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr
  00072	83 c4 10	 add	 esp, 16			; 00000010H
  00075	83 c3 02	 add	 ebx, 2
  00078	8b 08		 mov	 ecx, DWORD PTR [eax]

; 709  : 			
; 710  : 			while (c-- && *arg)

  0007a	85 c9		 test	 ecx, ecx
  0007c	74 16		 je	 SHORT $LN19@parse
  0007e	66 90		 npad	 2
$LL4@parse:
  00080	8a 07		 mov	 al, BYTE PTR [edi]
  00082	49		 dec	 ecx
  00083	84 c0		 test	 al, al
  00085	74 0d		 je	 SHORT $LN19@parse

; 711  : 				*cptr++ = (cell)*arg++;

  00087	0f be c0	 movsx	 eax, al
  0008a	47		 inc	 edi
  0008b	89 06		 mov	 DWORD PTR [esi], eax
  0008d	83 c6 04	 add	 esi, 4
  00090	85 c9		 test	 ecx, ecx
  00092	75 ec		 jne	 SHORT $LL4@parse
$LN19@parse:

; 712  : 			*cptr = 0;

  00094	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  0009a	8b 74 24 20	 mov	 esi, DWORD PTR _params$[esp+20]
$LN6@parse:

; 695  : 	cell *cptr;
; 696  : 	int state;
; 697  : 	
; 698  : 	while (*parse)

  0009e	8b 44 24 10	 mov	 eax, DWORD PTR _parse$[esp+24]
  000a2	80 38 00	 cmp	 BYTE PTR [eax], 0
  000a5	75 8d		 jne	 SHORT $LL2@parse
$LN18@parse:
  000a7	5f		 pop	 edi
  000a8	5e		 pop	 esi

; 713  : 		}
; 714  : 	}
; 715  : 
; 716  : 	return ((iarg - 2)>>1);

  000a9	8d 43 fe	 lea	 eax, DWORD PTR [ebx-2]
  000ac	5d		 pop	 ebp
  000ad	d1 f8		 sar	 eax, 1
  000af	5b		 pop	 ebx

; 717  : }

  000b0	83 c4 08	 add	 esp, 8
  000b3	c3		 ret	 0
?parse@@YAHPAUtagAMX@@PAH@Z ENDP			; parse
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?format@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_buf$1$ = -12						; size = 4
_param$ = -8						; size = 4
_fmt$1$ = -4						; size = 4
_amx$ = 8						; size = 4
_copy$1$ = 12						; size = 1
_params$ = 12						; size = 4
?format@@YAHPAUtagAMX@@PAH@Z PROC			; format, COMDAT

; 651  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp

; 652  : 	cell *buf = get_amxaddr(amx, params[1]);

  00005	8b 6c 24 18	 mov	 ebp, DWORD PTR _amx$[esp+16]
  00009	56		 push	 esi
  0000a	8b 74 24 20	 mov	 esi, DWORD PTR _params$[esp+20]
  0000e	57		 push	 edi
  0000f	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00012	57		 push	 edi
  00013	55		 push	 ebp
  00014	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 653  : 	cell *fmt = get_amxaddr(amx, params[3]);

  00019	ff 76 0c	 push	 DWORD PTR [esi+12]
  0001c	89 44 24 1c	 mov	 DWORD PTR _buf$1$[esp+40], eax
  00020	55		 push	 ebp
  00021	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 654  : 	size_t maxlen = params[2];
; 655  : 	/** 
; 656  : 	 * SPECIAL CASE - check if the buffers overlap.
; 657  : 	 *  some users, for whatever reason, do things like:
; 658  : 	 *  format(buf, 255, buf....
; 659  : 	 *  this is considered "deprecated" but we have to support it.
; 660  : 	 * we do this by checking to see if reading from buf will overlap
; 661  : 	 */
; 662  : 	cell addr_start = params[1];
; 663  : 	cell addr_end = params[1] + maxlen * sizeof(cell);
; 664  : 	cell max = params[0] / sizeof(cell);

  00026	8b 16		 mov	 edx, DWORD PTR [esi]

; 665  : 	bool copy = false;
; 666  : 	for (cell i = 3; i <= max; i++)

  00028	b9 03 00 00 00	 mov	 ecx, 3
  0002d	89 44 24 28	 mov	 DWORD PTR _fmt$1$[esp+44], eax
  00031	83 c4 10	 add	 esp, 16			; 00000010H
  00034	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00037	c1 ea 02	 shr	 edx, 2
  0003a	c6 44 24 24 00	 mov	 BYTE PTR _copy$1$[esp+24], 0
  0003f	8d 1c 87	 lea	 ebx, DWORD PTR [edi+eax*4]
  00042	3b d1		 cmp	 edx, ecx
  00044	72 10		 jb	 SHORT $LN18@format
$LL4@format:

; 667  : 	{
; 668  : 		//does this clip the bounds?!?!? WELL, DOES IT!?!?! i am a loud dog
; 669  : 		if (params[i] >= addr_start && params[i] <= addr_end)

  00046	8b 04 8e	 mov	 eax, DWORD PTR [esi+ecx*4]
  00049	3b c7		 cmp	 eax, edi
  0004b	7c 04		 jl	 SHORT $LN2@format
  0004d	3b c3		 cmp	 eax, ebx
  0004f	7e 5d		 jle	 SHORT $LN10@format
$LN2@format:

; 665  : 	bool copy = false;
; 666  : 	for (cell i = 3; i <= max; i++)

  00051	41		 inc	 ecx
  00052	3b ca		 cmp	 ecx, edx
  00054	7e f0		 jle	 SHORT $LL4@format
$LN18@format:
  00056	8b 44 24 10	 mov	 eax, DWORD PTR _buf$1$[esp+28]
$LN15@format:

; 677  : 	int param = 4;
; 678  : 	size_t total = 0;
; 679  : 
; 680  : 	total = atcprintf(buf, maxlen, fmt, amx, params, &param);

  0005a	8d 4c 24 14	 lea	 ecx, DWORD PTR _param$[esp+28]
  0005e	c7 44 24 14 04
	00 00 00	 mov	 DWORD PTR _param$[esp+28], 4
  00066	51		 push	 ecx
  00067	56		 push	 esi
  00068	55		 push	 ebp
  00069	ff 74 24 24	 push	 DWORD PTR _fmt$1$[esp+40]
  0006d	ff 76 08	 push	 DWORD PTR [esi+8]
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ??$atcprintf@HH@@YAIPAHIPBHPAUtagAMX@@00@Z ; atcprintf<int,int>
  00076	83 c4 18	 add	 esp, 24			; 00000018H
  00079	8b f8		 mov	 edi, eax

; 681  : 
; 682  : 	if (copy)

  0007b	80 7c 24 24 00	 cmp	 BYTE PTR _copy$1$[esp+24], 0
  00080	74 22		 je	 SHORT $LN16@format

; 683  : 	{
; 684  : 		/* copy back */
; 685  : 		cell *old = get_amxaddr(amx, params[1]);
; 686  : 		memcpy(old, g_cpbuf, (total+1) * sizeof(cell));

  00082	8d 0c bd 04 00
	00 00		 lea	 ecx, DWORD PTR [edi*4+4]
  00089	51		 push	 ecx
  0008a	68 00 00 00 00	 push	 OFFSET ?g_cpbuf@@3PAHA
  0008f	ff 76 04	 push	 DWORD PTR [esi+4]
  00092	55		 push	 ebp
  00093	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr
  00098	83 c4 08	 add	 esp, 8
  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 _memcpy
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN16@format:

; 687  : 	}
; 688  : 	return total;

  000a4	8b c7		 mov	 eax, edi
  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
  000a8	5d		 pop	 ebp
  000a9	5b		 pop	 ebx

; 689  : }

  000aa	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ad	c3		 ret	 0
$LN10@format:

; 670  : 		{
; 671  : 			copy = true;

  000ae	c6 44 24 24 01	 mov	 BYTE PTR _copy$1$[esp+24], 1

; 672  : 			break;
; 673  : 		}
; 674  : 	}
; 675  : 	if (copy)
; 676  : 		buf = g_cpbuf;

  000b3	b8 00 00 00 00	 mov	 eax, OFFSET ?g_cpbuf@@3PAHA
  000b8	eb a0		 jmp	 SHORT $LN15@format
?format@@YAHPAUtagAMX@@PAH@Z ENDP			; format
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?formatex@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_param$ = 12						; size = 4
_params$ = 12						; size = 4
?formatex@@YAHPAUtagAMX@@PAH@Z PROC			; formatex, COMDAT

; 641  : {

  00000	53		 push	 ebx

; 642  : 	cell *buf = get_amxaddr(amx, params[1]);

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _params$[esp]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 7c 24 10	 mov	 edi, DWORD PTR _amx$[esp+8]
  0000b	ff 73 04	 push	 DWORD PTR [ebx+4]
  0000e	57		 push	 edi
  0000f	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 643  : 	size_t maxlen = static_cast<size_t>(params[2]);
; 644  :     cell *fmt = get_amxaddr(amx, params[3]);

  00014	ff 73 0c	 push	 DWORD PTR [ebx+12]
  00017	8b f0		 mov	 esi, eax
  00019	57		 push	 edi
  0001a	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 645  : 	int param = 4;
; 646  : 	size_t total = atcprintf(buf, maxlen, fmt, amx, params, &param);

  0001f	8d 4c 24 24	 lea	 ecx, DWORD PTR _param$[esp+24]
  00023	c7 44 24 24 04
	00 00 00	 mov	 DWORD PTR _param$[esp+24], 4
  0002b	51		 push	 ecx
  0002c	53		 push	 ebx
  0002d	57		 push	 edi
  0002e	50		 push	 eax
  0002f	ff 73 08	 push	 DWORD PTR [ebx+8]
  00032	56		 push	 esi
  00033	e8 00 00 00 00	 call	 ??$atcprintf@HH@@YAIPAHIPBHPAUtagAMX@@00@Z ; atcprintf<int,int>
  00038	83 c4 28	 add	 esp, 40			; 00000028H
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx

; 647  : 	return static_cast<cell>(total);
; 648  : }

  0003e	c3		 ret	 0
?formatex@@YAHPAUtagAMX@@PAH@Z ENDP			; formatex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?equali@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?equali@@YAHPAUtagAMX@@PAH@Z PROC			; equali, COMDAT

; 613  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi

; 614  : 	cell *a = get_amxaddr(amx, params[1]);

  00003	8b 74 24 10	 mov	 esi, DWORD PTR _amx$[esp+8]
  00007	57		 push	 edi
  00008	8b 7c 24 18	 mov	 edi, DWORD PTR _params$[esp+12]
  0000c	ff 77 04	 push	 DWORD PTR [edi+4]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 615  : 	cell *b = get_amxaddr(amx, params[2]);

  00015	ff 77 08	 push	 DWORD PTR [edi+8]
  00018	8b d8		 mov	 ebx, eax
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 616  : 	int f, l, c = params[3];

  00020	8b 6f 0c	 mov	 ebp, DWORD PTR [edi+12]
  00023	83 c4 10	 add	 esp, 16			; 00000010H
  00026	8b f0		 mov	 esi, eax

; 617  : 	
; 618  : 	if (c)

  00028	85 ed		 test	 ebp, ebp
  0002a	74 3c		 je	 SHORT $LL7@equali
  0002c	0f 1f 40 00	 npad	 4
$LL4@equali:

; 619  : 	{
; 620  : 		do
; 621  : 		{
; 622  : 			f = tolower(*a++);

  00030	ff 33		 push	 DWORD PTR [ebx]
  00032	e8 00 00 00 00	 call	 _tolower

; 623  : 			l = tolower(*b++);

  00037	ff 36		 push	 DWORD PTR [esi]
  00039	8b f8		 mov	 edi, eax
  0003b	8d 5b 04	 lea	 ebx, DWORD PTR [ebx+4]
  0003e	e8 00 00 00 00	 call	 _tolower
  00043	83 c4 08	 add	 esp, 8
  00046	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00049	8b c8		 mov	 ecx, eax

; 624  : 		} while (--c && l && f && f == l);

  0004b	83 ed 01	 sub	 ebp, 1
  0004e	74 3b		 je	 SHORT $LN10@equali
  00050	85 c9		 test	 ecx, ecx
  00052	74 37		 je	 SHORT $LN10@equali
  00054	85 ff		 test	 edi, edi
  00056	74 33		 je	 SHORT $LN10@equali
  00058	3b f9		 cmp	 edi, ecx
  0005a	74 d4		 je	 SHORT $LL4@equali

; 634  : 	
; 635  : 	return (f - l) ? 0 : 1;

  0005c	33 c0		 xor	 eax, eax
  0005e	3b f9		 cmp	 edi, ecx
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5d		 pop	 ebp
  00063	0f 94 c0	 sete	 al
  00066	5b		 pop	 ebx

; 636  : }

  00067	c3		 ret	 0
$LL7@equali:

; 625  : 		
; 626  : 		return (f - l) ? 0 : 1;
; 627  : 	}
; 628  : 
; 629  : 	do
; 630  : 	{
; 631  : 		f = tolower(*a++);

  00068	ff 33		 push	 DWORD PTR [ebx]
  0006a	e8 00 00 00 00	 call	 _tolower

; 632  : 		l = tolower(*b++);

  0006f	ff 36		 push	 DWORD PTR [esi]
  00071	8b f8		 mov	 edi, eax
  00073	8d 5b 04	 lea	 ebx, DWORD PTR [ebx+4]
  00076	e8 00 00 00 00	 call	 _tolower
  0007b	83 c4 08	 add	 esp, 8
  0007e	8d 76 04	 lea	 esi, DWORD PTR [esi+4]
  00081	8b c8		 mov	 ecx, eax

; 633  : 	} while (f && f == l);

  00083	85 ff		 test	 edi, edi
  00085	74 04		 je	 SHORT $LN10@equali
  00087	3b f9		 cmp	 edi, ecx
  00089	74 dd		 je	 SHORT $LL7@equali
$LN10@equali:

; 634  : 	
; 635  : 	return (f - l) ? 0 : 1;

  0008b	33 c0		 xor	 eax, eax
  0008d	3b f9		 cmp	 edi, ecx
  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	5d		 pop	 ebp
  00092	0f 94 c0	 sete	 al
  00095	5b		 pop	 ebx

; 636  : }

  00096	c3		 ret	 0
?equali@@YAHPAUtagAMX@@PAH@Z ENDP			; equali
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?equal@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?equal@@YAHPAUtagAMX@@PAH@Z PROC			; equal, COMDAT

; 592  : {

  00000	53		 push	 ebx

; 593  : 	cell *a = get_amxaddr(amx, params[1]);

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _params$[esp]
  00005	56		 push	 esi
  00006	ff 73 04	 push	 DWORD PTR [ebx+4]
  00009	ff 74 24 10	 push	 DWORD PTR _amx$[esp+8]
  0000d	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 594  : 	cell *b = get_amxaddr(amx, params[2]);

  00012	ff 73 08	 push	 DWORD PTR [ebx+8]
  00015	8b f0		 mov	 esi, eax
  00017	ff 74 24 18	 push	 DWORD PTR _amx$[esp+16]
  0001b	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 595  : 	int c = params[3];

  00020	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  00023	83 c4 10	 add	 esp, 16			; 00000010H
  00026	8b d0		 mov	 edx, eax

; 596  : 	
; 597  : 	if (c)

  00028	85 c9		 test	 ecx, ecx
  0002a	74 26		 je	 SHORT $LN9@equal

; 598  : 	{
; 599  : 		while (--c && *a && (*a == *b))

  0002c	83 e9 01	 sub	 ecx, 1
  0002f	74 15		 je	 SHORT $LN16@equal
$LL2@equal:
  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	85 c0		 test	 eax, eax
  00035	74 0f		 je	 SHORT $LN16@equal
  00037	3b 02		 cmp	 eax, DWORD PTR [edx]
  00039	75 0b		 jne	 SHORT $LN16@equal

; 600  : 			++a, ++b;

  0003b	83 c6 04	 add	 esi, 4
  0003e	83 c2 04	 add	 edx, 4
  00041	83 e9 01	 sub	 ecx, 1
  00044	75 eb		 jne	 SHORT $LL2@equal
$LN16@equal:
  00046	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00048	33 c0		 xor	 eax, eax
  0004a	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0004c	5e		 pop	 esi
  0004d	0f 94 c0	 sete	 al
  00050	5b		 pop	 ebx

; 608  : 	
; 609  : 	return ret ? 0 : 1;
; 610  : }

  00051	c3		 ret	 0
$LN9@equal:

; 601  : 		return (*a-*b) ? 0 : 1;
; 602  : 	}
; 603  : 	
; 604  : 	int ret;
; 605  : 	
; 606  : 	while (!(ret = *a - *b) && *b)

  00052	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00054	8b 02		 mov	 eax, DWORD PTR [edx]
  00056	2b c8		 sub	 ecx, eax
  00058	75 17		 jne	 SHORT $LN17@equal
  0005a	2b d6		 sub	 edx, esi
  0005c	0f 1f 40 00	 npad	 4
$LL4@equal:
  00060	85 c0		 test	 eax, eax
  00062	74 0d		 je	 SHORT $LN17@equal
  00064	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 607  : 		++a, ++b;

  00067	83 c6 04	 add	 esi, 4
  0006a	8b 04 32	 mov	 eax, DWORD PTR [edx+esi]
  0006d	2b c8		 sub	 ecx, eax
  0006f	74 ef		 je	 SHORT $LL4@equal
$LN17@equal:
  00071	33 c0		 xor	 eax, eax
  00073	85 c9		 test	 ecx, ecx
  00075	5e		 pop	 esi
  00076	0f 94 c0	 sete	 al
  00079	5b		 pop	 ebx

; 608  : 	
; 609  : 	return ret ? 0 : 1;
; 610  : }

  0007a	c3		 ret	 0
?equal@@YAHPAUtagAMX@@PAH@Z ENDP			; equal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?setc@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?setc@@YAHPAUtagAMX@@PAH@Z PROC				; setc, COMDAT

; 580  : {

  00000	56		 push	 esi

; 581  : 	cell *src = get_amxaddr(amx, params[1]);

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR _params$[esp]
  00005	57		 push	 edi
  00006	ff 76 04	 push	 DWORD PTR [esi+4]
  00009	ff 74 24 10	 push	 DWORD PTR _amx$[esp+8]
  0000d	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 582  : 	int c = params[2];
; 583  : 	cell ch = params[3];
; 584  : 	
; 585  : 	while (c--)

  00012	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00015	83 c4 08	 add	 esp, 8
  00018	8b f8		 mov	 edi, eax
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 05		 je	 SHORT $LN10@setc

; 581  : 	cell *src = get_amxaddr(amx, params[1]);

  0001e	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00021	f3 ab		 rep stosd
$LN10@setc:

; 586  : 		*src++ = ch;
; 587  : 	
; 588  : 	return 1;

  00023	5f		 pop	 edi
  00024	b8 01 00 00 00	 mov	 eax, 1
  00029	5e		 pop	 esi

; 589  : }

  0002a	c3		 ret	 0
?setc@@YAHPAUtagAMX@@PAH@Z ENDP				; setc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?copyc@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?copyc@@YAHPAUtagAMX@@PAH@Z PROC			; copyc, COMDAT

; 565  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi

; 566  : 	cell *src = get_amxaddr(amx, params[3]);

  00003	8b 74 24 10	 mov	 esi, DWORD PTR _amx$[esp+8]
  00007	57		 push	 edi
  00008	8b 7c 24 18	 mov	 edi, DWORD PTR _params$[esp+12]
  0000c	ff 77 0c	 push	 DWORD PTR [edi+12]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 567  : 	cell *dest = get_amxaddr(amx, params[1]);

  00015	ff 77 04	 push	 DWORD PTR [edi+4]
  00018	8b d8		 mov	 ebx, eax
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 568  : 	cell *start = dest;
; 569  : 	int c = params[2];

  00020	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00023	83 c4 10	 add	 esp, 16			; 00000010H

; 570  : 	cell ch = params[4];

  00026	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  00029	8b e8		 mov	 ebp, eax

; 571  : 	
; 572  : 	while (c-- && *src && *src != ch)

  0002b	85 d2		 test	 edx, edx
  0002d	74 17		 je	 SHORT $LN10@copyc
  0002f	2b d8		 sub	 ebx, eax
$LL2@copyc:
  00031	8b 0c 03	 mov	 ecx, DWORD PTR [ebx+eax]
  00034	4a		 dec	 edx
  00035	85 c9		 test	 ecx, ecx
  00037	74 0d		 je	 SHORT $LN10@copyc
  00039	3b ce		 cmp	 ecx, esi
  0003b	74 09		 je	 SHORT $LN10@copyc

; 573  : 		*dest++ =* src++;

  0003d	89 08		 mov	 DWORD PTR [eax], ecx
  0003f	83 c0 04	 add	 eax, 4
  00042	85 d2		 test	 edx, edx
  00044	75 eb		 jne	 SHORT $LL2@copyc
$LN10@copyc:
  00046	5f		 pop	 edi

; 574  : 	*dest = 0;

  00047	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 575  : 	
; 576  : 	return (dest - start);

  0004d	2b c5		 sub	 eax, ebp
  0004f	5e		 pop	 esi
  00050	5d		 pop	 ebp
  00051	c1 f8 02	 sar	 eax, 2
  00054	5b		 pop	 ebx

; 577  : }

  00055	c3		 ret	 0
?copyc@@YAHPAUtagAMX@@PAH@Z ENDP			; copyc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?copy@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?copy@@YAHPAUtagAMX@@PAH@Z PROC				; copy, COMDAT

; 548  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	57		 push	 edi

; 549  : 	cell *src = get_amxaddr(amx, params[3]);

  00003	8b 7c 24 14	 mov	 edi, DWORD PTR _params$[esp+8]
  00007	ff 77 0c	 push	 DWORD PTR [edi+12]
  0000a	ff 74 24 14	 push	 DWORD PTR _amx$[esp+12]
  0000e	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 550  : 	int c = params[2];
; 551  : 
; 552  : 	cell *dest = get_amxaddr(amx, params[1]);

  00013	ff 77 04	 push	 DWORD PTR [edi+4]
  00016	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  00019	8b e8		 mov	 ebp, eax
  0001b	ff 74 24 1c	 push	 DWORD PTR _amx$[esp+20]
  0001f	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr
  00024	83 c4 10	 add	 esp, 16			; 00000010H

; 553  : 	cell *start = dest;

  00027	8b d0		 mov	 edx, eax

; 554  : 
; 555  : 	while (c-- && *src)

  00029	85 db		 test	 ebx, ebx
  0002b	74 14		 je	 SHORT $LN10@copy
  0002d	2b e8		 sub	 ebp, eax
  0002f	90		 npad	 1
$LL2@copy:
  00030	8b 0c 28	 mov	 ecx, DWORD PTR [eax+ebp]
  00033	4b		 dec	 ebx
  00034	85 c9		 test	 ecx, ecx
  00036	74 09		 je	 SHORT $LN10@copy

; 556  : 	{
; 557  : 		*dest++ = *src++;

  00038	89 08		 mov	 DWORD PTR [eax], ecx
  0003a	83 c0 04	 add	 eax, 4
  0003d	85 db		 test	 ebx, ebx
  0003f	75 ef		 jne	 SHORT $LL2@copy
$LN10@copy:
  00041	5f		 pop	 edi

; 558  : 	}
; 559  : 	*dest = '\0';

  00042	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 560  : 
; 561  : 	return (dest - start);

  00048	2b c2		 sub	 eax, edx
  0004a	5d		 pop	 ebp
  0004b	c1 f8 02	 sar	 eax, 2
  0004e	5b		 pop	 ebx

; 562  : }

  0004f	c3		 ret	 0
?copy@@YAHPAUtagAMX@@PAH@Z ENDP				; copy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?add@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?add@@YAHPAUtagAMX@@PAH@Z PROC				; add, COMDAT

; 522  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi

; 523  : 	cell *src = get_amxaddr(amx, params[3]);

  00003	8b 74 24 10	 mov	 esi, DWORD PTR _amx$[esp+8]
  00007	57		 push	 edi
  00008	8b 7c 24 18	 mov	 edi, DWORD PTR _params$[esp+12]
  0000c	ff 77 0c	 push	 DWORD PTR [edi+12]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 524  : 	cell *dest = get_amxaddr(amx, params[1]);

  00015	ff 77 04	 push	 DWORD PTR [edi+4]
  00018	8b d8		 mov	 ebx, eax
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 525  : 	cell *start = dest;
; 526  : 	int c = params[2], d = params[4];

  00020	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00023	83 c4 10	 add	 esp, 16			; 00000010H
  00026	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  00029	8b e8		 mov	 ebp, eax

; 527  : 	
; 528  : 	while (*dest && c--)

  0002b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002e	74 0f		 je	 SHORT $LN24@add
$LL2@add:
  00030	8b ca		 mov	 ecx, edx
  00032	4a		 dec	 edx
  00033	85 c9		 test	 ecx, ecx
  00035	74 08		 je	 SHORT $LN24@add

; 529  : 		++dest;

  00037	83 c0 04	 add	 eax, 4
  0003a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0003d	75 f1		 jne	 SHORT $LL2@add
$LN24@add:

; 530  : 	
; 531  : 	if (d)

  0003f	85 f6		 test	 esi, esi
  00041	74 31		 je	 SHORT $LN12@add

; 532  : 	{
; 533  : 		while (c-- && d-- && *src)

  00043	85 d2		 test	 edx, edx
  00045	74 44		 je	 SHORT $LN26@add
  00047	2b d8		 sub	 ebx, eax
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@add:
  00050	8b ce		 mov	 ecx, esi
  00052	4a		 dec	 edx
  00053	4e		 dec	 esi
  00054	85 c9		 test	 ecx, ecx
  00056	74 33		 je	 SHORT $LN26@add
  00058	8b 0c 03	 mov	 ecx, DWORD PTR [ebx+eax]
  0005b	85 c9		 test	 ecx, ecx
  0005d	74 2c		 je	 SHORT $LN26@add

; 534  : 			*dest++ =* src++;

  0005f	89 08		 mov	 DWORD PTR [eax], ecx
  00061	83 c0 04	 add	 eax, 4
  00064	85 d2		 test	 edx, edx
  00066	75 e8		 jne	 SHORT $LL4@add

; 542  : 	*dest = 0;

  00068	5f		 pop	 edi
  00069	89 10		 mov	 DWORD PTR [eax], edx

; 543  : 	
; 544  : 	return (dest-start);

  0006b	2b c5		 sub	 eax, ebp
  0006d	5e		 pop	 esi
  0006e	5d		 pop	 ebp
  0006f	c1 f8 02	 sar	 eax, 2
  00072	5b		 pop	 ebx

; 545  : }

  00073	c3		 ret	 0
$LN12@add:

; 535  : 		*dest = 0;
; 536  : 		
; 537  : 		return (dest - start);
; 538  : 	}
; 539  : 
; 540  : 	while (c-- && *src)

  00074	85 d2		 test	 edx, edx
  00076	74 13		 je	 SHORT $LN26@add
$LL6@add:
  00078	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0007a	4a		 dec	 edx
  0007b	85 c9		 test	 ecx, ecx
  0007d	74 0c		 je	 SHORT $LN26@add

; 541  : 		*dest++ =* src++;

  0007f	89 08		 mov	 DWORD PTR [eax], ecx
  00081	83 c3 04	 add	 ebx, 4
  00084	83 c0 04	 add	 eax, 4
  00087	85 d2		 test	 edx, edx
  00089	75 ed		 jne	 SHORT $LL6@add
$LN26@add:
  0008b	5f		 pop	 edi

; 542  : 	*dest = 0;

  0008c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 543  : 	
; 544  : 	return (dest-start);

  00092	2b c5		 sub	 eax, ebp
  00094	5e		 pop	 esi
  00095	5d		 pop	 ebp
  00096	c1 f8 02	 sar	 eax, 2
  00099	5b		 pop	 ebx

; 545  : }

  0009a	c3		 ret	 0
?add@@YAHPAUtagAMX@@PAH@Z ENDP				; add
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?float_to_str@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_szTemp$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?float_to_str@@YAHPAUtagAMX@@PAH@Z PROC			; float_to_str, COMDAT

; 514  : {

  00000	83 ec 24	 sub	 esp, 36			; 00000024H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 20	 mov	 DWORD PTR __$ArrayPad$[esp+36], eax
  0000e	56		 push	 esi
  0000f	8b 74 24 30	 mov	 esi, DWORD PTR _params$[esp+36]

; 515  : 	char szTemp[32];
; 516  : 	sprintf(szTemp, "%f", amx_ctof(params[1]));

  00013	8d 44 24 04	 lea	 eax, DWORD PTR _szTemp$[esp+40]
  00017	57		 push	 edi
  00018	8b 7c 24 30	 mov	 edi, DWORD PTR _amx$[esp+40]
  0001c	83 ec 08	 sub	 esp, 8
  0001f	f3 0f 10 46 04	 movss	 xmm0, DWORD PTR [esi+4]
  00024	0f 5a c0	 cvtps2pd xmm0, xmm0
  00027	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_02NJPGOMH@?$CFf?$AA@
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _sprintf

; 517  : 	
; 518  : 	return set_amxstring(amx, params[2], szTemp, params[3]);

  00037	ff 76 0c	 push	 DWORD PTR [esi+12]
  0003a	8d 44 24 1c	 lea	 eax, DWORD PTR _szTemp$[esp+64]
  0003e	50		 push	 eax
  0003f	ff 76 08	 push	 DWORD PTR [esi+8]
  00042	57		 push	 edi
  00043	e8 00 00 00 00	 call	 ?set_amxstring@@YAHPAUtagAMX@@HPBDH@Z ; set_amxstring

; 519  : }

  00048	8b 4c 24 48	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+76]
  0004c	83 c4 20	 add	 esp, 32			; 00000020H
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	33 cc		 xor	 ecx, esp
  00053	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00058	83 c4 24	 add	 esp, 36			; 00000024H
  0005b	c3		 ret	 0
?float_to_str@@YAHPAUtagAMX@@PAH@Z ENDP			; float_to_str
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?str_to_float@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_part2$1$ = -8						; size = 4
_fl$ = -8						; size = 4
_part1$1$ = -4						; size = 4
_amx$ = 8						; size = 4
_fl$1 = 12						; size = 4
_params$ = 12						; size = 4
_neg$1$ = 15						; size = 1
?str_to_float@@YAHPAUtagAMX@@PAH@Z PROC			; str_to_float, COMDAT

; 457  : {

  00000	83 ec 08	 sub	 esp, 8

; 458  : 	cell *str = get_amxaddr(amx, params[1]);

  00003	8b 44 24 10	 mov	 eax, DWORD PTR _params$[esp+4]
  00007	56		 push	 esi
  00008	ff 70 04	 push	 DWORD PTR [eax+4]
  0000b	ff 74 24 14	 push	 DWORD PTR _amx$[esp+12]
  0000f	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr
  00014	8b c8		 mov	 ecx, eax

; 459  : 
; 460  : 	bool neg = false;

  00016	c6 44 24 1f 00	 mov	 BYTE PTR _neg$1$[esp+16], 0

; 461  : 	unsigned long part1 = 0;

  0001b	33 f6		 xor	 esi, esi
  0001d	83 c4 08	 add	 esp, 8
  00020	89 74 24 08	 mov	 DWORD PTR _part1$1$[esp+12], esi

; 462  : 
; 463  : 	if (*str == '-')

  00024	8b 01		 mov	 eax, DWORD PTR [ecx]
  00026	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00029	75 07		 jne	 SHORT $LN6@str_to_flo

; 464  : 	{
; 465  : 		neg = true;

  0002b	c6 44 24 17 01	 mov	 BYTE PTR _neg$1$[esp+8], 1

; 466  : 		++str;

  00030	eb 05		 jmp	 SHORT $LN30@str_to_flo
$LN6@str_to_flo:

; 467  : 	}
; 468  : 	else if (*str == '+')

  00032	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  00035	75 03		 jne	 SHORT $LN18@str_to_flo
$LN30@str_to_flo:

; 469  : 		++str;

  00037	83 c1 04	 add	 ecx, 4
$LN18@str_to_flo:

; 470  : 
; 471  : 	while (*str)

  0003a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003c	85 d2		 test	 edx, edx
  0003e	74 5f		 je	 SHORT $LN3@str_to_flo
$LL2@str_to_flo:

; 472  : 	{
; 473  : 		if (*str == '.')

  00040	83 fa 2e	 cmp	 edx, 46			; 0000002eH
  00043	74 57		 je	 SHORT $LN20@str_to_flo

; 476  : 			break;
; 477  : 		}
; 478  : 		
; 479  : 		if (*str < '0' || *str > '9')

  00045	83 fa 30	 cmp	 edx, 48			; 00000030H
  00048	7c 1d		 jl	 SHORT $LN21@str_to_flo
  0004a	83 fa 39	 cmp	 edx, 57			; 00000039H
  0004d	7f 18		 jg	 SHORT $LN21@str_to_flo

; 483  : 		}
; 484  : 
; 485  : 		part1 *= 10;

  0004f	8d 34 b6	 lea	 esi, DWORD PTR [esi+esi*4]

; 486  : 		part1 += *str - '0';
; 487  : 
; 488  : 		++str;

  00052	83 c1 04	 add	 ecx, 4
  00055	8d 76 e8	 lea	 esi, DWORD PTR [esi-24]
  00058	8d 34 72	 lea	 esi, DWORD PTR [edx+esi*2]
  0005b	89 74 24 08	 mov	 DWORD PTR _part1$1$[esp+12], esi
  0005f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00061	85 d2		 test	 edx, edx
  00063	75 db		 jne	 SHORT $LL2@str_to_flo

; 495  : 	{
; 496  : 		if (*str < '0' || *str > '9')

  00065	eb 38		 jmp	 SHORT $LN3@str_to_flo
$LN21@str_to_flo:
  00067	66 0f 6e c6	 movd	 xmm0, esi

; 480  : 		{
; 481  : 			REAL fl = neg ? -static_cast<REAL>(part1) : static_cast<REAL>(part1);

  0006b	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0006f	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  00072	80 7c 24 17 00	 cmp	 BYTE PTR _neg$1$[esp+8], 0
  00077	f2 0f 58 04 f5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[esi*8]
  00080	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  00084	74 07		 je	 SHORT $LN16@str_to_flo
  00086	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
$LN16@str_to_flo:
  0008d	f3 0f 11 44 24
	14		 movss	 DWORD PTR _fl$1[esp+8], xmm0

; 482  : 			return amx_ftoc(fl);

  00093	8b 44 24 14	 mov	 eax, DWORD PTR _fl$1[esp+8]
  00097	5e		 pop	 esi

; 511  : }

  00098	83 c4 08	 add	 esp, 8
  0009b	c3		 ret	 0
$LN20@str_to_flo:

; 474  : 		{
; 475  : 			++str;

  0009c	83 c1 04	 add	 ecx, 4
$LN3@str_to_flo:

; 489  : 	}
; 490  : 
; 491  : 	unsigned long part2 = 0;
; 492  : 	unsigned long div = 1;
; 493  : 	
; 494  : 	while (*str)

  0009f	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a1	33 c0		 xor	 eax, eax
  000a3	57		 push	 edi
  000a4	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  000a7	85 d2		 test	 edx, edx
  000a9	74 32		 je	 SHORT $LN22@str_to_flo
  000ab	33 f6		 xor	 esi, esi
  000ad	0f 1f 00	 npad	 3
$LL4@str_to_flo:

; 495  : 	{
; 496  : 		if (*str < '0' || *str > '9')

  000b0	83 fa 30	 cmp	 edx, 48			; 00000030H
  000b3	7c 1c		 jl	 SHORT $LN29@str_to_flo
  000b5	83 fa 39	 cmp	 edx, 57			; 00000039H
  000b8	7f 17		 jg	 SHORT $LN29@str_to_flo

; 497  : 			break;
; 498  : 
; 499  : 		part2 *= 10;

  000ba	8d 34 b6	 lea	 esi, DWORD PTR [esi+esi*4]

; 500  : 		part2 += *str - '0';
; 501  : 		div *= 10;
; 502  : 		++str;

  000bd	83 c1 04	 add	 ecx, 4
  000c0	8d 76 e8	 lea	 esi, DWORD PTR [esi-24]
  000c3	8d 3c bf	 lea	 edi, DWORD PTR [edi+edi*4]
  000c6	8d 34 72	 lea	 esi, DWORD PTR [edx+esi*2]
  000c9	03 ff		 add	 edi, edi
  000cb	8b 11		 mov	 edx, DWORD PTR [ecx]
  000cd	85 d2		 test	 edx, edx
  000cf	75 df		 jne	 SHORT $LL4@str_to_flo
$LN29@str_to_flo:
  000d1	89 74 24 08	 mov	 DWORD PTR _part2$1$[esp+16], esi
  000d5	8b 74 24 0c	 mov	 esi, DWORD PTR _part1$1$[esp+16]
  000d9	8b 44 24 08	 mov	 eax, DWORD PTR _part2$1$[esp+16]
$LN22@str_to_flo:
  000dd	66 0f 6e c0	 movd	 xmm0, eax

; 503  : 	}
; 504  : 
; 505  : 	REAL fl = static_cast<REAL>(part1) + (static_cast<REAL>(part2) / div);

  000e1	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000e5	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000e8	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  000f1	66 0f 5a c8	 cvtpd2ps xmm1, xmm0
  000f5	66 0f 6e c7	 movd	 xmm0, edi
  000f9	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  000fd	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00100	f2 0f 58 04 fd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edi*8]
  00109	5f		 pop	 edi
  0010a	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0010e	f3 0f 5e c8	 divss	 xmm1, xmm0
  00112	66 0f 6e c6	 movd	 xmm0, esi
  00116	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0011a	c1 ee 1f	 shr	 esi, 31			; 0000001fH

; 506  : 	
; 507  : 	if (neg)

  0011d	80 7c 24 17 00	 cmp	 BYTE PTR _neg$1$[esp+8], 0
  00122	f2 0f 58 04 f5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[esi*8]
  0012b	66 0f 5a c0	 cvtpd2ps xmm0, xmm0
  0012f	f3 0f 58 c8	 addss	 xmm1, xmm0
  00133	f3 0f 11 4c 24
	04		 movss	 DWORD PTR _fl$[esp+12], xmm1
  00139	74 0d		 je	 SHORT $LN14@str_to_flo

; 508  : 		fl = -fl;

  0013b	0f 57 0d 00 00
	00 00		 xorps	 xmm1, DWORD PTR __xmm@80000000800000008000000080000000
  00142	f3 0f 11 4c 24
	04		 movss	 DWORD PTR _fl$[esp+12], xmm1
$LN14@str_to_flo:

; 509  : 	
; 510  : 	return amx_ftoc(fl);

  00148	8b 44 24 04	 mov	 eax, DWORD PTR _fl$[esp+12]
  0014c	5e		 pop	 esi

; 511  : }

  0014d	83 c4 08	 add	 esp, 8
  00150	c3		 ret	 0
?str_to_float@@YAHPAUtagAMX@@PAH@Z ENDP			; str_to_float
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?numtostr@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_szTemp$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?numtostr@@YAHPAUtagAMX@@PAH@Z PROC			; numtostr, COMDAT

; 449  : {

  00000	83 ec 24	 sub	 esp, 36			; 00000024H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	89 44 24 20	 mov	 DWORD PTR __$ArrayPad$[esp+36], eax
  0000e	56		 push	 esi
  0000f	8b 74 24 30	 mov	 esi, DWORD PTR _params$[esp+36]

; 450  : 	char szTemp[32];
; 451  : 	sprintf(szTemp, "%d", (int)params[1]);

  00013	8d 44 24 04	 lea	 eax, DWORD PTR _szTemp$[esp+40]
  00017	57		 push	 edi
  00018	8b 7c 24 30	 mov	 edi, DWORD PTR _amx$[esp+40]
  0001c	ff 76 04	 push	 DWORD PTR [esi+4]
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _sprintf

; 452  : 
; 453  : 	return set_amxstring(amx, params[2], szTemp, params[3]);

  0002a	ff 76 0c	 push	 DWORD PTR [esi+12]
  0002d	8d 44 24 18	 lea	 eax, DWORD PTR _szTemp$[esp+60]
  00031	50		 push	 eax
  00032	ff 76 08	 push	 DWORD PTR [esi+8]
  00035	57		 push	 edi
  00036	e8 00 00 00 00	 call	 ?set_amxstring@@YAHPAUtagAMX@@HPBDH@Z ; set_amxstring

; 454  : }

  0003b	8b 4c 24 44	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+72]
  0003f	83 c4 1c	 add	 esp, 28			; 0000001cH
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	33 cc		 xor	 ecx, esp
  00046	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004b	83 c4 24	 add	 esp, 36			; 00000024H
  0004e	c3		 ret	 0
?numtostr@@YAHPAUtagAMX@@PAH@Z ENDP			; numtostr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?amx_strtof@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_result$ = -4						; size = 4
_len$ = -4						; size = 4
_amx$ = 8						; size = 4
_pEnd$ = 12						; size = 4
_params$ = 12						; size = 4
?amx_strtof@@YAHPAUtagAMX@@PAH@Z PROC			; amx_strtof, COMDAT

; 435  : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	56		 push	 esi

; 436  : 	int len;
; 437  : 	char *pString = get_amxstring(amx, params[1], 0, len);

  00003	8b 74 24 10	 mov	 esi, DWORD PTR _amx$[esp+8]
  00007	8d 44 24 08	 lea	 eax, DWORD PTR _len$[esp+12]
  0000b	57		 push	 edi
  0000c	8b 7c 24 18	 mov	 edi, DWORD PTR _params$[esp+12]
  00010	50		 push	 eax
  00011	6a 00		 push	 0
  00013	ff 77 04	 push	 DWORD PTR [edi+4]
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring

; 438  : 	cell *endPos = get_amxaddr(amx, params[2]);

  0001c	ff 77 08	 push	 DWORD PTR [edi+8]
  0001f	8b d8		 mov	 ebx, eax
  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr
  00027	8b f0		 mov	 esi, eax

; 439  : 
; 440  : 	char *pEnd = NULL;

  00029	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR _pEnd$[esp+36], 0

; 441  : 	float result = strtod(pString, &pEnd);

  00031	8d 44 24 30	 lea	 eax, DWORD PTR _pEnd$[esp+36]
  00035	50		 push	 eax
  00036	53		 push	 ebx
  00037	e8 00 00 00 00	 call	 _strtod

; 442  : 
; 443  : 	*endPos = pEnd - pString;

  0003c	8b 44 24 38	 mov	 eax, DWORD PTR _pEnd$[esp+44]
  00040	83 c4 20	 add	 esp, 32			; 00000020H
  00043	2b c3		 sub	 eax, ebx
  00045	89 06		 mov	 DWORD PTR [esi], eax
  00047	d9 5c 24 0c	 fstp	 DWORD PTR _result$[esp+16]

; 444  : 
; 445  : 	return amx_ftoc(result);

  0004b	8b 44 24 0c	 mov	 eax, DWORD PTR _result$[esp+16]
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx

; 446  : }

  00052	59		 pop	 ecx
  00053	c3		 ret	 0
?amx_strtof@@YAHPAUtagAMX@@PAH@Z ENDP			; amx_strtof
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?amx_strtol@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_len$ = -4						; size = 4
_amx$ = 8						; size = 4
_pEnd$ = 12						; size = 4
_params$ = 12						; size = 4
?amx_strtol@@YAHPAUtagAMX@@PAH@Z PROC			; amx_strtol, COMDAT

; 416  : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp

; 417  : 	int len;
; 418  : 	int base = params[3];

  00003	8b 6c 24 14	 mov	 ebp, DWORD PTR _params$[esp+8]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b 5d 0c	 mov	 ebx, DWORD PTR [ebp+12]

; 419  : 
; 420  : 	if (base != 0 && (base < 2 || base > 36))

  0000c	85 db		 test	 ebx, ebx
  0000e	74 0c		 je	 SHORT $LN2@amx_strtol
  00010	83 fb 02	 cmp	 ebx, 2
  00013	7c 05		 jl	 SHORT $LN3@amx_strtol
  00015	83 fb 24	 cmp	 ebx, 36			; 00000024H
  00018	7e 02		 jle	 SHORT $LN2@amx_strtol
$LN3@amx_strtol:

; 421  : 		base = 0;

  0001a	33 db		 xor	 ebx, ebx
$LN2@amx_strtol:

; 422  : 
; 423  : 	char *pString = get_amxstring(amx, params[1], 0, len);

  0001c	8b 74 24 18	 mov	 esi, DWORD PTR _amx$[esp+16]
  00020	8d 44 24 10	 lea	 eax, DWORD PTR _len$[esp+20]
  00024	50		 push	 eax
  00025	6a 00		 push	 0
  00027	ff 75 04	 push	 DWORD PTR [ebp+4]
  0002a	56		 push	 esi
  0002b	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring

; 424  : 	cell *endPos = get_amxaddr(amx, params[2]);

  00030	ff 75 08	 push	 DWORD PTR [ebp+8]
  00033	8b f8		 mov	 edi, eax
  00035	56		 push	 esi
  00036	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr
  0003b	8b f0		 mov	 esi, eax

; 425  : 
; 426  : 	char *pEnd = NULL;

  0003d	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR _pEnd$[esp+40], 0

; 427  : 	long result = strtol(pString, &pEnd, base);

  00045	53		 push	 ebx
  00046	8d 44 24 38	 lea	 eax, DWORD PTR _pEnd$[esp+44]
  0004a	50		 push	 eax
  0004b	57		 push	 edi
  0004c	e8 00 00 00 00	 call	 _strtol

; 428  : 
; 429  : 	*endPos = pEnd - pString;

  00051	8b 4c 24 40	 mov	 ecx, DWORD PTR _pEnd$[esp+52]
  00055	83 c4 24	 add	 esp, 36			; 00000024H
  00058	2b cf		 sub	 ecx, edi
  0005a	89 0e		 mov	 DWORD PTR [esi], ecx
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5d		 pop	 ebp
  0005f	5b		 pop	 ebx

; 430  : 
; 431  : 	return result;
; 432  : }

  00060	59		 pop	 ecx
  00061	c3		 ret	 0
?amx_strtol@@YAHPAUtagAMX@@PAH@Z ENDP			; amx_strtol
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?strtonum@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_iLen$ = -4						; size = 4
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?strtonum@@YAHPAUtagAMX@@PAH@Z PROC			; strtonum, COMDAT

; 410  : {

  00000	51		 push	 ecx

; 411  : 	int iLen;
; 412  : 	return atoi(get_amxstring(amx, params[1], 0, iLen));

  00001	8d 04 24	 lea	 eax, DWORD PTR _iLen$[esp+4]
  00004	50		 push	 eax
  00005	8b 44 24 10	 mov	 eax, DWORD PTR _params$[esp+4]
  00009	6a 00		 push	 0
  0000b	ff 70 04	 push	 DWORD PTR [eax+4]
  0000e	ff 74 24 14	 push	 DWORD PTR _amx$[esp+12]
  00012	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 _atoi

; 413  : }

  0001d	83 c4 18	 add	 esp, 24			; 00000018H
  00020	c3		 ret	 0
?strtonum@@YAHPAUtagAMX@@PAH@Z ENDP			; strtonum
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?containi@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_str$1$ = -4						; size = 4
_amx$ = 8						; size = 4
_substr$1$ = 12						; size = 4
_params$ = 12						; size = 4
?containi@@YAHPAUtagAMX@@PAH@Z PROC			; containi, COMDAT

; 386  : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx

; 387  : 	register cell *a = get_amxaddr(amx, params[2]);

  00002	8b 5c 24 10	 mov	 ebx, DWORD PTR _params$[esp+4]
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	ff 73 08	 push	 DWORD PTR [ebx+8]
  0000c	8b 7c 24 1c	 mov	 edi, DWORD PTR _amx$[esp+20]
  00010	57		 push	 edi
  00011	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 388  : 	register cell *b = get_amxaddr(amx, params[1]);

  00016	ff 73 04	 push	 DWORD PTR [ebx+4]
  00019	8b f0		 mov	 esi, eax
  0001b	57		 push	 edi
  0001c	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr
  00021	8b e8		 mov	 ebp, eax

; 389  : 	register cell *c = b;
; 390  : 	cell* str = b;
; 391  : 	cell* substr = a;

  00023	89 74 24 2c	 mov	 DWORD PTR _substr$1$[esp+32], esi
  00027	83 c4 10	 add	 esp, 16			; 00000010H
  0002a	89 6c 24 10	 mov	 DWORD PTR _str$1$[esp+20], ebp
  0002e	8b dd		 mov	 ebx, ebp

; 392  : 	
; 393  : 	while (*c)

  00030	83 7d 00 00	 cmp	 DWORD PTR [ebp], 0
  00034	74 3f		 je	 SHORT $LN12@containi
$LL2@containi:

; 394  : 	{
; 395  : 		if (tolower(*c) == tolower(*a))

  00036	ff 36		 push	 DWORD PTR [esi]
  00038	e8 00 00 00 00	 call	 _tolower
  0003d	ff 33		 push	 DWORD PTR [ebx]
  0003f	8b f8		 mov	 edi, eax
  00041	e8 00 00 00 00	 call	 _tolower
  00046	83 c4 08	 add	 esp, 8
  00049	3b c7		 cmp	 eax, edi
  0004b	75 1a		 jne	 SHORT $LN4@containi

; 396  : 		{
; 397  : 			c++;
; 398  : 			if (!*++a)

  0004d	83 c6 04	 add	 esi, 4
  00050	83 c3 04	 add	 ebx, 4
  00053	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00056	75 18		 jne	 SHORT $LN5@containi

; 399  : 				return b - str;

  00058	2b 6c 24 10	 sub	 ebp, DWORD PTR _str$1$[esp+20]
  0005c	5f		 pop	 edi
  0005d	c1 fd 02	 sar	 ebp, 2
  00060	5e		 pop	 esi
  00061	8b c5		 mov	 eax, ebp
  00063	5d		 pop	 ebp
  00064	5b		 pop	 ebx

; 407  : }

  00065	59		 pop	 ecx
  00066	c3		 ret	 0
$LN4@containi:

; 400  : 		} else {
; 401  : 			c = ++b;
; 402  : 			a = substr;

  00067	8b 74 24 1c	 mov	 esi, DWORD PTR _substr$1$[esp+16]
  0006b	83 c5 04	 add	 ebp, 4
  0006e	8b dd		 mov	 ebx, ebp
$LN5@containi:

; 392  : 	
; 393  : 	while (*c)

  00070	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  00073	75 c1		 jne	 SHORT $LL2@containi
$LN12@containi:
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5d		 pop	 ebp

; 403  : 		}
; 404  : 	}
; 405  : 	
; 406  : 	return -1;

  00078	83 c8 ff	 or	 eax, -1
  0007b	5b		 pop	 ebx

; 407  : }

  0007c	59		 pop	 ecx
  0007d	c3		 ret	 0
?containi@@YAHPAUtagAMX@@PAH@Z ENDP			; containi
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?contain@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
?contain@@YAHPAUtagAMX@@PAH@Z PROC			; contain, COMDAT

; 362  : {

  00000	53		 push	 ebx

; 363  : 	register cell *a = get_amxaddr(amx, params[2]);

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _params$[esp]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 7c 24 10	 mov	 edi, DWORD PTR _amx$[esp+8]
  0000b	ff 73 08	 push	 DWORD PTR [ebx+8]
  0000e	57		 push	 edi
  0000f	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 364  : 	register cell *b = get_amxaddr(amx, params[1]);

  00014	ff 73 04	 push	 DWORD PTR [ebx+4]
  00017	8b f0		 mov	 esi, eax
  00019	57		 push	 edi
  0001a	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr
  0001f	83 c4 10	 add	 esp, 16			; 00000010H

; 365  : 	register cell *c = b;

  00022	8b d0		 mov	 edx, eax

; 366  : 	cell* str = b;

  00024	8b d8		 mov	 ebx, eax

; 367  : 	cell* substr = a;

  00026	8b fe		 mov	 edi, esi

; 368  : 	
; 369  : 	while (*c)

  00028	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002b	74 29		 je	 SHORT $LN12@contain
  0002d	0f 1f 00	 npad	 3
$LL2@contain:

; 370  : 	{
; 371  : 		if (*c == *a)

  00030	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00032	3b 0e		 cmp	 ecx, DWORD PTR [esi]
  00034	75 14		 jne	 SHORT $LN4@contain

; 372  : 		{
; 373  : 			c++;
; 374  : 			if (!*++a)

  00036	83 c6 04	 add	 esi, 4
  00039	83 c2 04	 add	 edx, 4
  0003c	83 3e 00	 cmp	 DWORD PTR [esi], 0
  0003f	75 10		 jne	 SHORT $LN5@contain

; 375  : 				return b - str;

  00041	5f		 pop	 edi
  00042	2b c3		 sub	 eax, ebx
  00044	5e		 pop	 esi
  00045	c1 f8 02	 sar	 eax, 2
  00048	5b		 pop	 ebx

; 383  : }

  00049	c3		 ret	 0
$LN4@contain:

; 376  : 		} else {
; 377  : 			c = ++b;

  0004a	83 c0 04	 add	 eax, 4

; 378  : 			a = substr;

  0004d	8b f7		 mov	 esi, edi
  0004f	8b d0		 mov	 edx, eax
$LN5@contain:

; 368  : 	
; 369  : 	while (*c)

  00051	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00054	75 da		 jne	 SHORT $LL2@contain
$LN12@contain:
  00056	5f		 pop	 edi
  00057	5e		 pop	 esi

; 379  : 		}
; 380  : 	}
; 381  : 	
; 382  : 	return -1;

  00058	83 c8 ff	 or	 eax, -1
  0005b	5b		 pop	 ebx

; 383  : }

  0005c	c3		 ret	 0
?contain@@YAHPAUtagAMX@@PAH@Z ENDP			; contain
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?replace_stringex@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_search$1$ = -12					; size = 4
_maxlength$1$ = -8					; size = 4
_caseSensitive$ = -4					; size = 1
_amx$ = 8						; size = 4
_replace$1$ = 12					; size = 4
_len$ = 12						; size = 4
_params$ = 12						; size = 4
?replace_stringex@@YAHPAUtagAMX@@PAH@Z PROC		; replace_stringex, COMDAT

; 330  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx

; 331  : 	int len;
; 332  : 	size_t maxlength = (size_t)params[2];
; 333  : 
; 334  : 	char *text = get_amxstring(amx, params[1], 0, len);

  00004	8b 5c 24 14	 mov	 ebx, DWORD PTR _amx$[esp+12]
  00008	8d 44 24 18	 lea	 eax, DWORD PTR _len$[esp+12]
  0000c	55		 push	 ebp
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b 7c 24 24	 mov	 edi, DWORD PTR _params$[esp+24]
  00013	50		 push	 eax
  00014	6a 00		 push	 0
  00016	ff 77 04	 push	 DWORD PTR [edi+4]
  00019	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  0001c	53		 push	 ebx
  0001d	89 74 24 24	 mov	 DWORD PTR _maxlength$1$[esp+44], esi
  00021	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  00026	8b e8		 mov	 ebp, eax

; 335  : 	const char *search = get_amxstring(amx, params[3], 1, len);

  00028	8d 44 24 34	 lea	 eax, DWORD PTR _len$[esp+40]
  0002c	50		 push	 eax
  0002d	6a 01		 push	 1
  0002f	ff 77 0c	 push	 DWORD PTR [edi+12]
  00032	53		 push	 ebx
  00033	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  00038	89 44 24 30	 mov	 DWORD PTR _search$1$[esp+60], eax

; 336  : 	const char *replace = get_amxstring(amx, params[4], 2, len);

  0003c	8d 44 24 44	 lea	 eax, DWORD PTR _len$[esp+56]
  00040	50		 push	 eax
  00041	6a 02		 push	 2
  00043	ff 77 10	 push	 DWORD PTR [edi+16]
  00046	53		 push	 ebx
  00047	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring

; 337  : 
; 338  : 	size_t searchLen = (params[5] == -1) ? strlen(search) : (size_t)params[5];

  0004c	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  0004f	83 c4 30	 add	 esp, 48			; 00000030H
  00052	89 44 24 24	 mov	 DWORD PTR _replace$1$[esp+24], eax
  00056	83 fa ff	 cmp	 edx, -1
  00059	75 14		 jne	 SHORT $LN5@replace_st
  0005b	8b 54 24 10	 mov	 edx, DWORD PTR _search$1$[esp+28]
  0005f	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
$LL9@replace_st:
  00062	8a 02		 mov	 al, BYTE PTR [edx]
  00064	42		 inc	 edx
  00065	84 c0		 test	 al, al
  00067	75 f9		 jne	 SHORT $LL9@replace_st
  00069	8b 44 24 24	 mov	 eax, DWORD PTR _replace$1$[esp+24]
  0006d	2b d1		 sub	 edx, ecx
$LN5@replace_st:

; 339  : 	size_t replaceLen = (params[6] == -1) ? strlen(replace) : (size_t)params[6];

  0006f	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00072	83 f9 ff	 cmp	 ecx, -1
  00075	75 16		 jne	 SHORT $LN7@replace_st
  00077	8b c8		 mov	 ecx, eax
  00079	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  0007c	0f 1f 40 00	 npad	 4
$LL10@replace_st:
  00080	8a 01		 mov	 al, BYTE PTR [ecx]
  00082	41		 inc	 ecx
  00083	84 c0		 test	 al, al
  00085	75 f9		 jne	 SHORT $LL10@replace_st
  00087	2b ce		 sub	 ecx, esi
  00089	8b 74 24 14	 mov	 esi, DWORD PTR _maxlength$1$[esp+28]
$LN7@replace_st:

; 340  : 
; 341  : 	bool caseSensitive = params[7] ? true : false;

  0008d	83 7f 1c 00	 cmp	 DWORD PTR [edi+28], 0
  00091	0f 95 44 24 18	 setne	 BYTE PTR _caseSensitive$[esp+28]

; 342  : 
; 343  : 	if (searchLen == 0)

  00096	85 d2		 test	 edx, edx
  00098	75 1b		 jne	 SHORT $LN2@replace_st

; 344  : 	{
; 345  : 		LogError(amx, AMX_ERR_NATIVE, "Cannot replace searches of empty strings.");

  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IBLGDDPF@Cannot?5replace?5searches?5of?5empty@
  0009f	6a 0a		 push	 10			; 0000000aH
  000a1	53		 push	 ebx
  000a2	e8 00 00 00 00	 call	 _LogError
  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN11@replace_st:

; 346  : 		return -1;

  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5d		 pop	 ebp
  000ad	83 c8 ff	 or	 eax, -1
  000b0	5b		 pop	 ebx

; 359  : }

  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b4	c3		 ret	 0
$LN2@replace_st:

; 347  : 	}
; 348  : 
; 349  : 	char *ptr = UTIL_ReplaceEx(text, maxlength + 1, search, searchLen, replace, replaceLen, caseSensitive); // + EOS

  000b5	ff 74 24 18	 push	 DWORD PTR _caseSensitive$[esp+28]
  000b9	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  000bc	51		 push	 ecx
  000bd	ff 74 24 2c	 push	 DWORD PTR _replace$1$[esp+32]
  000c1	52		 push	 edx
  000c2	ff 74 24 20	 push	 DWORD PTR _search$1$[esp+44]
  000c6	50		 push	 eax
  000c7	55		 push	 ebp
  000c8	e8 00 00 00 00	 call	 ?UTIL_ReplaceEx@@YAPADPADIPBDI1I_N@Z ; UTIL_ReplaceEx
  000cd	8b f0		 mov	 esi, eax
  000cf	83 c4 1c	 add	 esp, 28			; 0000001cH

; 350  : 
; 351  : 	if (!ptr)

  000d2	85 f6		 test	 esi, esi
  000d4	74 d4		 je	 SHORT $LN11@replace_st

; 352  : 	{
; 353  : 		return -1;
; 354  : 	}
; 355  : 
; 356  : 	set_amxstring(amx, params[1], text, maxlength);

  000d6	ff 74 24 14	 push	 DWORD PTR _maxlength$1$[esp+28]
  000da	55		 push	 ebp
  000db	ff 77 04	 push	 DWORD PTR [edi+4]
  000de	53		 push	 ebx
  000df	e8 00 00 00 00	 call	 ?set_amxstring@@YAHPAUtagAMX@@HPBDH@Z ; set_amxstring
  000e4	83 c4 10	 add	 esp, 16			; 00000010H

; 357  : 
; 358  : 	return ptr - text;

  000e7	2b f5		 sub	 esi, ebp
  000e9	8b c6		 mov	 eax, esi
  000eb	5f		 pop	 edi
  000ec	5e		 pop	 esi
  000ed	5d		 pop	 ebp
  000ee	5b		 pop	 ebx

; 359  : }

  000ef	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f2	c3		 ret	 0
?replace_stringex@@YAHPAUtagAMX@@PAH@Z ENDP		; replace_stringex
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?replace_string@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_search$1$ = -8						; size = 4
_text$1$ = -4						; size = 4
_amx$ = 8						; size = 4
_caseSensitive$ = 12					; size = 1
_len$ = 12						; size = 4
_params$ = 12						; size = 4
?replace_string@@YAHPAUtagAMX@@PAH@Z PROC		; replace_string, COMDAT

; 306  : {

  00000	83 ec 08	 sub	 esp, 8
  00003	53		 push	 ebx

; 307  : 	int len;
; 308  : 	size_t maxlength = (size_t)params[2];

  00004	8b 5c 24 14	 mov	 ebx, DWORD PTR _params$[esp+8]

; 309  : 
; 310  : 	char *text = get_amxstring(amx, params[1], 0, len);

  00008	8d 44 24 14	 lea	 eax, DWORD PTR _len$[esp+8]
  0000c	55		 push	 ebp
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b 7c 24 1c	 mov	 edi, DWORD PTR _amx$[esp+20]
  00013	8b 6b 08	 mov	 ebp, DWORD PTR [ebx+8]
  00016	50		 push	 eax
  00017	6a 00		 push	 0
  00019	ff 73 04	 push	 DWORD PTR [ebx+4]
  0001c	57		 push	 edi
  0001d	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  00022	8b f0		 mov	 esi, eax

; 311  : 	const char *search = get_amxstring(amx, params[3], 1, len);

  00024	8d 44 24 30	 lea	 eax, DWORD PTR _len$[esp+36]
  00028	50		 push	 eax
  00029	6a 01		 push	 1
  0002b	ff 73 0c	 push	 DWORD PTR [ebx+12]
  0002e	89 74 24 30	 mov	 DWORD PTR _text$1$[esp+52], esi
  00032	57		 push	 edi
  00033	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  00038	89 44 24 30	 mov	 DWORD PTR _search$1$[esp+56], eax

; 312  : 	const char *replace = get_amxstring(amx, params[4], 2, len);

  0003c	8d 44 24 40	 lea	 eax, DWORD PTR _len$[esp+52]
  00040	50		 push	 eax
  00041	6a 02		 push	 2
  00043	ff 73 10	 push	 DWORD PTR [ebx+16]
  00046	57		 push	 edi
  00047	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  0004c	83 c4 30	 add	 esp, 48			; 00000030H
  0004f	8b c8		 mov	 ecx, eax

; 313  : 
; 314  : 	bool caseSensitive = params[5] ? true : false;

  00051	83 7b 14 00	 cmp	 DWORD PTR [ebx+20], 0

; 315  : 
; 316  : 	if (search[0] == '\0')

  00055	8b 44 24 10	 mov	 eax, DWORD PTR _search$1$[esp+24]
  00059	0f 95 44 24 20	 setne	 BYTE PTR _caseSensitive$[esp+20]
  0005e	80 38 00	 cmp	 BYTE PTR [eax], 0
  00061	75 1b		 jne	 SHORT $LN2@replace_st

; 317  : 	{
; 318  : 		LogError(amx, AMX_ERR_NATIVE, "Cannot replace searches of empty strings.");

  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@IBLGDDPF@Cannot?5replace?5searches?5of?5empty@
  00068	6a 0a		 push	 10			; 0000000aH
  0006a	57		 push	 edi
  0006b	e8 00 00 00 00	 call	 _LogError
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH

; 319  : 		return -1;

  00073	83 c8 ff	 or	 eax, -1
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5d		 pop	 ebp
  00079	5b		 pop	 ebx

; 327  : }

  0007a	83 c4 08	 add	 esp, 8
  0007d	c3		 ret	 0
$LN2@replace_st:

; 320  : 	}
; 321  : 
; 322  : 	int count = UTIL_ReplaceAll(text, maxlength + 1, search, replace, caseSensitive); // + EOS

  0007e	ff 74 24 20	 push	 DWORD PTR _caseSensitive$[esp+20]
  00082	51		 push	 ecx
  00083	50		 push	 eax
  00084	8d 45 01	 lea	 eax, DWORD PTR [ebp+1]
  00087	50		 push	 eax
  00088	56		 push	 esi
  00089	e8 00 00 00 00	 call	 ?UTIL_ReplaceAll@@YAIPADIPBD1_N@Z ; UTIL_ReplaceAll

; 323  : 
; 324  : 	set_amxstring(amx, params[1], text, maxlength);

  0008e	55		 push	 ebp
  0008f	ff 74 24 2c	 push	 DWORD PTR _text$1$[esp+48]
  00093	8b f0		 mov	 esi, eax
  00095	ff 73 04	 push	 DWORD PTR [ebx+4]
  00098	57		 push	 edi
  00099	e8 00 00 00 00	 call	 ?set_amxstring@@YAHPAUtagAMX@@HPBDH@Z ; set_amxstring
  0009e	83 c4 24	 add	 esp, 36			; 00000024H

; 325  : 
; 326  : 	return count;

  000a1	8b c6		 mov	 eax, esi
  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	5d		 pop	 ebp
  000a6	5b		 pop	 ebx

; 327  : }

  000a7	83 c4 08	 add	 esp, 8
  000aa	c3		 ret	 0
?replace_string@@YAHPAUtagAMX@@PAH@Z ENDP		; replace_string
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?replace@@YAHPAUtagAMX@@PAH@Z
_TEXT	SEGMENT
_len$1$ = -24						; size = 4
tv250 = -20						; size = 4
_textLen$1$ = -16					; size = 4
_whatLen$1$ = -12					; size = 4
_with$1$ = -8						; size = 4
tv249 = -4						; size = 4
_amx$ = 8						; size = 4
_withLen$1$ = 12					; size = 4
_params$ = 12						; size = 4
?replace@@YAHPAUtagAMX@@PAH@Z PROC			; replace, COMDAT

; 257  : {

  00000	83 ec 18	 sub	 esp, 24			; 00000018H
  00003	53		 push	 ebx

; 258  : 	cell *text = get_amxaddr(amx, params[1]);

  00004	8b 5c 24 20	 mov	 ebx, DWORD PTR _amx$[esp+24]
  00008	55		 push	 ebp
  00009	56		 push	 esi
  0000a	8b 74 24 2c	 mov	 esi, DWORD PTR _params$[esp+32]
  0000e	57		 push	 edi
  0000f	ff 76 04	 push	 DWORD PTR [esi+4]
  00012	53		 push	 ebx
  00013	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 259  : 	cell len = params[2];
; 260  : 	cell *what = get_amxaddr(amx, params[3]);

  00018	ff 76 0c	 push	 DWORD PTR [esi+12]
  0001b	8b f8		 mov	 edi, eax
  0001d	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00020	53		 push	 ebx
  00021	89 44 24 20	 mov	 DWORD PTR _len$1$[esp+56], eax
  00025	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 261  : 	cell *with = get_amxaddr(amx, params[4]);

  0002a	ff 76 10	 push	 DWORD PTR [esi+16]
  0002d	8b e8		 mov	 ebp, eax
  0002f	53		 push	 ebx
  00030	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 262  : 	cell *textptr = text;
; 263  : 
; 264  : 	int withLen = amxstring_len(with);

  00035	50		 push	 eax
  00036	89 44 24 3c	 mov	 DWORD PTR _with$1$[esp+68], eax
  0003a	e8 00 00 00 00	 call	 ?amxstring_len@@YAHPAH@Z ; amxstring_len

; 265  : 	int whatLen = amxstring_len(what);

  0003f	55		 push	 ebp
  00040	89 44 24 50	 mov	 DWORD PTR _withLen$1$[esp+68], eax
  00044	e8 00 00 00 00	 call	 ?amxstring_len@@YAHPAH@Z ; amxstring_len
  00049	8b f0		 mov	 esi, eax

; 266  : 	int textLen = amxstring_len(text);

  0004b	57		 push	 edi
  0004c	89 74 24 40	 mov	 DWORD PTR _whatLen$1$[esp+76], esi
  00050	e8 00 00 00 00	 call	 ?amxstring_len@@YAHPAH@Z ; amxstring_len
  00055	83 c4 24	 add	 esp, 36			; 00000024H
  00058	89 44 24 18	 mov	 DWORD PTR _textLen$1$[esp+40], eax

; 267  : 
; 268  : 	if (whatLen > textLen)

  0005c	3b f0		 cmp	 esi, eax
  0005e	7f 15		 jg	 SHORT $LN15@replace

; 269  : 		return 0;
; 270  : 
; 271  : 	if (whatLen < 1)

  00060	83 fe 01	 cmp	 esi, 1
  00063	7d 1a		 jge	 SHORT $LN5@replace

; 272  : 	{
; 273  : 		LogError(amx, AMX_ERR_NATIVE, "No search string specified.");

  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@KJALMONH@No?5search?5string?5specified?4?$AA@
  0006a	6a 0a		 push	 10			; 0000000aH
  0006c	53		 push	 ebx
  0006d	e8 00 00 00 00	 call	 _LogError
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@replace:

; 300  : 	}
; 301  : 	
; 302  : 	return 0;

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5d		 pop	 ebp
  00078	33 c0		 xor	 eax, eax
  0007a	5b		 pop	 ebx

; 303  : }

  0007b	83 c4 18	 add	 esp, 24			; 00000018H
  0007e	c3		 ret	 0
$LN5@replace:

; 274  : 		return 0;
; 275  : 	}
; 276  : 
; 277  : 	if (textLen - whatLen + withLen > len)

  0007f	8b 54 24 30	 mov	 edx, DWORD PTR _withLen$1$[esp+36]
  00083	8b c8		 mov	 ecx, eax
  00085	8b 44 24 10	 mov	 eax, DWORD PTR _len$1$[esp+40]
  00089	2b ce		 sub	 ecx, esi
  0008b	03 d1		 add	 edx, ecx
  0008d	89 4c 24 14	 mov	 DWORD PTR tv250[esp+40], ecx
  00091	89 54 24 24	 mov	 DWORD PTR tv249[esp+40], edx
  00095	3b d0		 cmp	 edx, eax
  00097	7e 1c		 jle	 SHORT $LN6@replace

; 278  : 	{
; 279  : 		LogError(amx, AMX_ERR_NATIVE, "replace() buffer not big enough (%d>=%d)", (textLen - whatLen + withLen), len);

  00099	50		 push	 eax
  0009a	52		 push	 edx
  0009b	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@NFNJDNGL@replace?$CI?$CJ?5buffer?5not?5big?5enough?5@
  000a0	6a 0a		 push	 10			; 0000000aH
  000a2	53		 push	 ebx
  000a3	e8 00 00 00 00	 call	 _LogError
  000a8	83 c4 14	 add	 esp, 20			; 00000014H

; 300  : 	}
; 301  : 	
; 302  : 	return 0;

  000ab	33 c0		 xor	 eax, eax
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5d		 pop	 ebp
  000b0	5b		 pop	 ebx

; 303  : }

  000b1	83 c4 18	 add	 esp, 24			; 00000018H
  000b4	c3		 ret	 0
$LN6@replace:

; 280  : 		return 0;
; 281  : 	}
; 282  : 
; 283  : 	cell browsed = 0;
; 284  : 	while (*text && (browsed <= (textLen-whatLen)))

  000b5	8b 07		 mov	 eax, DWORD PTR [edi]
  000b7	33 db		 xor	 ebx, ebx
  000b9	85 c0		 test	 eax, eax
  000bb	74 b8		 je	 SHORT $LN15@replace
  000bd	0f 1f 00	 npad	 3
$LL2@replace:
  000c0	3b d9		 cmp	 ebx, ecx
  000c2	7f b1		 jg	 SHORT $LN15@replace

; 285  : 	{
; 286  : 		if (*text == *what)

  000c4	3b 45 00	 cmp	 eax, DWORD PTR [ebp]
  000c7	75 13		 jne	 SHORT $LN8@replace

; 287  : 		{
; 288  : 			if (fastcellcmp(text, what, whatLen))

  000c9	56		 push	 esi
  000ca	55		 push	 ebp
  000cb	57		 push	 edi
  000cc	e8 00 00 00 00	 call	 ?fastcellcmp@@YA_NPAH0H@Z ; fastcellcmp
  000d1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d4	84 c0		 test	 al, al
  000d6	75 17		 jne	 SHORT $LN11@replace
  000d8	8b 4c 24 14	 mov	 ecx, DWORD PTR tv250[esp+40]
$LN8@replace:

; 280  : 		return 0;
; 281  : 	}
; 282  : 
; 283  : 	cell browsed = 0;
; 284  : 	while (*text && (browsed <= (textLen-whatLen)))

  000dc	8b 47 04	 mov	 eax, DWORD PTR [edi+4]

; 296  : 			}
; 297  : 		}
; 298  : 		text++;

  000df	83 c7 04	 add	 edi, 4

; 299  : 		browsed++;

  000e2	43		 inc	 ebx
  000e3	85 c0		 test	 eax, eax
  000e5	75 d9		 jne	 SHORT $LL2@replace
  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi
  000e9	5d		 pop	 ebp
  000ea	5b		 pop	 ebx

; 303  : }

  000eb	83 c4 18	 add	 esp, 24			; 00000018H
  000ee	c3		 ret	 0
$LN11@replace:

; 289  : 			{
; 290  : 				cell *saveptr = text + whatLen;
; 291  : 				cell restlen = textLen - (browsed + whatLen);
; 292  : 				textptr = text + withLen;

  000ef	8b 44 24 30	 mov	 eax, DWORD PTR _withLen$1$[esp+36]

; 293  : 				memmove(textptr, saveptr, (restlen + 1) * sizeof(cell));

  000f3	8b 4c 24 1c	 mov	 ecx, DWORD PTR _whatLen$1$[esp+40]
  000f7	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  000fe	8b 44 24 18	 mov	 eax, DWORD PTR _textLen$1$[esp+40]
  00102	2b c3		 sub	 eax, ebx
  00104	2b c1		 sub	 eax, ecx
  00106	8d 04 85 04 00
	00 00		 lea	 eax, DWORD PTR [eax*4+4]
  0010d	50		 push	 eax
  0010e	8d 04 8f	 lea	 eax, DWORD PTR [edi+ecx*4]
  00111	50		 push	 eax
  00112	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]
  00115	51		 push	 ecx
  00116	e8 00 00 00 00	 call	 _memmove

; 294  : 				memcpy(text, with, withLen * sizeof(cell));

  0011b	56		 push	 esi
  0011c	ff 74 24 30	 push	 DWORD PTR _with$1$[esp+56]
  00120	57		 push	 edi
  00121	e8 00 00 00 00	 call	 _memcpy

; 295  : 				return (textLen - whatLen + withLen);

  00126	8b 44 24 3c	 mov	 eax, DWORD PTR tv249[esp+64]
  0012a	83 c4 18	 add	 esp, 24			; 00000018H
  0012d	5f		 pop	 edi
  0012e	5e		 pop	 esi
  0012f	5d		 pop	 ebp
  00130	5b		 pop	 ebx

; 303  : }

  00131	83 c4 18	 add	 esp, 24			; 00000018H
  00134	c3		 ret	 0
?replace@@YAHPAUtagAMX@@PAH@Z ENDP			; replace
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?fastcellcmp@@YA_NPAH0H@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
_len$ = 16						; size = 4
?fastcellcmp@@YA_NPAH0H@Z PROC				; fastcellcmp, COMDAT

; 246  : {

  00000	56		 push	 esi

; 247  : 	while (len--)

  00001	8b 74 24 10	 mov	 esi, DWORD PTR _len$[esp]
  00005	57		 push	 edi
  00006	85 f6		 test	 esi, esi
  00008	74 1c		 je	 SHORT $LN8@fastcellcm
  0000a	8b 7c 24 0c	 mov	 edi, DWORD PTR _a$[esp+4]
  0000e	8b 54 24 10	 mov	 edx, DWORD PTR _b$[esp+4]
  00012	2b fa		 sub	 edi, edx
$LL2@fastcellcm:

; 248  : 	{
; 249  : 		if (*a++ != *b++)

  00014	8b 0c 17	 mov	 ecx, DWORD PTR [edi+edx]
  00017	8d 52 04	 lea	 edx, DWORD PTR [edx+4]
  0001a	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  0001d	4e		 dec	 esi
  0001e	3b c8		 cmp	 ecx, eax
  00020	75 09		 jne	 SHORT $LN7@fastcellcm

; 247  : 	while (len--)

  00022	85 f6		 test	 esi, esi
  00024	75 ee		 jne	 SHORT $LL2@fastcellcm
$LN8@fastcellcm:
  00026	5f		 pop	 edi

; 251  : 	}
; 252  : 
; 253  : 	return true;

  00027	b0 01		 mov	 al, 1
  00029	5e		 pop	 esi

; 254  : }

  0002a	c3		 ret	 0
$LN7@fastcellcm:
  0002b	5f		 pop	 edi

; 250  : 			return false;

  0002c	32 c0		 xor	 al, al
  0002e	5e		 pop	 esi

; 254  : }

  0002f	c3		 ret	 0
?fastcellcmp@@YA_NPAH0H@Z ENDP				; fastcellcmp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?parse_arg@@YAPADPAPADAAH@Z
_TEXT	SEGMENT
_line$ = 8						; size = 4
_state$ = 12						; size = 4
?parse_arg@@YAPADPAPADAAH@Z PROC			; parse_arg, COMDAT

; 207  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 208  : 	static char arg[3072];
; 209  : 	char* dest = arg;
; 210  : 	state = 0;
; 211  : 	
; 212  : 	while (**line)

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR _line$[esp+4]
  00006	bb 00 00 00 00	 mov	 ebx, OFFSET ?arg@?1??parse_arg@@YAPADPAPADAAH@Z@4PADA
  0000b	57		 push	 edi
  0000c	8b 7c 24 14	 mov	 edi, DWORD PTR _state$[esp+8]
  00010	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00016	8b 06		 mov	 eax, DWORD PTR [esi]
  00018	80 38 00	 cmp	 BYTE PTR [eax], 0
  0001b	74 53		 je	 SHORT $LN22@parse_arg
  0001d	0f 1f 00	 npad	 3
$LL2@parse_arg:

; 213  : 	{
; 214  : 		if (isspace(**line))

  00020	8b 06		 mov	 eax, DWORD PTR [esi]
  00022	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _isspace
  0002b	83 c4 04	 add	 esp, 4
  0002e	85 c0		 test	 eax, eax
  00030	74 0d		 je	 SHORT $LN4@parse_arg

; 215  : 		{
; 216  : 			if (state == 1)

  00032	8b 07		 mov	 eax, DWORD PTR [edi]
  00034	83 f8 01	 cmp	 eax, 1
  00037	74 37		 je	 SHORT $LN22@parse_arg

; 217  : 				break;
; 218  : 			else if (!state)

  00039	85 c0		 test	 eax, eax
  0003b	75 0d		 jne	 SHORT $LN9@parse_arg

; 219  : 			{
; 220  : 				(*line)++;
; 221  : 				continue;

  0003d	eb 28		 jmp	 SHORT $LN25@parse_arg
$LN4@parse_arg:

; 222  : 			}
; 223  : 		}
; 224  : 		else if (state != 2)

  0003f	83 3f 02	 cmp	 DWORD PTR [edi], 2
  00042	74 06		 je	 SHORT $LN9@parse_arg

; 225  : 			state = 1;

  00044	c7 07 01 00 00
	00		 mov	 DWORD PTR [edi], 1
$LN9@parse_arg:

; 226  : 		
; 227  : 		if (**line == '"')

  0004a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0004c	8a 01		 mov	 al, BYTE PTR [ecx]
  0004e	3c 22		 cmp	 al, 34			; 00000022H
  00050	75 12		 jne	 SHORT $LN10@parse_arg

; 228  : 		{
; 229  : 			(*line)++;

  00052	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00055	89 06		 mov	 DWORD PTR [esi], eax

; 230  : 			
; 231  : 			if (state == 2)

  00057	83 3f 02	 cmp	 DWORD PTR [edi], 2
  0005a	74 14		 je	 SHORT $LN22@parse_arg

; 232  : 				break;
; 233  : 			
; 234  : 			state = 2;

  0005c	c7 07 02 00 00
	00		 mov	 DWORD PTR [edi], 2

; 235  : 			continue;

  00062	eb 05		 jmp	 SHORT $LN18@parse_arg
$LN10@parse_arg:

; 236  : 		}
; 237  : 		
; 238  : 		*dest++ = *(*line)++;

  00064	88 03		 mov	 BYTE PTR [ebx], al
  00066	43		 inc	 ebx
$LN25@parse_arg:
  00067	ff 06		 inc	 DWORD PTR [esi]
$LN18@parse_arg:

; 208  : 	static char arg[3072];
; 209  : 	char* dest = arg;
; 210  : 	state = 0;
; 211  : 	
; 212  : 	while (**line)

  00069	8b 06		 mov	 eax, DWORD PTR [esi]
  0006b	80 38 00	 cmp	 BYTE PTR [eax], 0
  0006e	75 b0		 jne	 SHORT $LL2@parse_arg
$LN22@parse_arg:
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi

; 239  : 	}
; 240  : 	
; 241  : 	*dest = '\0';

  00072	c6 03 00	 mov	 BYTE PTR [ebx], 0

; 242  : 	return arg;

  00075	b8 00 00 00 00	 mov	 eax, OFFSET ?arg@?1??parse_arg@@YAPADPAPADAAH@Z@4PADA
  0007a	5b		 pop	 ebx

; 243  : }

  0007b	c3		 ret	 0
?parse_arg@@YAPADPAPADAAH@Z ENDP			; parse_arg
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_amx_addr$ = 12						; size = 4
_source$ = 16						; size = 4
_sourcelen$ = 20					; size = 4
_maxlen$ = 24						; size = 4
??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z PROC	; set_amxstring_utf8<char>, COMDAT

; 110  : 	size_t len = sourcelen;
; 111  : 	bool needtocheck = false;
; 112  : 
; 113  : 	register cell* dest = (cell *)(amx->base + (int)(((AMX_HEADER *)amx->base)->dat + amx_addr));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _amx$[esp-4]
  00004	53		 push	 ebx
  00005	55		 push	 ebp
  00006	8b 6c 24 1c	 mov	 ebp, DWORD PTR _maxlen$[esp+4]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	56		 push	 esi
  0000d	8b f5		 mov	 esi, ebp
  0000f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00012	03 c8		 add	 ecx, eax
  00014	8b 44 24 1c	 mov	 eax, DWORD PTR _sourcelen$[esp+8]
  00018	03 4c 24 14	 add	 ecx, DWORD PTR _amx_addr$[esp+8]
  0001c	3b c5		 cmp	 eax, ebp

; 114  : 	register cell* start = dest;

  0001e	8b d9		 mov	 ebx, ecx
  00020	0f 46 f0	 cmovbe	 esi, eax

; 115  : 
; 116  : 	if (len > maxlen)
; 117  : 	{
; 118  : 		len = maxlen;
; 119  : 		needtocheck = true;
; 120  : 	}
; 121  : 
; 122  : 	maxlen = len;

  00023	8b d6		 mov	 edx, esi

; 123  : 
; 124  : 	while (maxlen-- && *source)

  00025	85 d2		 test	 edx, edx
  00027	74 20		 je	 SHORT $LN8@set_amxstr
  00029	57		 push	 edi
  0002a	8b 7c 24 1c	 mov	 edi, DWORD PTR _source$[esp+12]
  0002e	66 90		 npad	 2
$LL2@set_amxstr:
  00030	8a 07		 mov	 al, BYTE PTR [edi]
  00032	4a		 dec	 edx
  00033	84 c0		 test	 al, al
  00035	74 0d		 je	 SHORT $LN14@set_amxstr

; 125  : 	{
; 126  : 		*dest++ = *(unsigned char*)source++;

  00037	0f b6 c0	 movzx	 eax, al
  0003a	47		 inc	 edi
  0003b	89 01		 mov	 DWORD PTR [ecx], eax
  0003d	83 c1 04	 add	 ecx, 4
  00040	85 d2		 test	 edx, edx
  00042	75 ec		 jne	 SHORT $LL2@set_amxstr
$LN14@set_amxstr:
  00044	8b 44 24 20	 mov	 eax, DWORD PTR _sourcelen$[esp+12]
  00048	5f		 pop	 edi
$LN8@set_amxstr:
  00049	3b c5		 cmp	 eax, ebp

; 127  : 	}
; 128  : 
; 129  : 	if (needtocheck && (start[len - 1] & 1 << 7))

  0004b	76 17		 jbe	 SHORT $LN12@set_amxstr
  0004d	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  00050	f6 04 83 80	 test	 BYTE PTR [ebx+eax*4], 128 ; 00000080H
  00054	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  00057	74 0b		 je	 SHORT $LN12@set_amxstr

; 130  : 	{
; 131  : 		len -= UTIL_CheckValidChar(start + len - 1);

  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ??$UTIL_CheckValidChar@H@@YAHPAH@Z ; UTIL_CheckValidChar<int>
  0005f	83 c4 04	 add	 esp, 4
  00062	2b f0		 sub	 esi, eax
$LN12@set_amxstr:

; 132  : 	}
; 133  : 
; 134  : 	start[len] = '\0';

  00064	c7 04 b3 00 00
	00 00		 mov	 DWORD PTR [ebx+esi*4], 0

; 135  : 
; 136  : 	return len;

  0006b	8b c6		 mov	 eax, esi
  0006d	5e		 pop	 esi
  0006e	5d		 pop	 ebp
  0006f	5b		 pop	 ebx

; 137  : }

  00070	c3		 ret	 0
??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z ENDP	; set_amxstring_utf8<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ??$set_amxstring_utf8@H@@YAHPAUtagAMX@@HPBHII@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_amx_addr$ = 12						; size = 4
_source$ = 16						; size = 4
_sourcelen$ = 20					; size = 4
_maxlen$ = 24						; size = 4
??$set_amxstring_utf8@H@@YAHPAUtagAMX@@HPBHII@Z PROC	; set_amxstring_utf8<int>, COMDAT

; 110  : 	size_t len = sourcelen;
; 111  : 	bool needtocheck = false;
; 112  : 
; 113  : 	register cell* dest = (cell *)(amx->base + (int)(((AMX_HEADER *)amx->base)->dat + amx_addr));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _amx$[esp-4]
  00004	53		 push	 ebx
  00005	55		 push	 ebp
  00006	8b 6c 24 1c	 mov	 ebp, DWORD PTR _maxlen$[esp+4]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	56		 push	 esi
  0000d	8b f5		 mov	 esi, ebp
  0000f	57		 push	 edi
  00010	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00013	03 d0		 add	 edx, eax
  00015	8b 44 24 20	 mov	 eax, DWORD PTR _sourcelen$[esp+12]
  00019	03 54 24 18	 add	 edx, DWORD PTR _amx_addr$[esp+12]
  0001d	3b c5		 cmp	 eax, ebp

; 114  : 	register cell* start = dest;

  0001f	8b da		 mov	 ebx, edx
  00021	0f 46 f0	 cmovbe	 esi, eax

; 115  : 
; 116  : 	if (len > maxlen)
; 117  : 	{
; 118  : 		len = maxlen;
; 119  : 		needtocheck = true;
; 120  : 	}
; 121  : 
; 122  : 	maxlen = len;

  00024	8b fe		 mov	 edi, esi

; 123  : 
; 124  : 	while (maxlen-- && *source)

  00026	85 ff		 test	 edi, edi
  00028	74 1f		 je	 SHORT $LN8@set_amxstr
  0002a	8b 4c 24 1c	 mov	 ecx, DWORD PTR _source$[esp+12]
  0002e	66 90		 npad	 2
$LL2@set_amxstr:
  00030	4f		 dec	 edi
  00031	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00034	74 0f		 je	 SHORT $LN14@set_amxstr

; 125  : 	{
; 126  : 		*dest++ = *(unsigned char*)source++;

  00036	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00039	83 c1 04	 add	 ecx, 4
  0003c	89 02		 mov	 DWORD PTR [edx], eax
  0003e	83 c2 04	 add	 edx, 4
  00041	85 ff		 test	 edi, edi
  00043	75 eb		 jne	 SHORT $LL2@set_amxstr
$LN14@set_amxstr:
  00045	8b 44 24 20	 mov	 eax, DWORD PTR _sourcelen$[esp+12]
$LN8@set_amxstr:
  00049	3b c5		 cmp	 eax, ebp

; 127  : 	}
; 128  : 
; 129  : 	if (needtocheck && (start[len - 1] & 1 << 7))

  0004b	76 17		 jbe	 SHORT $LN12@set_amxstr
  0004d	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  00050	f6 04 83 80	 test	 BYTE PTR [ebx+eax*4], 128 ; 00000080H
  00054	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  00057	74 0b		 je	 SHORT $LN12@set_amxstr

; 130  : 	{
; 131  : 		len -= UTIL_CheckValidChar(start + len - 1);

  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ??$UTIL_CheckValidChar@H@@YAHPAH@Z ; UTIL_CheckValidChar<int>
  0005f	83 c4 04	 add	 esp, 4
  00062	2b f0		 sub	 esi, eax
$LN12@set_amxstr:

; 132  : 	}
; 133  : 
; 134  : 	start[len] = '\0';

  00064	5f		 pop	 edi
  00065	c7 04 b3 00 00
	00 00		 mov	 DWORD PTR [ebx+esi*4], 0

; 135  : 
; 136  : 	return len;

  0006c	8b c6		 mov	 eax, esi
  0006e	5e		 pop	 esi
  0006f	5d		 pop	 ebp
  00070	5b		 pop	 ebx

; 137  : }

  00071	c3		 ret	 0
??$set_amxstring_utf8@H@@YAHPAUtagAMX@@HPBHII@Z ENDP	; set_amxstring_utf8<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?copy_amxmemory@@YAXPAH0H@Z
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_len$ = 16						; size = 4
?copy_amxmemory@@YAXPAH0H@Z PROC			; copy_amxmemory, COMDAT

; 202  : 	while (len--)

  00000	8b 54 24 0c	 mov	 edx, DWORD PTR _len$[esp-4]
  00004	85 d2		 test	 edx, edx
  00006	74 1a		 je	 SHORT $LN6@copy_amxme
  00008	8b 44 24 08	 mov	 eax, DWORD PTR _src$[esp-4]
  0000c	56		 push	 esi
  0000d	8b 74 24 08	 mov	 esi, DWORD PTR _dest$[esp]
  00011	2b f0		 sub	 esi, eax
$LL2@copy_amxme:

; 203  : 		*dest++=*src++;

  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
  00015	8d 40 04	 lea	 eax, DWORD PTR [eax+4]
  00018	89 4c 06 fc	 mov	 DWORD PTR [esi+eax-4], ecx
  0001c	83 ea 01	 sub	 edx, 1
  0001f	75 f2		 jne	 SHORT $LL2@copy_amxme
  00021	5e		 pop	 esi
$LN6@copy_amxme:

; 204  : }

  00022	c3		 ret	 0
?copy_amxmemory@@YAXPAH0H@Z ENDP			; copy_amxmemory
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?set_amxstring_utf8_cell@@YAHPAUtagAMX@@HPBHII@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_amx_addr$ = 12						; size = 4
_source$ = 16						; size = 4
_sourcelen$ = 20					; size = 4
_maxlen$ = 24						; size = 4
?set_amxstring_utf8_cell@@YAHPAUtagAMX@@HPBHII@Z PROC	; set_amxstring_utf8_cell, COMDAT

; 146  : 	return set_amxstring_utf8(amx, amx_addr, source, sourcelen, maxlen);

  00000	e9 00 00 00 00	 jmp	 ??$set_amxstring_utf8@H@@YAHPAUtagAMX@@HPBHII@Z ; set_amxstring_utf8<int>
?set_amxstring_utf8_cell@@YAHPAUtagAMX@@HPBHII@Z ENDP	; set_amxstring_utf8_cell
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?set_amxstring_utf8_char@@YAHPAUtagAMX@@HPBDII@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_amx_addr$ = 12						; size = 4
_source$ = 16						; size = 4
_sourcelen$ = 20					; size = 4
_maxlen$ = 24						; size = 4
?set_amxstring_utf8_char@@YAHPAUtagAMX@@HPBDII@Z PROC	; set_amxstring_utf8_char, COMDAT

; 141  : 	return set_amxstring_utf8(amx, amx_addr, source, sourcelen, maxlen);

  00000	e9 00 00 00 00	 jmp	 ??$set_amxstring_utf8@D@@YAHPAUtagAMX@@HPBDII@Z ; set_amxstring_utf8<char>
?set_amxstring_utf8_char@@YAHPAUtagAMX@@HPBDII@Z ENDP	; set_amxstring_utf8_char
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?set_amxstring_simple@@YAHPAHPBDH@Z
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_source$ = 12						; size = 4
_max$ = 16						; size = 4
?set_amxstring_simple@@YAHPAHPBDH@Z PROC		; set_amxstring_simple, COMDAT

; 70   : 	cell* start = dest;
; 71   : 
; 72   : 	while (max-- && *source)

  00000	8b 54 24 0c	 mov	 edx, DWORD PTR _max$[esp-4]
  00004	8b 44 24 04	 mov	 eax, DWORD PTR _dest$[esp-4]
  00008	57		 push	 edi
  00009	8b f8		 mov	 edi, eax
  0000b	85 d2		 test	 edx, edx
  0000d	74 1a		 je	 SHORT $LN10@set_amxstr
  0000f	56		 push	 esi
  00010	8b 74 24 10	 mov	 esi, DWORD PTR _source$[esp+4]
$LL2@set_amxstr:
  00014	8a 0e		 mov	 cl, BYTE PTR [esi]
  00016	4a		 dec	 edx
  00017	84 c9		 test	 cl, cl
  00019	74 0d		 je	 SHORT $LN11@set_amxstr

; 73   : 	{
; 74   : 		*dest++ = (unsigned char)*source++;

  0001b	0f b6 c9	 movzx	 ecx, cl
  0001e	46		 inc	 esi
  0001f	89 08		 mov	 DWORD PTR [eax], ecx
  00021	83 c0 04	 add	 eax, 4
  00024	85 d2		 test	 edx, edx
  00026	75 ec		 jne	 SHORT $LL2@set_amxstr
$LN11@set_amxstr:
  00028	5e		 pop	 esi
$LN10@set_amxstr:

; 75   : 	}
; 76   : 
; 77   : 	*dest = 0;

  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 78   : 
; 79   : 	return dest - start;

  0002f	2b c7		 sub	 eax, edi
  00031	c1 f8 02	 sar	 eax, 2
  00034	5f		 pop	 edi

; 80   : }

  00035	c3		 ret	 0
?set_amxstring_simple@@YAHPAHPBDH@Z ENDP		; set_amxstring_simple
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?set_amxstring@@YAHPAUtagAMX@@HPBDH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_amx_addr$ = 12						; size = 4
_source$ = 16						; size = 4
_max$ = 20						; size = 4
?set_amxstring@@YAHPAUtagAMX@@HPBDH@Z PROC		; set_amxstring, COMDAT

; 84   : 	register cell* dest = (cell *)(amx->base + (int)(((AMX_HEADER *)amx->base)->dat + amx_addr));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _amx$[esp-4]

; 85   : 	register cell* start = dest;
; 86   : 
; 87   : #if defined BINLOG_ENABLED
; 88   : 	if (g_binlog_level & 2)
; 89   : 	{
; 90   : 		CPluginMngr::CPlugin *pl = g_plugins.findPluginFast(amx);
; 91   : 		if (pl)
; 92   : 			g_BinLog.WriteOp(BinLog_SetString, pl->getId(), amx_addr, max, source);
; 93   : 	}
; 94   : #endif
; 95   : 	
; 96   : 	while (max-- && *source)

  00004	8b 54 24 10	 mov	 edx, DWORD PTR _max$[esp-4]
  00008	57		 push	 edi
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0000e	03 c1		 add	 eax, ecx
  00010	03 44 24 0c	 add	 eax, DWORD PTR _amx_addr$[esp]
  00014	8b f8		 mov	 edi, eax
  00016	85 d2		 test	 edx, edx
  00018	74 1b		 je	 SHORT $LN10@set_amxstr
  0001a	56		 push	 esi
  0001b	8b 74 24 14	 mov	 esi, DWORD PTR _source$[esp+4]
  0001f	90		 npad	 1
$LL2@set_amxstr:
  00020	8a 0e		 mov	 cl, BYTE PTR [esi]
  00022	4a		 dec	 edx
  00023	84 c9		 test	 cl, cl
  00025	74 0d		 je	 SHORT $LN11@set_amxstr

; 97   : 		*dest++ = (unsigned char)*source++;

  00027	0f b6 c9	 movzx	 ecx, cl
  0002a	46		 inc	 esi
  0002b	89 08		 mov	 DWORD PTR [eax], ecx
  0002d	83 c0 04	 add	 eax, 4
  00030	85 d2		 test	 edx, edx
  00032	75 ec		 jne	 SHORT $LL2@set_amxstr
$LN11@set_amxstr:
  00034	5e		 pop	 esi
$LN10@set_amxstr:

; 98   : 	
; 99   : 	*dest = 0;

  00035	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 100  : 	
; 101  : 	return dest - start;

  0003b	2b c7		 sub	 eax, edi
  0003d	c1 f8 02	 sar	 eax, 2
  00040	5f		 pop	 edi

; 102  : }

  00041	c3		 ret	 0
?set_amxstring@@YAHPAUtagAMX@@HPBDH@Z ENDP		; set_amxstring
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?amxstring_len@@YAHPAH@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?amxstring_len@@YAHPAH@Z PROC				; amxstring_len, COMDAT

; 55   : 	register int c = 0;
; 56   : 
; 57   : 	while (a[c])

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _a$[esp-4]
  00004	33 c0		 xor	 eax, eax
  00006	39 01		 cmp	 DWORD PTR [ecx], eax
  00008	74 0d		 je	 SHORT $LN3@amxstring_
  0000a	66 0f 1f 44 00
	00		 npad	 6
$LL2@amxstring_:

; 58   : 		++c;

  00010	40		 inc	 eax
  00011	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  00015	75 f9		 jne	 SHORT $LL2@amxstring_
$LN3@amxstring_:

; 59   : 	
; 60   : 	return c;
; 61   : }

  00017	c3		 ret	 0
?amxstring_len@@YAHPAH@Z ENDP				; amxstring_len
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT _get_amxstring_r
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_amx_addr$ = 12						; size = 4
_destination$ = 16					; size = 4
_maxlen$ = 20						; size = 4
_get_amxstring_r PROC					; COMDAT

; 151  : 	register cell *source = (cell *)(amx->base + (int)(((AMX_HEADER *)amx->base)->dat + amx_addr));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _amx$[esp-4]

; 152  : 	register char *dest = destination;

  00004	8b 54 24 0c	 mov	 edx, DWORD PTR _destination$[esp-4]
  00008	56		 push	 esi

; 153  : 	char *start = dest;
; 154  : 
; 155  : 	while (maxlen-- && *source)

  00009	8b 74 24 14	 mov	 esi, DWORD PTR _maxlen$[esp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00012	03 c8		 add	 ecx, eax
  00014	03 4c 24 0c	 add	 ecx, DWORD PTR _amx_addr$[esp]
  00018	85 f6		 test	 esi, esi
  0001a	74 16		 je	 SHORT $LN10@get_amxstr
  0001c	0f 1f 40 00	 npad	 4
$LL2@get_amxstr:
  00020	4e		 dec	 esi
  00021	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00024	74 0c		 je	 SHORT $LN10@get_amxstr

; 156  : 		*dest++=(char)(*source++);

  00026	8a 01		 mov	 al, BYTE PTR [ecx]
  00028	83 c1 04	 add	 ecx, 4
  0002b	88 02		 mov	 BYTE PTR [edx], al
  0002d	42		 inc	 edx
  0002e	85 f6		 test	 esi, esi
  00030	75 ee		 jne	 SHORT $LL2@get_amxstr
$LN10@get_amxstr:

; 157  : 
; 158  : 	*dest = '\0';

  00032	c6 02 00	 mov	 BYTE PTR [edx], 0

; 159  : 
; 160  : #if defined BINLOG_ENABLED
; 161  : 	if (g_binlog_level & 2)
; 162  : 	{
; 163  : 		CPluginMngr::CPlugin *pl = g_plugins.findPluginFast(amx);
; 164  : 		if (pl)
; 165  : 			g_BinLog.WriteOp(BinLog_GetString, pl->getId(), amx_addr, destination);
; 166  : 	}
; 167  : #endif
; 168  : 
; 169  : 	return dest - start;

  00035	2b 54 24 10	 sub	 edx, DWORD PTR _destination$[esp]
  00039	8b c2		 mov	 eax, edx
  0003b	5e		 pop	 esi

; 170  : }

  0003c	c3		 ret	 0
_get_amxstring_r ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?get_amxvector_null@@YAPAHPAUtagAMX@@H@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_amx_addr$ = 12						; size = 4
?get_amxvector_null@@YAPAHPAUtagAMX@@H@Z PROC		; get_amxvector_null, COMDAT

; 190  : {

  00000	56		 push	 esi

; 191  : 	cell *addr = get_amxaddr(amx, amx_addr);

  00001	ff 74 24 0c	 push	 DWORD PTR _amx_addr$[esp]
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR _amx$[esp+4]
  00009	56		 push	 esi
  0000a	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr

; 192  : 	if (addr == g_plugins.findPluginFast(amx)->getNullVectorOfs())

  0000f	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  00012	83 c4 08	 add	 esp, 8
  00015	33 d2		 xor	 edx, edx
  00017	3b 81 c0 00 00
	00		 cmp	 eax, DWORD PTR [ecx+192]
  0001d	5e		 pop	 esi
  0001e	0f 44 c2	 cmove	 eax, edx

; 193  : 	{
; 194  : 		return nullptr;
; 195  : 	}
; 196  : 
; 197  : 	return addr;
; 198  : }

  00021	c3		 ret	 0
?get_amxvector_null@@YAPAHPAUtagAMX@@H@Z ENDP		; get_amxvector_null
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?get_amxstring_null@@YAPADPAUtagAMX@@HHAAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_amx_addr$ = 12						; size = 4
_id$ = 16						; size = 4
_len$ = 20						; size = 4
?get_amxstring_null@@YAPADPAUtagAMX@@HHAAH@Z PROC	; get_amxstring_null, COMDAT

; 180  : {

  00000	56		 push	 esi

; 181  : 	if (get_amxaddr(amx, amx_addr) == g_plugins.findPluginFast(amx)->getNullStringOfs())

  00001	ff 74 24 0c	 push	 DWORD PTR _amx_addr$[esp]
  00005	8b 74 24 0c	 mov	 esi, DWORD PTR _amx$[esp+4]
  00009	56		 push	 esi
  0000a	e8 00 00 00 00	 call	 ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ; get_amxaddr
  0000f	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  00012	83 c4 08	 add	 esp, 8
  00015	3b 81 bc 00 00
	00		 cmp	 eax, DWORD PTR [ecx+188]
  0001b	75 04		 jne	 SHORT $LN2@get_amxstr

; 182  : 	{
; 183  : 		return nullptr;

  0001d	33 c0		 xor	 eax, eax
  0001f	5e		 pop	 esi

; 187  : }

  00020	c3		 ret	 0
$LN2@get_amxstr:

; 184  : 	}
; 185  : 
; 186  : 	return get_amxstring(amx, amx_addr, id, len);

  00021	ff 74 24 14	 push	 DWORD PTR _len$[esp]
  00025	ff 74 24 14	 push	 DWORD PTR _id$[esp+4]
  00029	ff 74 24 14	 push	 DWORD PTR _amx_addr$[esp+8]
  0002d	56		 push	 esi
  0002e	e8 00 00 00 00	 call	 ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ; get_amxstring
  00033	83 c4 10	 add	 esp, 16			; 00000010H
  00036	5e		 pop	 esi

; 187  : }

  00037	c3		 ret	 0
?get_amxstring_null@@YAPADPAUtagAMX@@HHAAH@Z ENDP	; get_amxstring_null
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_amx_addr$ = 12						; size = 4
_id$ = 16						; size = 4
_len$ = 20						; size = 4
?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z PROC		; get_amxstring, COMDAT

; 174  : 	static char buffer[4][16384];
; 175  : 	len = get_amxstring_r(amx, amx_addr, buffer[id], sizeof(buffer[id]) - 1);

  00000	8b 44 24 0c	 mov	 eax, DWORD PTR _id$[esp-4]
  00004	56		 push	 esi
  00005	c1 e0 0e	 shl	 eax, 14			; 0000000eH
  00008	68 ff 3f 00 00	 push	 16383			; 00003fffH
  0000d	8d b0 00 00 00
	00		 lea	 esi, DWORD PTR ?buffer@?1??get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z@4PAY0EAAA@DA[eax]
  00013	56		 push	 esi
  00014	ff 74 24 14	 push	 DWORD PTR _amx_addr$[esp+8]
  00018	ff 74 24 14	 push	 DWORD PTR _amx$[esp+12]
  0001c	e8 00 00 00 00	 call	 _get_amxstring_r
  00021	8b 4c 24 24	 mov	 ecx, DWORD PTR _len$[esp+16]
  00025	83 c4 10	 add	 esp, 16			; 00000010H
  00028	89 01		 mov	 DWORD PTR [ecx], eax

; 176  : 	return buffer[id];

  0002a	8b c6		 mov	 eax, esi
  0002c	5e		 pop	 esi

; 177  : }

  0002d	c3		 ret	 0
?get_amxstring@@YAPADPAUtagAMX@@HHAAH@Z ENDP		; get_amxstring
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?format_amxstring@@YAPADPAUtagAMX@@PAHHAAH@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_params$ = 12						; size = 4
_parm$ = 16						; size = 4
_len$ = 20						; size = 4
?format_amxstring@@YAPADPAUtagAMX@@PAHHAAH@Z PROC	; format_amxstring, COMDAT

; 39   : #if !defined BINLOG_ENABLED
; 40   : 	return g_langMngr.FormatAmxString(amx, params, parm, len);

  00000	ff 74 24 10	 push	 DWORD PTR _len$[esp-4]
  00004	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_langMngr@@3VCLangMngr@@A ; g_langMngr
  00009	ff 74 24 10	 push	 DWORD PTR _parm$[esp]
  0000d	ff 74 24 10	 push	 DWORD PTR _params$[esp+4]
  00011	ff 74 24 10	 push	 DWORD PTR _amx$[esp+8]
  00015	e8 00 00 00 00	 call	 ?FormatAmxString@CLangMngr@@QAEPADPAUtagAMX@@PAHHAAH@Z ; CLangMngr::FormatAmxString

; 41   : #else
; 42   : 	char *ans = g_langMngr.FormatAmxString(amx, params, parm, len);
; 43   : 	if (g_binlog_level & 4)
; 44   : 	{
; 45   : 		CPluginMngr::CPlugin *pl = g_plugins.findPluginFast(amx);
; 46   : 		if (pl)
; 47   : 			g_BinLog.WriteOp(BinLog_FormatString, pl->getId(), parm, len, ans);
; 48   : 	}
; 49   : 	return ans;
; 50   : #endif
; 51   : }

  0001a	c3		 ret	 0
?format_amxstring@@YAPADPAUtagAMX@@PAHHAAH@Z ENDP	; format_amxstring
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?get_amxaddr@@YAPAHPAUtagAMX@@H@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
_amx_addr$ = 12						; size = 4
?get_amxaddr@@YAPAHPAUtagAMX@@H@Z PROC			; get_amxaddr, COMDAT

; 65   : 	return (cell *)(amx->base + (int)(((AMX_HEADER *)amx->base)->dat + amx_addr));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _amx$[esp-4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00009	03 c1		 add	 eax, ecx
  0000b	03 44 24 08	 add	 eax, DWORD PTR _amx_addr$[esp-4]

; 66   : }

  0000f	c3		 ret	 0
?get_amxaddr@@YAPAHPAUtagAMX@@H@Z ENDP			; get_amxaddr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\string.cpp
;	COMDAT ?stristr@@YAPBDPBD0@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
_substr$ = 12						; size = 4
?stristr@@YAPBDPBD0@Z PROC				; stristr, COMDAT

; 16   : {

  00000	53		 push	 ebx

; 17   : 	register char *needle = (char *)substr;

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _substr$[esp]
  00005	55		 push	 ebp

; 18   : 	register char *prevloc = (char *)str;

  00006	8b 6c 24 0c	 mov	 ebp, DWORD PTR _str$[esp+4]
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 19   : 	register char *haystack = (char *)str;

  0000c	8b f5		 mov	 esi, ebp

; 20   : 
; 21   : 	while (*haystack)

  0000e	80 7d 00 00	 cmp	 BYTE PTR [ebp], 0
  00012	74 35		 je	 SHORT $LN12@stristr
$LL2@stristr:

; 22   : 	{
; 23   : 		if (tolower(*haystack) == tolower(*needle))

  00014	0f be 03	 movsx	 eax, BYTE PTR [ebx]
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 _tolower
  0001d	8b f8		 mov	 edi, eax
  0001f	0f be 06	 movsx	 eax, BYTE PTR [esi]
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 _tolower
  00028	83 c4 08	 add	 esp, 8
  0002b	3b c7		 cmp	 eax, edi
  0002d	75 0e		 jne	 SHORT $LN4@stristr

; 24   : 		{
; 25   : 			haystack++;
; 26   : 			if (!*++needle)

  0002f	43		 inc	 ebx
  00030	46		 inc	 esi
  00031	80 3b 00	 cmp	 BYTE PTR [ebx], 0
  00034	75 0e		 jne	 SHORT $LN5@stristr

; 27   : 				return prevloc;

  00036	5f		 pop	 edi
  00037	5e		 pop	 esi
  00038	8b c5		 mov	 eax, ebp
  0003a	5d		 pop	 ebp
  0003b	5b		 pop	 ebx

; 35   : }

  0003c	c3		 ret	 0
$LN4@stristr:

; 28   : 		} else {
; 29   : 			haystack = ++prevloc;
; 30   : 			needle = (char *)substr;

  0003d	8b 5c 24 18	 mov	 ebx, DWORD PTR _substr$[esp+12]
  00041	45		 inc	 ebp
  00042	8b f5		 mov	 esi, ebp
$LN5@stristr:

; 20   : 
; 21   : 	while (*haystack)

  00044	80 3e 00	 cmp	 BYTE PTR [esi], 0
  00047	75 cb		 jne	 SHORT $LL2@stristr
$LN12@stristr:
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5d		 pop	 ebp

; 31   : 		}
; 32   : 	}
; 33   : 
; 34   : 	return NULL;

  0004c	33 c0		 xor	 eax, eax
  0004e	5b		 pop	 ebx

; 35   : }

  0004f	c3		 ret	 0
?stristr@@YAPBDPBD0@Z ENDP				; stristr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\cplugin.h
;	COMDAT ?findPluginFast@CPluginMngr@@QAEPAVCPlugin@1@PAUtagAMX@@@Z
_TEXT	SEGMENT
_amx$ = 8						; size = 4
?findPluginFast@CPluginMngr@@QAEPAVCPlugin@1@PAUtagAMX@@@Z PROC ; CPluginMngr::findPluginFast, COMDAT
; _this$ = ecx

; 128  : 	inline CPlugin* findPluginFast(AMX *amx) { return (CPlugin*)(amx->userdata[UD_FINDPLUGIN]); }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _amx$[esp-4]
  00004	8b 40 48	 mov	 eax, DWORD PTR [eax+72]
  00007	c2 04 00	 ret	 4
?findPluginFast@CPluginMngr@@QAEPAVCPlugin@1@PAUtagAMX@@@Z ENDP ; CPluginMngr::findPluginFast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\cplugin.h
;	COMDAT ?getNullVectorOfs@CPlugin@CPluginMngr@@QBEPAHXZ
_TEXT	SEGMENT
?getNullVectorOfs@CPlugin@CPluginMngr@@QBEPAHXZ PROC	; CPluginMngr::CPlugin::getNullVectorOfs, COMDAT
; _this$ = ecx

; 105  : 		inline cell* getNullVectorOfs() const { return m_pNullVectorOfs; }

  00000	8b 81 c0 00 00
	00		 mov	 eax, DWORD PTR [ecx+192]
  00006	c3		 ret	 0
?getNullVectorOfs@CPlugin@CPluginMngr@@QBEPAHXZ ENDP	; CPluginMngr::CPlugin::getNullVectorOfs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\nightfire_sdk\amx\amxmodx\cplugin.h
;	COMDAT ?getNullStringOfs@CPlugin@CPluginMngr@@QBEPAHXZ
_TEXT	SEGMENT
?getNullStringOfs@CPlugin@CPluginMngr@@QBEPAHXZ PROC	; CPluginMngr::CPlugin::getNullStringOfs, COMDAT
; _this$ = ecx

; 104  : 		inline cell* getNullStringOfs() const { return m_pNullStringOfs; }

  00000	8b 81 bc 00 00
	00		 mov	 eax, DWORD PTR [ecx+188]
  00006	c3		 ret	 0
?getNullStringOfs@CPlugin@CPluginMngr@@QBEPAHXZ ENDP	; CPluginMngr::CPlugin::getNullStringOfs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00000	8d 44 24 0c	 lea	 eax, DWORD PTR __Format$[esp]
  00004	50		 push	 eax
  00005	6a 00		 push	 0
  00007	ff 74 24 10	 push	 DWORD PTR __Format$[esp+4]
  0000b	6a ff		 push	 -1
  0000d	ff 74 24 14	 push	 DWORD PTR __Buffer$[esp+12]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

  0002f	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00000	ff 74 24 10	 push	 DWORD PTR __ArgList$[esp-4]
  00004	ff 74 24 10	 push	 DWORD PTR __Locale$[esp]
  00008	ff 74 24 10	 push	 DWORD PTR __Format$[esp+4]
  0000c	6a ff		 push	 -1
  0000e	ff 74 24 14	 push	 DWORD PTR __Buffer$[esp+12]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 1459 :     #pragma warning(pop)
; 1460 : }

  00030	c3		 ret	 0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1386 :     int const _Result = __stdio_common_vsprintf(

  00000	ff 74 24 14	 push	 DWORD PTR __ArgList$[esp-4]
  00004	ff 74 24 14	 push	 DWORD PTR __Locale$[esp]
  00008	ff 74 24 14	 push	 DWORD PTR __Format$[esp+4]
  0000c	ff 74 24 14	 push	 DWORD PTR __BufferCount$[esp+8]
  00010	ff 74 24 14	 push	 DWORD PTR __Buffer$[esp+12]
  00014	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	ff 70 04	 push	 DWORD PTR [eax+4]
  0001e	83 c9 01	 or	 ecx, 1
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

  00027	83 c9 ff	 or	 ecx, -1
  0002a	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002d	85 c0		 test	 eax, eax
  0002f	0f 48 c1	 cmovs	 eax, ecx

; 1391 : }

  00032	c3		 ret	 0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

  00000	c3		 ret	 0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\string.h
;	COMDAT ?strstr@@YAPADQADQBD@Z
_TEXT	SEGMENT
__String$ = 8						; size = 4
__SubString$ = 12					; size = 4
?strstr@@YAPADQADQBD@Z PROC				; strstr, COMDAT

; 537  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  00000	e9 00 00 00 00	 jmp	 _strstr
?strstr@@YAPADQADQBD@Z ENDP				; strstr
_TEXT	ENDS
END
